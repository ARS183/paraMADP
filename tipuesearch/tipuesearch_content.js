var tipuesearch = {"pages":[{"title":" ParaMADP ","text":"ParaMADP Documentation generated by FORD for the github repository Warning This API documentation for our github repository is a work in progress Developer Info Jinqiang Chen","tags":"home","loc":"index.html"},{"title":"Gridpara – ParaMADP ","text":"type, public :: Gridpara Type definition for grid parameters Components Type Visibility Attributes Name Initial integer(kind=4), public :: nx_global integer(kind=4), public :: ny_global integer(kind=4), public :: nx integer(kind=4), public :: ny real(kind=realdp), public :: hx real(kind=realdp), public :: hy real(kind=realdp), public :: hxhy integer, public, dimension(0:npMax - 1) :: i_offset integer, public, dimension(0:npMax - 1) :: j_offset integer, public, dimension(0:npMax - 1) :: i_nn integer, public, dimension(0:npMax - 1) :: j_nn real(kind=realdp), public, allocatable, dimension(:,:) :: wavenumber_k wavenumber_k: the wavenumber profile of the domain real(kind=realdp), public, allocatable, dimension(:,:) :: wavenumber_kh_pow_2 wavenumber_kh_pow_2 = (kh)&#94;2","tags":"","loc":"type/gridpara.html"},{"title":"matrix – ParaMADP ","text":"type, public :: matrix This is an empty matrix type","tags":"","loc":"type/matrix.html"},{"title":"preconditioner – ParaMADP ","text":"type, public :: preconditioner Components Type Visibility Attributes Name Initial integer, public :: ni integer, public :: nj real(kind=realdp), public :: hx_c real(kind=realdp), public :: hy_c","tags":"","loc":"type/preconditioner.html"},{"title":"TwoGrids – ParaMADP ","text":"type, public :: TwoGrids Type definition for a two-grid system. \"f\" in variable names stands for fine grid, \"c\" in variable names stands for coarse grid Components Type Visibility Attributes Name Initial integer(kind=4), public :: nxf_global integer(kind=4), public :: nyf_global integer(kind=4), public :: nxf integer(kind=4), public :: nyf integer(kind=4), public :: nxc_global integer(kind=4), public :: nyc_global integer(kind=4), public :: nxc integer(kind=4), public :: nyc real(kind=realdp), public :: hxf real(kind=realdp), public :: hyf real(kind=realdp), public :: hxhyf real(kind=realdp), public :: hxc real(kind=realdp), public :: hyc real(kind=realdp), public :: hxhyc integer, public, dimension(0:npMax - 1) :: if_offset integer, public, dimension(0:npMax - 1) :: jf_offset integer, public, dimension(0:npMax - 1) :: if_nn integer, public, dimension(0:npMax - 1) :: jf_nn integer, public, dimension(0:npMax - 1) :: ic_offset integer, public, dimension(0:npMax - 1) :: jc_offset integer, public, dimension(0:npMax - 1) :: ic_nn integer, public, dimension(0:npMax - 1) :: jc_nn real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_f real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_c real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_f real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_c Constructor public        interface TwoGrids public  function FromFine2Coarse (OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: OneGrid Return Value type( TwoGrids )","tags":"","loc":"type/twogrids.html"},{"title":"GridSystem – ParaMADP ","text":"type, public :: GridSystem A data type that collect some info of a (coarse) grid system \nIt is different the type Gridpara, which does not consist any variable like u, rhs, res, and etc. Components Type Visibility Attributes Name Initial integer(kind=4), public :: nxc_global Global grid size, in x and y directions respectively. integer(kind=4), public :: nyc_global Global grid size, in x and y directions respectively. integer(kind=4), public :: nxc Local grid size of a subdomain, in x and y directions respectively. integer(kind=4), public :: nyc Local grid size of a subdomain, in x and y directions respectively. integer, public, dimension(0:npMax - 1) :: ic_offset ic_offset: an array that contains the index offset for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: jc_offset jc_offset: an array that contains the index offset for MPI ranks in y direction integer, public, dimension(0:npMax - 1) :: ic_nn ic_nn: an array that contains the number of grid points for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: jc_nn jc_nn: an array that contains the number of grid points for MPI ranks in y direction real(kind=realdp), public :: hxc space step, hxhyc==hx*hy==hx&#94;2 real(kind=realdp), public :: hyc space step, hxhyc==hx*hy==hx&#94;2 real(kind=realdp), public :: hxhyc space step, hxhyc==hx*hy==hx&#94;2 complex(kind=realdp), public, allocatable, dimension(:,:) :: u_c Solution variable in subdomain complex(kind=realdp), public, allocatable, dimension(:,:) :: rhs_c RHS variable in subdomain complex(kind=realdp), public, allocatable, dimension(:,:) :: res_c Residual variable in subdomain real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_c wavenumber in subdomain real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_c wavenumber in subdomain","tags":"","loc":"type/gridsystem.html"},{"title":"rmatvec – ParaMADP","text":"public  function rmatvec(A, v) This is an empty matrix-vector multiplication for real-type input v Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in) :: v (:,:) Return Value real(kind=realdp), (size(v,1),size(v,2)) Called by proc~~rmatvec~~CalledByGraph proc~rmatvec rmatvec interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~rmatvec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rmatvec.html"},{"title":"cmatvec – ParaMADP","text":"public  function cmatvec(A, v) This is complex matrix-vector multiplication Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in) :: v (:,:) Return Value complex(kind=realdp), (size(v,1),size(v,2)) Calls proc~~cmatvec~~CallsGraph proc~cmatvec cmatvec proc~helmholtz2d_bc Helmholtz2d_BC proc~cmatvec->proc~helmholtz2d_bc proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cmatvec~~CalledByGraph proc~cmatvec cmatvec interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cmatvec.html"},{"title":"rprecon – ParaMADP","text":"public  function rprecon(v, M1) This is an empty preconditioner for real-type input v Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(:,:) :: v type( preconditioner ), intent(in) :: M1 Return Value real(kind=realdp), dimension(size(v,1),size(v,2)) Called by proc~~rprecon~~CalledByGraph proc~rprecon rprecon interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~rprecon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rprecon.html"},{"title":"cprecon – ParaMADP","text":"public  function cprecon(v, M1) This is an preconditioner for complex-type input v, i.e. M1&#94;(-1)v\nWe can manully call different preconditioners here. Here only use multigrid-based CLSP Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (:,:) type( preconditioner ), intent(in) :: M1 Return Value complex(kind=realdp), (size(v,1),size(v,2)) Calls proc~~cprecon~~CallsGraph proc~cprecon cprecon proc~mgcslp_invmx MGCSLP_invMx proc~cprecon->proc~mgcslp_invmx proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cprecon~~CalledByGraph proc~cprecon cprecon interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cprecon.html"},{"title":"OPERATOR(*) – ParaMADP","text":"public interface OPERATOR(*) Calls interface~~operator(ASTERISK)~~CallsGraph interface~operator(ASTERISK) OPERATOR(*) proc~cmatvec cmatvec interface~operator(ASTERISK)->proc~cmatvec proc~rmatvec rmatvec interface~operator(ASTERISK)->proc~rmatvec proc~helmholtz2d_bc Helmholtz2d_BC proc~cmatvec->proc~helmholtz2d_bc proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function rmatvec (A, v) This is an empty matrix-vector multiplication for real-type input v Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in) :: v (:,:) Return Value real(kind=realdp), (size(v,1),size(v,2)) public  function cmatvec (A, v) This is complex matrix-vector multiplication Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in) :: v (:,:) Return Value complex(kind=realdp), (size(v,1),size(v,2))","tags":"","loc":"interface/operator(ASTERISK).html"},{"title":"OPERATOR(/) – ParaMADP","text":"public interface OPERATOR(/) Calls interface~~operator(SLASH)~~CallsGraph interface~operator(SLASH) OPERATOR(/) proc~cprecon cprecon interface~operator(SLASH)->proc~cprecon proc~rprecon rprecon interface~operator(SLASH)->proc~rprecon proc~mgcslp_invmx MGCSLP_invMx proc~cprecon->proc~mgcslp_invmx proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function rprecon (v, M1) This is an empty preconditioner for real-type input v Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(:,:) :: v type( preconditioner ), intent(in) :: M1 Return Value real(kind=realdp), dimension(size(v,1),size(v,2)) public  function cprecon (v, M1) This is an preconditioner for complex-type input v, i.e. M1&#94;(-1)v\nWe can manully call different preconditioners here. Here only use multigrid-based CLSP Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (:,:) type( preconditioner ), intent(in) :: M1 Return Value complex(kind=realdp), (size(v,1),size(v,2))","tags":"","loc":"interface/operator(SLASH).html"},{"title":"norm – ParaMADP","text":"public  function norm(v) Compute the L2-norm of a complex variable, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v Return Value real(kind=realdp) Calls proc~~norm~~CallsGraph proc~norm norm mpi_allreduce mpi_allreduce proc~norm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~norm~~CalledByGraph proc~norm norm proc~arnoldi arnoldi proc~arnoldi->proc~norm proc~full_pgcr full_pgcr proc~full_pgcr->proc~norm proc~full_pgmres full_pgmres proc~full_pgmres->proc~norm proc~fullgmres fullgmres proc~fullgmres->proc~norm proc~fullgmres->proc~arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~norm proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~norm proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~norm proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~norm proc~restartgmres restartgmres proc~restartgmres->proc~norm proc~restartgmres->proc~arnoldi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/norm.html"},{"title":"Realnorm – ParaMADP","text":"public  function Realnorm(v) Compute the L2-norm of a real variable, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v Return Value real(kind=realdp) Calls proc~~realnorm~~CallsGraph proc~realnorm Realnorm mpi_allreduce mpi_allreduce proc~realnorm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/realnorm.html"},{"title":"dot_prod – ParaMADP","text":"public  function dot_prod(v, w) Compute the do product of two complex variables, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: w Return Value complex(kind=realdp) Calls proc~~dot_prod~~CallsGraph proc~dot_prod dot_prod mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dot_prod~~CalledByGraph proc~dot_prod dot_prod proc~arnoldi arnoldi proc~arnoldi->proc~dot_prod proc~full_pgcr full_pgcr proc~full_pgcr->proc~dot_prod proc~full_pgmres full_pgmres proc~full_pgmres->proc~dot_prod proc~pfgmres pfgmres proc~pfgmres->proc~dot_prod proc~prearnoldi Prearnoldi proc~prearnoldi->proc~dot_prod proc~fullgmres fullgmres proc~fullgmres->proc~arnoldi proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~prearnoldi proc~restartgmres restartgmres proc~restartgmres->proc~arnoldi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dot_prod.html"},{"title":"mg_norm – ParaMADP","text":"public  function mg_norm(v, ni, nj) Compute the L2-norm of a complex variable, for a coarse-grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v integer, intent(in) :: ni ni, nj: grid size of the subdomain on the current coarse grid level integer, intent(in) :: nj ni, nj: grid size of the subdomain on the current coarse grid level Return Value real(kind=realdp) Calls proc~~mg_norm~~CallsGraph proc~mg_norm mg_norm mpi_allreduce mpi_allreduce proc~mg_norm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_norm~~CalledByGraph proc~mg_norm mg_norm proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~ex proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~mg_norm proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~mg_norm proc~mg_bicgstab mg_bicgstab proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres mg_fullgmres proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~mg_arnoldi proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~mg_norm proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~mg_norm proc~f_cycle F_cycle proc~f_cycle->proc~mg_bicgstab proc~f_cycle->proc~mg_fullgmres proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~multilevel_invey MultiLevel_invEy proc~multilevel_invey->proc~def_prefgmres proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~multilevel_invey proc~multileveladp_px->proc~mgcslp_invmhx proc~qx Qx proc~qx->proc~invey proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~ex->proc~mgcslp_invmhx proc~p_adef1x->proc~mgcslp_invmx proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~precond_x->proc~def_px proc~px Px proc~px->proc~qx interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_norm.html"},{"title":"mg_dot_prod – ParaMADP","text":"public  function mg_dot_prod(v, w, ni, nj) Compute the dot product of two complex variables, for a coarse-grid system.\nNote that the dimension is not specified here, it means it calculate all the elements Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: w integer, intent(in) :: ni ni, nj: grid size of the subdomain on the current coarse grid level integer, intent(in) :: nj ni, nj: grid size of the subdomain on the current coarse grid level Return Value complex(kind=realdp) Calls proc~~mg_dot_prod~~CallsGraph proc~mg_dot_prod mg_dot_prod mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_dot_prod~~CalledByGraph proc~mg_dot_prod mg_dot_prod proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mg_dot_prod proc~mgcslp_invmhx MGCSLP_invMHx proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~mg_dot_prod proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~mg_dot_prod proc~mg_bicgstab mg_bicgstab proc~mg_bicgstab->proc~mg_dot_prod proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~mg_dot_prod proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~ex proc~f_cycle F_cycle proc~f_cycle->proc~mg_bicgstab proc~f_cycle->proc~f_cycle proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_fullgmres->proc~mg_arnoldi proc~multilevel_invey MultiLevel_invEy proc~multilevel_invey->proc~def_prefgmres proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~multilevel_invey proc~multileveladp_px->proc~mgcslp_invmhx proc~qx Qx proc~qx->proc~invey proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~ex->proc~mgcslp_invmhx proc~p_adef1x->proc~mgcslp_invmx proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~precond_x->proc~def_px proc~px Px proc~px->proc~qx interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_dot_prod.html"},{"title":"LOG2 – ParaMADP","text":"public  function LOG2(x) Compute log2(x) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: x Return Value real(kind=realdp) Called by proc~~log2~~CalledByGraph proc~log2 LOG2 proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~cslp_mx_nth_stencils->proc~log2 proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~log2 proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth_stencils->proc~log2 proc~multilevel_invey MultiLevel_invEy proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~log2 proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~multilevel_invey proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~cslp_mx_nth program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~log2 proc~full_pgcr full_pgcr program~helmholtz_2d->proc~full_pgcr proc~full_pgmres full_pgmres program~helmholtz_2d->proc~full_pgmres proc~pfgmres pfgmres program~helmholtz_2d->proc~pfgmres proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d->proc~pre_fullgmres proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d->proc~pre_restartgmres proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr->proc~precond_x proc~full_pgmres->proc~precond_x proc~pfgmres->proc~precond_x proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/log2.html"},{"title":"Helm_Ax_nth – ParaMADP","text":"public  function Helm_Ax_nth(v_in, grid) ReD-Glk Helmholtz operator for coarse levels Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Parameters of the current grid system Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Calls proc~~helm_ax_nth~~CallsGraph proc~helm_ax_nth Helm_Ax_nth proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~log2 LOG2 proc~helm_ax_nth->proc~log2 proc~mg_check_xy2d mg_check_xy2d proc~helm_ax_nth->proc~mg_check_xy2d proc~helm_ax_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helm_ax_nth~~CalledByGraph proc~helm_ax_nth Helm_Ax_nth proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~helm_ax_nth proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helm_ax_nth.html"},{"title":"CSLP_Mx_nth – ParaMADP","text":"public  function CSLP_Mx_nth(v_in, grid) ReD-Glk CSLP operator for coarse levels Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Calls proc~~cslp_mx_nth~~CallsGraph proc~cslp_mx_nth CSLP_Mx_nth proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~log2 LOG2 proc~cslp_mx_nth->proc~log2 proc~mg_check_xy2d mg_check_xy2d proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cslp_mx_nth~~CalledByGraph proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~krylovcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cslp_mx_nth.html"},{"title":"Helmholtz2d_stencils – ParaMADP","text":"public  subroutine Helmholtz2d_stencils(ap, an, as, aw, ae, hxhykxy2) Computational stencils for the Helmholtz operator, second-order central FD scheme Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae real(kind=realdp), intent(in) :: hxhykxy2 The value of (kh)&#94;2, which is computed and stored in advance. Called by proc~~helmholtz2d_stencils~~CalledByGraph proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~precond_x Precond_x proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~full_pgmres->proc~precond_x proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx Helm_Ahx proc~helm_ahx->proc~helmholtz2d_bc_mg proc~multileveladp_px->proc~helm_ax_nth proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_fullgmres->proc~precond_x proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~precond_x proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~ex Ex proc~ex->proc~helm_a2hx proc~ex->proc~helm_ahx proc~multilevel_invey->proc~def_prefgmres proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~precond_x->proc~def_px proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx->proc~invey Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helmholtz2d_stencils.html"},{"title":"cslp2d_stencils – ParaMADP","text":"public  subroutine cslp2d_stencils(ap, an, as, aw, ae, hxhykxy2) Computational stencils for the CSLP operator Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae real(kind=realdp), intent(in) :: hxhykxy2 The value of (kh)&#94;2, which is computed and stored in advance Called by proc~~cslp2d_stencils~~CalledByGraph proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~ex->proc~mgcslp_invmhx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cslp2d_stencils.html"},{"title":"Helmholtz2d_BC – ParaMADP","text":"public  subroutine Helmholtz2d_BC(v_in, v_out) matrix-free Helmholtz operator, ONLY for the default gird system\nFirst deal with the boundary grid points and then the internals Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v_out Calls proc~~helmholtz2d_bc~~CallsGraph proc~helmholtz2d_bc Helmholtz2d_BC proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmholtz2d_bc~~CalledByGraph proc~helmholtz2d_bc Helmholtz2d_BC proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~helmholtz2d_bc proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helmholtz2d_bc.html"},{"title":"Helmholtz2d_BC_mg – ParaMADP","text":"public  subroutine Helmholtz2d_BC_mg(v_in, v_out, ni, nj, hx_c, hy_c, kxy, kh2) matrix-free Helmholtz operator, for the specified coarse gird systems Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_out integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 Calls proc~~helmholtz2d_bc_mg~~CallsGraph proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmholtz2d_bc_mg~~CalledByGraph proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_ahx Helm_Ahx proc~helm_ahx->proc~helmholtz2d_bc_mg proc~ex Ex proc~ex->proc~helm_a2hx proc~ex->proc~helm_ahx proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helmholtz2d_bc_mg.html"},{"title":"CSLP_OP_BC – ParaMADP","text":"public  subroutine CSLP_OP_BC(v_in, v_out, ni, nj, hx_c, hy_c, kxy, kh2) matrix-free CSLP operator, for the specified gird systems Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_out integer, intent(in) :: ni ni,nj: grid size of subdomain on the current grid level integer, intent(in) :: nj ni,nj: grid size of subdomain on the current grid level real(kind=realdp), intent(in) :: hx_c hx_c,hy_c: space step of subdomain on the current grid level real(kind=realdp), intent(in) :: hy_c hx_c,hy_c: space step of subdomain on the current grid level real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy kxy: wavenumber profile of subdomain on the current grid level,kh2=(kh)&#94;2 real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 kxy: wavenumber profile of subdomain on the current grid level,kh2=(kh)&#94;2 Calls proc~~cslp_op_bc~~CallsGraph proc~cslp_op_bc CSLP_OP_BC proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cslp_op_bc~~CalledByGraph proc~cslp_op_bc CSLP_OP_BC proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cslp_op_bc.html"},{"title":"GridBase_ExtrpltGhostBCs – ParaMADP","text":"public  subroutine GridBase_ExtrpltGhostBCs(v_in, grid) Extrapolation of a layer of ghost grid points Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Called by proc~~gridbase_extrpltghostbcs~~CalledByGraph proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~krylovcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gridbase_extrpltghostbcs.html"},{"title":"Helm_Ax_nth_stencils – ParaMADP","text":"public  subroutine Helm_Ax_nth_stencils(Stcl_nth, grid, ic, jc) ReD-Glk computational stencils of the Helmholtz operator for differnet coarse-grid level\nDefault 2nd-ordr stencils Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: Stcl_nth (-3:3,-3:3) Resulting stencils for the Helmholtz operator type( Gridpara ), intent(inout) :: grid parameters for the current coarse-grid system integer :: ic Index for the wavenumber field integer :: jc Index for the wavenumber field Calls proc~~helm_ax_nth_stencils~~CallsGraph proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~log2 LOG2 proc~helm_ax_nth_stencils->proc~log2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helm_ax_nth_stencils~~CalledByGraph proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~helm_ax_nth proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helm_ax_nth_stencils.html"},{"title":"CSLP_Mx_nth_stencils – ParaMADP","text":"public  subroutine CSLP_Mx_nth_stencils(Stcl_nth, grid, ic, jc) ReD-Glk computational stencils of the CSLP operator for differnet coarse-grid level Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: Stcl_nth (-3:3,-3:3) Resulting stencils for the CSLP operator type( Gridpara ), intent(inout) :: grid parameters for the current coarse-grid system integer :: ic Index for the wavenumber field integer :: jc Index for the wavenumber field Calls proc~~cslp_mx_nth_stencils~~CallsGraph proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~log2 LOG2 proc~cslp_mx_nth_stencils->proc~log2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cslp_mx_nth_stencils~~CalledByGraph proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~krylovcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cslp_mx_nth_stencils.html"},{"title":"TRACE_DOT – ParaMADP","text":"public interface TRACE_DOT Module Procedures private  function CTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value complex(kind=realdp) private  function RTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) real(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp) private  function RCTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value complex(kind=realdp)","tags":"","loc":"interface/trace_dot.html"},{"title":"P_DOT – ParaMADP","text":"public interface P_DOT Module Procedures private  function CP_DOT(P, R0, w, s) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), allocatable :: P (:,:,:) complex(kind=realdp), intent(in), allocatable :: R0 (:,:) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) integer :: s Return Value complex(kind=realdp), (s) private  function RP_DOT(P, R0, w, s) made a big mistake here, only found after done numerous tests, Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), allocatable :: P (:,:,:) real(kind=realdp), intent(in), allocatable :: R0 (:,:) real(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) integer :: s Return Value real(kind=realdp), (s)","tags":"","loc":"interface/p_dot.html"},{"title":"FROB_NORM – ParaMADP","text":"public interface FROB_NORM Module Procedures private  function CFROB_NORM(v) Frobenius norm of complex matrix Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp) private  function RFROB_NORM(v) Frobenius norm of real matrix Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp)","tags":"","loc":"interface/frob_norm.html"},{"title":"IDRS – ParaMADP","text":"public interface IDRS Called by interface~~idrs~~CalledByGraph interface~idrs IDRS program~helmholtz_2d helmholtz_2d program~helmholtz_2d->interface~idrs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  function CIDRS(A, b, M1, s, tolerance, maximum_iterations, variant, flag, relres, iterations, x0, U0, omega, resvec, H) +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in), allocatable :: b (:,:) type( preconditioner ), intent(in) :: M1 integer, intent(in) :: s real(kind=realdp), intent(in), optional :: tolerance integer, intent(in), optional :: maximum_iterations character(len=8), intent(in), optional :: variant integer, intent(out), optional :: flag real(kind=realdp), intent(out), optional :: relres integer, intent(out), optional :: iterations complex(kind=realdp), intent(in), optional :: x0 (:,:) complex(kind=realdp), intent(in), optional :: U0 (:,:,:) complex(kind=realdp), intent(in), optional :: omega (:) real(kind=realdp), intent(out), optional :: resvec (:) complex(kind=realdp), intent(out), optional :: H (:,:) Return Value complex(kind=realdp), (size(b,1),size(b,2)) private  function RIDRS(A, b, M1, s, tolerance, maximum_iterations, variant, flag, relres, iterations, x0, U0, omega, H, resvec) +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in), allocatable :: b (:,:) type( preconditioner ), intent(in) :: M1 integer, intent(in) :: s real(kind=realdp), intent(in), optional :: tolerance integer, intent(in), optional :: maximum_iterations character(len=8), intent(in), optional :: variant integer, intent(out), optional :: flag real(kind=realdp), intent(out), optional :: relres integer, intent(out), optional :: iterations real(kind=realdp), intent(in), optional :: x0 (:,:) real(kind=realdp), intent(in), optional :: U0 (:,:,:) real(kind=realdp), intent(in), optional :: omega (:) real(kind=realdp), intent(out), optional :: H (:,:) real(kind=realdp), intent(out), optional :: resvec (:) Return Value real(kind=realdp), (size(b,1),size(b,2))","tags":"","loc":"interface/idrs.html"},{"title":"read_parameter – ParaMADP","text":"public  subroutine read_parameter() read the input parameters for the solver settings\nRead by Rank 0 and then broadcast to the other ranks\nGet the input filename The Default input filename is Input/Helmholtz.in Arguments None Calls proc~~read_parameter~~CallsGraph proc~read_parameter read_parameter mpi_barrier mpi_barrier proc~read_parameter->mpi_barrier mpi_bcast mpi_bcast proc~read_parameter->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_parameter~~CalledByGraph proc~read_parameter read_parameter program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~read_parameter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_parameter.html"},{"title":"if_BCs – ParaMADP","text":"public  subroutine if_BCs(ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c, kxy) Determine which BC, for specified coarse grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in) :: kxy Calls proc~~if_bcs~~CallsGraph proc~if_bcs if_BCs proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~if_bcs~~CalledByGraph proc~if_bcs if_BCs proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~if_bcs proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~if_bcs proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~precond_x Precond_x proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~full_pgmres->proc~precond_x proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_ahx Helm_Ahx proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_fullgmres->proc~precond_x proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~precond_x proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec proc~ex Ex proc~ex->proc~helm_a2hx proc~ex->proc~helm_ahx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~precond_x->proc~mgcslp_invmx proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/if_bcs.html"},{"title":"Dirichlet – ParaMADP","text":"public  subroutine Dirichlet(ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c) Dirichlet, ap=h&#94;2, which will devided by h&#94;2 in the rountine of the operator\nWhen use this Dirichlet, you have to be carefull with the RHS respectively Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c Called by proc~~dirichlet~~CalledByGraph proc~dirichlet Dirichlet proc~if_bcs if_BCs proc~if_bcs->proc~dirichlet proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~if_bcs proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~if_bcs proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~precond_x Precond_x proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~full_pgmres->proc~precond_x proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_ahx Helm_Ahx proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_fullgmres->proc~precond_x proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~precond_x proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec proc~ex Ex proc~ex->proc~helm_a2hx proc~ex->proc~helm_ahx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~precond_x->proc~mgcslp_invmx proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dirichlet.html"},{"title":"first_order_Neum – ParaMADP","text":"public  subroutine first_order_Neum(ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c, kxy) Sommerfeld boundary conditions. Eliminate the ghost grid points by second-order discretization Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in) :: kxy Called by proc~~first_order_neum~~CalledByGraph proc~first_order_neum first_order_Neum proc~if_bcs if_BCs proc~if_bcs->proc~first_order_neum proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~if_bcs proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~if_bcs proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~precond_x Precond_x proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~full_pgmres->proc~precond_x proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_ahx Helm_Ahx proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_fullgmres->proc~precond_x proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~precond_x proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec proc~ex Ex proc~ex->proc~helm_a2hx proc~ex->proc~helm_ahx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~precond_x->proc~mgcslp_invmx proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/first_order_neum.html"},{"title":"DEF_Px – ParaMADP","text":"public  function DEF_Px(x) Identifier for different deflation methods, ONLY for an input array from the default (finest) grid system\nA basic deflation method Adapted deflation method, including higher-order deflation vectors Two-level Krylov Method Multilevel deflation method Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: x Return Value complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) Calls proc~~def_px~~CallsGraph proc~def_px DEF_Px proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~mgcslp_invmx MGCSLP_invMx proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~helm_ax_nth->proc~mg_check_xy2d proc~grid_destroy grid_destroy proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~mgcslp_invmx->proc~grid_destroy proc~mgcslp_invmx->proc~v_cycle proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~mg_dot_prod mg_dot_prod proc~def_prefgmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_prefgmres->proc~mg_norm proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp_op_bc->proc~if_bcs proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~coarsegridpara proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_fullgmres->proc~mg_norm proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_bicgstab->proc~cslp_op_bc proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_norm->mpi_allreduce proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_px~~CalledByGraph proc~def_px DEF_Px proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_px.html"},{"title":"FromFine2Coarse – ParaMADP","text":"public  function FromFine2Coarse(OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: OneGrid Return Value type( TwoGrids ) Calls proc~~fromfine2coarse~~CallsGraph proc~fromfine2coarse FromFine2Coarse proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~fromfine2coarse->proc~wavenumber_fwrestriction proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fromfine2coarse~~CalledByGraph proc~fromfine2coarse FromFine2Coarse interface~twogrids TwoGrids interface~twogrids->proc~fromfine2coarse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fromfine2coarse.html"},{"title":"CoarseGridpara – ParaMADP","text":"public  function CoarseGridpara(f2c) A procedure to create a Gridpara type of the coarse grid system from a given a two-grid system Arguments Type Intent Optional Attributes Name type( TwoGrids ), intent(inout) :: f2c Return Value type( Gridpara ) Called by proc~~coarsegridpara~~CalledByGraph proc~coarsegridpara CoarseGridpara proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~coarsegridpara proc~def_fullgmres->proc~ex proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~coarsegridpara proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~ex->proc~coarsegridpara proc~def_arnoldi->proc~ex proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey MultiLevel_invEy proc~multilevel_invey->proc~def_prefgmres proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/coarsegridpara.html"},{"title":"ZTx – ParaMADP","text":"public  function ZTx(x, f2c) Restriction of a variable, by full-weight restriction or higher-order restriction depending on the laylers of overlapping grid points used. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~ztx~~CallsGraph proc~ztx ZTx proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ztx~~CalledByGraph proc~ztx ZTx proc~ex Ex proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~ztx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~ztx proc~invey invEy proc~qx->proc~invey proc~ztzx->proc~ztx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ztx.html"},{"title":"Zx – ParaMADP","text":"public  function Zx(x, f2c) Interpolation of a variable from coarse to fine, by bilinear or higher-order interpolation depending on the laylers of overlapping grid points used. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~zx~~CallsGraph proc~zx Zx proc~mg_check_xy2d mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~zx~~CalledByGraph proc~zx Zx proc~ex Ex proc~ex->proc~zx proc~ztzx ZTZx proc~ex->proc~ztzx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~zx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~ztzx->proc~zx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/zx.html"},{"title":"ZTZx – ParaMADP","text":"public  function ZTZx(x, f2c) A routine that first perform restriction and then interpolation Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~ztzx~~CallsGraph proc~ztzx ZTZx proc~ztx ZTx proc~ztzx->proc~ztx proc~zx Zx proc~ztzx->proc~zx proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ztzx~~CalledByGraph proc~ztzx ZTZx proc~ex Ex proc~ex->proc~ztzx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ztzx.html"},{"title":"Helm_Ahx – ParaMADP","text":"public  function Helm_Ahx(x, f2c) A function that performs the Helmholtz operator on the fine grid of the two-grid system, by ReD-O2 method Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~helm_ahx~~CallsGraph proc~helm_ahx Helm_Ahx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helm_ahx~~CalledByGraph proc~helm_ahx Helm_Ahx proc~ex Ex proc~ex->proc~helm_ahx proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helm_ahx.html"},{"title":"Helm_A2hx – ParaMADP","text":"public  function Helm_A2hx(x, f2c) A function that performs the Helmholtz operator on the coarse grid of the two-grid system, by different methods\nReD-O2\nReD-Glk\nReD-cmpO4 Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~helm_a2hx~~CallsGraph proc~helm_a2hx Helm_A2hx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helm_a2hx~~CalledByGraph proc~helm_a2hx Helm_A2hx proc~ex Ex proc~ex->proc~helm_a2hx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helm_a2hx.html"},{"title":"Ex – ParaMADP","text":"public  function Ex(x, f2c) Coarse-grid operation for two-level deflation\nStraight-forward Galerkin coarsening approach Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~ex~~CallsGraph proc~ex Ex proc~coarsegridpara CoarseGridpara proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~ztx ZTx proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~zx Zx proc~ex->proc~zx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~zx->proc~mg_check_xy2d proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ex~~CalledByGraph proc~ex Ex proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ex.html"},{"title":"invEy – ParaMADP","text":"public  function invEy(y, f2c) Invert the coarse-grid operator for two-level delfation method, by using GMRES or Bi-CGSTAB\ndetermined by the specified maximum number of iterations on the coarse grid Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~invey~~CallsGraph proc~invey invEy proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztx ZTx proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~zx Zx proc~ex->proc~zx mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~invey~~CalledByGraph proc~invey invEy proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/invey.html"},{"title":"MultiLevel_invEy – ParaMADP","text":"public recursive function MultiLevel_invEy(y, f2c) A recursive function to invert the coarse-level operators for multilevel delfation methods, by using preconditioned FGMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) Calls proc~~multilevel_invey~~CallsGraph proc~multilevel_invey MultiLevel_invEy proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~log2 LOG2 proc~multilevel_invey->proc~log2 cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth Helm_Ax_nth proc~def_prefgmres->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~mg_dot_prod mg_dot_prod proc~def_prefgmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_prefgmres->proc~mg_norm proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~helm_ax_nth->proc~mg_check_xy2d proc~grid_destroy grid_destroy proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~multileveladp_px->proc~multilevel_invey proc~multileveladp_px->proc~log2 proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~krylovcslp_invmhx proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~helm_ax_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~gridsys_define proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~f_cycle proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_mx_nth_stencils->proc~log2 proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~multilevel_invey~~CalledByGraph proc~multilevel_invey MultiLevel_invEy proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~multilevel_invey proc~def_prefgmres->proc~multileveladp_px proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multilevel_invey.html"},{"title":"Qx – ParaMADP","text":"public  function Qx(x, f2c) Perform y=Qx in deflation definition, where Q=ZE&#94;(-1)Z&#94;T Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~qx~~CallsGraph proc~qx Qx proc~invey invEy proc~qx->proc~invey proc~ztx ZTx proc~qx->proc~ztx proc~zx Zx proc~qx->proc~zx proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztzx ZTZx proc~ex->proc~ztzx mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~qx~~CalledByGraph proc~qx Qx proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/qx.html"},{"title":"Px – ParaMADP","text":"public  function Px(x, f2c) Perform y=Px in deflation definition, where P=I-AQ Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~px~~CallsGraph proc~px Px proc~helm_ahx Helm_Ahx proc~px->proc~helm_ahx proc~qx Qx proc~px->proc~qx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~invey invEy proc~qx->proc~invey proc~ztx ZTx proc~qx->proc~ztx proc~zx Zx proc~qx->proc~zx proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~helm_ahx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~cslp_op_bc->proc~if_bcs proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/px.html"},{"title":"P_DEFx – ParaMADP","text":"public  function P_DEFx(x, f2c) Deflation preconditioning, P = (I-AQ)+Q Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~p_defx~~CallsGraph proc~p_defx P_DEFx proc~helm_ahx Helm_Ahx proc~p_defx->proc~helm_ahx proc~qx Qx proc~p_defx->proc~qx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~invey invEy proc~qx->proc~invey proc~ztx ZTx proc~qx->proc~ztx proc~zx Zx proc~qx->proc~zx proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~helm_ahx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~cslp_op_bc->proc~if_bcs proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~p_defx~~CalledByGraph proc~p_defx P_DEFx proc~def_px DEF_Px proc~def_px->proc~p_defx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/p_defx.html"},{"title":"P_ADEF1x – ParaMADP","text":"public  function P_ADEF1x(x, f2c) Adapted Deflation Preconditioning, P = M&#94;(-1)(I-AQ)+Q, including higher-order deflation (ADP) if LAP > 1 Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~p_adef1x~~CallsGraph proc~p_adef1x P_ADEF1x proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~mgcslp_invmx MGCSLP_invMx proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~invey invEy proc~qx->proc~invey proc~ztx ZTx proc~qx->proc~ztx proc~zx Zx proc~qx->proc~zx proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~if_bcs proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_bicgstab->proc~cslp_op_bc proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~helm_ahx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~p_adef1x~~CalledByGraph proc~p_adef1x P_ADEF1x proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/p_adef1x.html"},{"title":"MultiLevelADP_Px – ParaMADP","text":"public recursive function MultiLevelADP_Px(x, grid) Multilevel deflation preconditioning (MADP) \nMultigrid-based CSLP on the finest and second level\nKrylov-based CSLP on the finest and second level Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: x (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Calls proc~~multileveladp_px~~CallsGraph proc~multileveladp_px MultiLevelADP_Px proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~helm_ax_nth->proc~mg_check_xy2d proc~grid_destroy grid_destroy proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~mg_dot_prod mg_dot_prod proc~def_prefgmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_prefgmres->proc~mg_norm proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~mg_bicgstab->proc~cslp_op_bc proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_norm->mpi_allreduce proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~cslp_mx_nth_stencils->proc~log2 proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~multileveladp_px~~CalledByGraph proc~multileveladp_px MultiLevelADP_Px proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multileveladp_px.html"},{"title":"P_TLKMx – ParaMADP","text":"public  function P_TLKMx(x, f2c) Two-Level Krylov Method, P = [(I-M&#94;(-1)AQ )+Q ]M&#94;(-1), where Q' is defined based on M&#94;(-1)A\nM&#94;(-1)x\nQM&#94;(-1)x AQM&#94;(-1)x\nM&#94;(-1)AQM&#94;(-1)x [(I-M&#94;(-1)AQ)+Q]M&#94;(-1) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Calls proc~~p_tlkmx~~CallsGraph proc~p_tlkmx P_TLKMx proc~helm_ahx Helm_Ahx proc~p_tlkmx->proc~helm_ahx proc~mgcslp_invmx MGCSLP_invMx proc~p_tlkmx->proc~mgcslp_invmx proc~qx Qx proc~p_tlkmx->proc~qx proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~invey invEy proc~qx->proc~invey proc~ztx ZTx proc~qx->proc~ztx proc~zx Zx proc~qx->proc~zx proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc_mg->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~if_bcs proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~mgcslp_invmhx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_bicgstab->proc~cslp_op_bc proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~helm_ahx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~p_tlkmx~~CalledByGraph proc~p_tlkmx P_TLKMx proc~def_px DEF_Px proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/p_tlkmx.html"},{"title":"default_gridpara – ParaMADP","text":"public  subroutine default_gridpara(finestgrid) This is a rountine to define the default finest Gridpara from the common grid parameters of the whole project Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: finestgrid Called by proc~~default_gridpara~~CalledByGraph proc~default_gridpara default_gridpara proc~def_px DEF_Px proc~def_px->proc~default_gridpara proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/default_gridpara.html"},{"title":"wavenumber_FWrestriction – ParaMADP","text":"public  subroutine wavenumber_FWrestriction(f2c) This routine obtains the wavenumber of the coarse level by full-weight restriction from the fine level Arguments Type Intent Optional Attributes Name type( TwoGrids ), intent(inout) :: f2c Calls proc~~wavenumber_fwrestriction~~CallsGraph proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~wavenumber_fwrestriction~~CalledByGraph proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~fromfine2coarse FromFine2Coarse proc~fromfine2coarse->proc~wavenumber_fwrestriction interface~twogrids TwoGrids interface~twogrids->proc~fromfine2coarse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/wavenumber_fwrestriction.html"},{"title":"DEF_fullgmres – ParaMADP","text":"public  subroutine DEF_fullgmres(y, x, f2c) A (CSLP preconditioned) GMRES solver for the coarse-grid problem in two-level deflation method\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"def_mg_miter+1\".So we need a k. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Calls proc~~def_fullgmres~~CallsGraph proc~def_fullgmres DEF_fullgmres proc~coarsegridpara CoarseGridpara proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~ex Ex proc~def_fullgmres->proc~ex proc~mg_norm mg_norm proc~def_fullgmres->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_fullgmres->proc~mgcslp_invmhx cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~mgcslp_invmhx proc~mg_dot_prod mg_dot_prod proc~def_arnoldi->proc~mg_dot_prod proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztx ZTx proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~zx Zx proc~ex->proc~zx mpi_allreduce mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_dot_prod->mpi_allreduce proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~cslp_op_bc proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~cslp_op_bc mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_fullgmres~~CalledByGraph proc~def_fullgmres DEF_fullgmres proc~invey invEy proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_fullgmres.html"},{"title":"def_arnoldi – ParaMADP","text":"public  subroutine def_arnoldi(V, H, k, f2c, CurrentGrid) Arnoldi prosess of DEF_fullgmres\nAttention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP,def_mg_miter+1) :: V complex(kind=realdp), intent(inout), dimension(def_mg_miter+1,def_mg_miter) :: H integer, intent(in) :: k type( TwoGrids ), intent(inout) :: f2c type( Gridpara ) :: CurrentGrid Calls proc~~def_arnoldi~~CallsGraph proc~def_arnoldi def_arnoldi proc~ex Ex proc~def_arnoldi->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_arnoldi->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_arnoldi->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_arnoldi->proc~mgcslp_invmhx proc~ex->proc~mgcslp_invmhx proc~coarsegridpara CoarseGridpara proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztx ZTx proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~zx Zx proc~ex->proc~zx mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_arnoldi~~CalledByGraph proc~def_arnoldi def_arnoldi proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_arnoldi.html"},{"title":"def_apply_givens_rotation – ParaMADP","text":"public  subroutine def_apply_givens_rotation(H, cs, sn, k) Apply givens rotation of DEF_fullgmres Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(def_mg_miter+1,def_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: cs complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: sn integer, intent(in) :: k Calls proc~~def_apply_givens_rotation~~CallsGraph proc~def_apply_givens_rotation def_apply_givens_rotation cdsqrt cdsqrt proc~def_apply_givens_rotation->cdsqrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_apply_givens_rotation~~CalledByGraph proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~def_apply_givens_rotation proc~invey invEy proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_apply_givens_rotation.html"},{"title":"def_back_substitute – ParaMADP","text":"public  subroutine def_back_substitute(H, beta, k) Perform back substitute in of DEF_fullgmres Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(def_mg_miter+1,def_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: beta integer, intent(in) :: k Called by proc~~def_back_substitute~~CalledByGraph proc~def_back_substitute def_back_substitute proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~def_back_substitute proc~invey invEy proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_back_substitute.html"},{"title":"DEF_bicgstab – ParaMADP","text":"public  subroutine DEF_bicgstab(y, x, f2c) A (CSLP preconditioned) Bi-CGSTAB solver for the coarse-grid problem in two-level deflation method Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Calls proc~~def_bicgstab~~CallsGraph proc~def_bicgstab DEF_bicgstab proc~coarsegridpara CoarseGridpara proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~mg_dot_prod mg_dot_prod proc~def_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_bicgstab->proc~mg_norm proc~mgcslp_invmhx MGCSLP_invMHx proc~def_bicgstab->proc~mgcslp_invmhx proc~ex->proc~coarsegridpara proc~ex->proc~mgcslp_invmhx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztx ZTx proc~ex->proc~ztx proc~ztzx ZTZx proc~ex->proc~ztzx proc~zx Zx proc~ex->proc~zx mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~mg_check_xy2d mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~zx->proc~mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_bicgstab~~CalledByGraph proc~def_bicgstab DEF_bicgstab proc~invey invEy proc~invey->proc~def_bicgstab proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_bicgstab.html"},{"title":"DEF_prefgmres – ParaMADP","text":"public recursive subroutine DEF_prefgmres(y, x, f2c, maximum_iterations, level, rtol) A recursive flexible GMRES with right deflation preconditioning\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"maxit+1\".So we need a k. Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c integer, intent(in), optional :: maximum_iterations integer, intent(in), optional :: level real(kind=realdp), intent(in), optional :: rtol Calls proc~~def_prefgmres~~CallsGraph proc~def_prefgmres DEF_prefgmres cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth Helm_Ax_nth proc~def_prefgmres->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~mg_dot_prod mg_dot_prod proc~def_prefgmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~def_prefgmres->proc~mg_norm proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~log2 LOG2 proc~helm_ax_nth->proc~log2 proc~mg_check_xy2d mg_check_xy2d proc~helm_ax_nth->proc~mg_check_xy2d proc~grid_destroy grid_destroy proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~helm_ax_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~gridsys_define proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~multilevel_invey->proc~def_prefgmres proc~multilevel_invey->proc~log2 proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~red_glk_cslp_gmres->proc~log2 proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~f_cycle proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_mx_nth_stencils->proc~log2 proc~cslp_op_bc->proc~mg_check_xy2d proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~mg_bicgstab->proc~mg_dot_prod proc~mg_bicgstab->proc~mg_norm proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_arnoldi->proc~cslp_op_bc proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~def_prefgmres~~CalledByGraph proc~def_prefgmres DEF_prefgmres proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multilevel_invey MultiLevel_invEy proc~multilevel_invey->proc~def_prefgmres proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/def_prefgmres.html"},{"title":"Helmholtz2d_O4cmpct – ParaMADP","text":"public  subroutine Helmholtz2d_O4cmpct(v_in, v_out, f2c) A coarse-grid Helmholtz operator for two-level deflation, descretized by a classic compact fourth-order FD scheme Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: v_out (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Calls proc~~helmholtz2d_o4cmpct~~CallsGraph proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmholtz2d_o4cmpct~~CalledByGraph proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~ex Ex proc~ex->proc~helm_a2hx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helmholtz2d_o4cmpct.html"},{"title":"Helmholtz2d_ReD_Glk – ParaMADP","text":"public  subroutine Helmholtz2d_ReD_Glk(v_in, v_out, f2c) A coarse-grid Helmholtz operator for two-level deflation, descretized by ReD-GLK FD scheme\nfill in a layer of ghost grid points by boundary conditions The boundary keeps 2nd-order finite difference scheme using five points stencils Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: v_out (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Calls proc~~helmholtz2d_red_glk~~CallsGraph proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helmholtz2d_red_glk~~CalledByGraph proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ex Ex proc~ex->proc~helm_a2hx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/helmholtz2d_red_glk.html"},{"title":"ReD_Glk_stencils – ParaMADP","text":"public  subroutine ReD_Glk_stencils(a, b, f2c, ic, jc) ReD-Glk computational stencils of the Helmholtz operator for coarse-grid level in two-deflation method Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: a (-2:2,-2:2) a: Laplace operator complex(kind=realdp) :: b (-2:2,-2:2) b: wavenumber operator type( TwoGrids ), intent(inout) :: f2c integer :: ic integer :: jc Called by proc~~red_glk_stencils~~CalledByGraph proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~red_glk_stencils proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ex Ex proc~ex->proc~helm_a2hx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/red_glk_stencils.html"},{"title":"ExtrpltGhostBCs – ParaMADP","text":"public  subroutine ExtrpltGhostBCs(v_in, f2c) Extrapolate a layer of ghost grid points based on the boundary conditions \nThe zero padding of wavenumber is ok in practical Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Called by proc~~extrpltghostbcs~~CalledByGraph proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~helm_a2hx Helm_A2hx proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ex Ex proc~ex->proc~helm_a2hx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~qx Qx proc~qx->proc~invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~qx proc~p_defx P_DEFx proc~p_defx->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~qx proc~px Px proc~px->proc~qx proc~def_px DEF_Px proc~def_px->proc~p_adef1x proc~def_px->proc~p_defx proc~def_px->proc~p_tlkmx proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/extrpltghostbcs.html"},{"title":"TwoGrids – ParaMADP","text":"public interface TwoGrids Calls interface~~twogrids~~CallsGraph interface~twogrids TwoGrids proc~fromfine2coarse FromFine2Coarse interface~twogrids->proc~fromfine2coarse proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~fromfine2coarse->proc~wavenumber_fwrestriction proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public  function FromFine2Coarse (OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: OneGrid Return Value type( TwoGrids )","tags":"","loc":"interface/twogrids.html"},{"title":"MGCSLP_invMx – ParaMADP","text":"public  function MGCSLP_invMx(b_in) Multigrid-Based CSLP, ONLY starts from the default (finest) grid sysyem\nOne V-cycle\nTwo V-cycle\nOne F-cycle Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b_in Return Value complex(kind=realdp), (1-LAP:nx+LAP,1-LAP:ny+LAP) MGCSLP_invMx = M_h&#94;(-1)(b_h) Calls proc~~mgcslp_invmx~~CallsGraph proc~mgcslp_invmx MGCSLP_invMx proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mgcslp_invmx~~CalledByGraph proc~mgcslp_invmx MGCSLP_invMx proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mgcslp_invmx.html"},{"title":"MGCSLP_invMHx – ParaMADP","text":"public  function MGCSLP_invMHx(b_in, grid) Multigrid-based CSLP, starts from the a specified grid system\nOne V-cycle\nTwo V-cycle\nOne F-cycle Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) :: b_in type( Gridpara ) :: grid A data type that collect some parameters of a system Return Value complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) MGCSLP_invMHx = M_H&#94;(-1)(b_H) Calls proc~~mgcslp_invmhx~~CallsGraph proc~mgcslp_invmhx MGCSLP_invMHx proc~f_cycle F_cycle proc~mgcslp_invmhx->proc~f_cycle proc~grid_destroy grid_destroy proc~mgcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~mgcslp_invmhx->proc~gridsys_define proc~v_cycle V_cycle proc~mgcslp_invmhx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mgcslp_invmhx~~CalledByGraph proc~mgcslp_invmhx MGCSLP_invMHx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~qx Qx proc~qx->proc~invey proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~qx proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~px Px proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mgcslp_invmhx.html"},{"title":"KrylovCSLP_invMHx – ParaMADP","text":"public  function KrylovCSLP_invMHx(b_in, grid) Krylov-based CSLP, starts from the a specified grid sysyem\nChoose Bi-CGSATB or GMRES by uncomment or comment Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) :: b_in type( Gridpara ) :: grid A data type that collect some parameters of a system Return Value complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Calls proc~~krylovcslp_invmhx~~CallsGraph proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~grid_destroy grid_destroy proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres cdsqrt cdsqrt proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~log2 LOG2 proc~red_glk_cslp_gmres->proc~log2 proc~mg_dot_prod mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth->proc~log2 proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_mx_nth->proc~mg_check_xy2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~cslp_mx_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~krylovcslp_invmhx~~CalledByGraph proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~krylovcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/krylovcslp_invmhx.html"},{"title":"finestgrid_define – ParaMADP","text":"public  subroutine finestgrid_define(mg_finest) This is a routine that define the finest grid system from the default (finest) grid parameters Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_finest Called by proc~~finestgrid_define~~CalledByGraph proc~finestgrid_define finestgrid_define proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~finestgrid_define proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/finestgrid_define.html"},{"title":"gridsys_define – ParaMADP","text":"public  subroutine gridsys_define(grid, basegridsys) This is a routine that define a GridSystem type from the grid parameters of a data type Gridpara\nOne can find the differnece of GridSystem and Gridpara Arguments Type Intent Optional Attributes Name type( Gridpara ) :: grid type( GridSystem ) :: basegridsys Called by proc~~gridsys_define~~CalledByGraph proc~gridsys_define gridsys_define proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~gridsys_define proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~gridsys_define proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~ex->proc~mgcslp_invmhx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~qx Qx proc~qx->proc~invey proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~p_adef1x->proc~qx proc~p_defx->proc~qx proc~p_tlkmx->proc~qx proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~px Px proc~px->proc~qx program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/gridsys_define.html"},{"title":"coarsegrid_create – ParaMADP","text":"public  subroutine coarsegrid_create(mg_coarse, mg_fine) This is a routine that define a coarse grid system mg_coarse from a fine grid system mg_fine Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine Called by proc~~coarsegrid_create~~CalledByGraph proc~coarsegrid_create coarsegrid_create proc~f_cycle F_cycle proc~f_cycle->proc~coarsegrid_create proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/coarsegrid_create.html"},{"title":"grid_destroy – ParaMADP","text":"public  subroutine grid_destroy(mg_dm) This is a routine that deallocate the arrays of a grid system Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_dm Called by proc~~grid_destroy~~CalledByGraph proc~grid_destroy grid_destroy proc~f_cycle F_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~grid_destroy proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~ex->proc~mgcslp_invmhx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~multilevel_invey->proc~def_prefgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/grid_destroy.html"},{"title":"restriction – ParaMADP","text":"public  subroutine restriction(mg_coarse, mg_fine) This is routine that perform full-weight resctriction from fine to coarse grid system, mainly\nresidual (res) on fine grid --> right-hand side (rhs) on coarse grid,\nwavenumber on fine grid --> wavenumber on the coarse grid\nBased on the relationship of the index between the fine and coarse grid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine Calls proc~~restriction~~CallsGraph proc~restriction restriction proc~mg_check_xy2d mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~restriction~~CalledByGraph proc~restriction restriction proc~f_cycle F_cycle proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~restriction proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/restriction.html"},{"title":"prolongation_en_correct – ParaMADP","text":"public  subroutine prolongation_en_correct(mg_coarse, mg_fine) This is routine that perform bilinear interpolation and correction from coarse to fine grid system, mainly\nsolution (u) on coarse grid --> correction (e_h) for solution (u) of fine grid\nBased on the relationship of the index between the fine and coarse grid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine Calls proc~~prolongation_en_correct~~CallsGraph proc~prolongation_en_correct prolongation_en_correct proc~mg_check_xy2d mg_check_xy2d proc~prolongation_en_correct->proc~mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prolongation_en_correct~~CalledByGraph proc~prolongation_en_correct prolongation_en_correct proc~f_cycle F_cycle proc~f_cycle->proc~prolongation_en_correct proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/prolongation_en_correct.html"},{"title":"V_cycle – ParaMADP","text":"public recursive subroutine V_cycle(mg_fine) A classic multigrid V-cycle\nA classic Two-Cycle\nGMRES or Bi-CGSTAB can be chose to solve the coarse-grid problem\nGMRES or Bi-CGSTAB can be chose to solve the coarsest-grid problem Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_fine Calls proc~~v_cycle~~CallsGraph proc~v_cycle V_cycle proc~v_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~v_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~v_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~v_cycle->proc~damp_jacobi_smoother proc~grid_destroy grid_destroy proc~v_cycle->proc~grid_destroy proc~mg_bicgstab mg_bicgstab proc~v_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~v_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~v_cycle->proc~prolongation_en_correct proc~restriction restriction proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~v_cycle~~CalledByGraph proc~v_cycle V_cycle proc~v_cycle->proc~v_cycle proc~f_cycle F_cycle proc~f_cycle->proc~v_cycle proc~f_cycle->proc~f_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~v_cycle proc~mgcslp_invmx->proc~f_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/v_cycle.html"},{"title":"F_cycle – ParaMADP","text":"public recursive subroutine F_cycle(mg_fine) This is a classic F-cycle multigrid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_fine Calls proc~~f_cycle~~CallsGraph proc~f_cycle F_cycle proc~f_cycle->proc~f_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~grid_destroy grid_destroy proc~f_cycle->proc~grid_destroy proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~v_cycle->proc~v_cycle proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~f_cycle~~CalledByGraph proc~f_cycle F_cycle proc~f_cycle->proc~f_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/f_cycle.html"},{"title":"mg_fullgmres – ParaMADP","text":"public  subroutine mg_fullgmres(mg_solve) This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using GMRES\n The CSLP is define by ReD-O2 scheme\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k.\n The default tolerance is 1E-08 Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve The current coarsest grid system Calls proc~~mg_fullgmres~~CallsGraph proc~mg_fullgmres mg_fullgmres proc~cslp_op_bc CSLP_OP_BC proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_norm mg_norm proc~mg_fullgmres->proc~mg_norm proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_norm proc~mg_dot_prod mg_dot_prod proc~mg_arnoldi->proc~mg_dot_prod mpi_allreduce mpi_allreduce proc~mg_norm->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_dot_prod->mpi_allreduce mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_fullgmres~~CalledByGraph proc~mg_fullgmres mg_fullgmres proc~f_cycle F_cycle proc~f_cycle->proc~mg_fullgmres proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_fullgmres.html"},{"title":"mg_arnoldi – ParaMADP","text":"public  subroutine mg_arnoldi(V, H, k, ni, nj, hx_c, hy_c, kxy, kh2) Arnoldi precess\n w=A*v_i Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP,cslp_mg_miter+1) :: V complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H integer, intent(in) :: k integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 Calls proc~~mg_arnoldi~~CallsGraph proc~mg_arnoldi mg_arnoldi proc~cslp_op_bc CSLP_OP_BC proc~mg_arnoldi->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_arnoldi->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_arnoldi->proc~mg_norm proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_arnoldi~~CalledByGraph proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres mg_fullgmres proc~mg_fullgmres->proc~mg_arnoldi proc~f_cycle F_cycle proc~f_cycle->proc~mg_fullgmres proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_arnoldi.html"},{"title":"mg_apply_givens_rotation – ParaMADP","text":"public  subroutine mg_apply_givens_rotation(H, cs, sn, k) This is routine to perform apply_givens_rotation Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: cs complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: sn integer, intent(in) :: k Calls proc~~mg_apply_givens_rotation~~CallsGraph proc~mg_apply_givens_rotation mg_apply_givens_rotation cdsqrt cdsqrt proc~mg_apply_givens_rotation->cdsqrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_apply_givens_rotation~~CalledByGraph proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres mg_fullgmres proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~f_cycle F_cycle proc~f_cycle->proc~mg_fullgmres proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_apply_givens_rotation.html"},{"title":"mg_back_substitute – ParaMADP","text":"public  subroutine mg_back_substitute(H, beta, k) This is routine that performs back substitute Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: beta integer, intent(in) :: k Called by proc~~mg_back_substitute~~CalledByGraph proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres mg_fullgmres proc~mg_fullgmres->proc~mg_back_substitute proc~f_cycle F_cycle proc~f_cycle->proc~mg_fullgmres proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_back_substitute.html"},{"title":"mg_bicgstab – ParaMADP","text":"public  subroutine mg_bicgstab(mg_solve, maximum_iterations) This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using Bi-CGSTAB\nThe CSLP is define by ReD-O2 scheme Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve integer, intent(in), optional :: maximum_iterations User-specified maximum number of iterations Calls proc~~mg_bicgstab~~CallsGraph proc~mg_bicgstab mg_bicgstab proc~cslp_op_bc CSLP_OP_BC proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_bicgstab~~CalledByGraph proc~mg_bicgstab mg_bicgstab proc~f_cycle F_cycle proc~f_cycle->proc~mg_bicgstab proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_bicgstab.html"},{"title":"ReD_Glk_CSLP_bicgstab – ParaMADP","text":"public  subroutine ReD_Glk_CSLP_bicgstab(mg_solve, grid, maximum_iterations) This is a rountine to solve a coarse grid CSLP system approximately by using Bi-CGSTAB. \nThe CSLP operator is defined by ReD-Glk scheme. \nCSLP operator by ReD-Glk Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve The current coarse grid system type( Gridpara ) :: grid Parameters of current coarse grid integer, intent(in), optional :: maximum_iterations Calls proc~~red_glk_cslp_bicgstab~~CallsGraph proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~mg_dot_prod mg_dot_prod proc~red_glk_cslp_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~red_glk_cslp_bicgstab->proc~mg_norm proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~log2 LOG2 proc~cslp_mx_nth->proc~log2 proc~mg_check_xy2d mg_check_xy2d proc~cslp_mx_nth->proc~mg_check_xy2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~cslp_mx_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/red_glk_cslp_bicgstab.html"},{"title":"ReD_Glk_CSLP_gmres – ParaMADP","text":"public  subroutine ReD_Glk_CSLP_gmres(mg_solve, grid, maximum_iterations) This is a rountine to solve a coarse grid CSLP system approximately by using GMRES\n The CSLP operator is defined by ReD-Glk scheme\n CSLP operator by ReD-Glk Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w)\n---call back_substitute(H,beta,k)--------------------------------- Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve type( Gridpara ) :: grid integer, intent(in), optional :: maximum_iterations User-specified maximum number of iterations,default is 300 Calls proc~~red_glk_cslp_gmres~~CallsGraph proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres cdsqrt cdsqrt proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~log2 LOG2 proc~red_glk_cslp_gmres->proc~log2 proc~mg_dot_prod mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~mg_norm mg_norm proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth->proc~log2 proc~cslp2d_stencils cslp2d_stencils proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_mx_nth->proc~mg_check_xy2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~cslp_mx_nth_stencils->proc~log2 proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~red_glk_cslp_gmres~~CalledByGraph proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~krylovcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~multileveladp_px->proc~krylovcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~multilevel_invey->proc~def_prefgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/red_glk_cslp_gmres.html"},{"title":"my_mod1 – ParaMADP","text":"public  function my_mod1(na, nb) A function to calculate the modulo of two integers na and nb Arguments Type Intent Optional Attributes Name integer :: na integer :: nb Return Value integer Called by proc~~my_mod1~~CalledByGraph proc~my_mod1 my_mod1 proc~part2d part2d proc~part2d->proc~my_mod1 program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~part2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/my_mod1.html"},{"title":"part2d – ParaMADP","text":"public  subroutine part2d() Partitions the 2D domain for parallel processing and calculates offsets and sizes for each partition\nthe ID of partion along 2 directions\n-1 proc in x-direction\n+1 proc in x-direction\nif not periodic, 0 node donot send mesg to npx0-1 node\nif not periodic, npx0-1 node donot send mesg to 0 node Arguments None Calls proc~~part2d~~CallsGraph proc~part2d part2d mpi_barrier mpi_barrier proc~part2d->mpi_barrier proc~my_mod1 my_mod1 proc~part2d->proc~my_mod1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~part2d~~CalledByGraph proc~part2d part2d program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~part2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/part2d.html"},{"title":"check_x2d – ParaMADP","text":"public  subroutine check_x2d(f) Exchanges data in the x direction, ONLY for the default (finest) grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) Calls proc~~check_x2d~~CallsGraph proc~check_x2d check_x2d mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_x2d~~CalledByGraph proc~check_x2d check_x2d proc~check_xy2d check_xy2d proc~check_xy2d->proc~check_x2d proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~check_xy2d proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~helmholtz2d_bc proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_x2d.html"},{"title":"check_y2d – ParaMADP","text":"public  subroutine check_y2d(f) Exchanges data in the y direction, ONLY for the default (finest) grid system\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) Calls proc~~check_y2d~~CallsGraph proc~check_y2d check_y2d mpi_sendrecv mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_y2d~~CalledByGraph proc~check_y2d check_y2d proc~check_xy2d check_xy2d proc~check_xy2d->proc~check_y2d proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~check_xy2d proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~helmholtz2d_bc proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_y2d.html"},{"title":"check_xy2d – ParaMADP","text":"public  subroutine check_xy2d(f) Exchanges data first in the x direction and then y direction, ONLY for the default (finest) grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) Calls proc~~check_xy2d~~CallsGraph proc~check_xy2d check_xy2d proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_xy2d~~CalledByGraph proc~check_xy2d check_xy2d proc~helmholtz2d_bc Helmholtz2d_BC proc~helmholtz2d_bc->proc~check_xy2d proc~arnoldi arnoldi proc~arnoldi->proc~helmholtz2d_bc proc~cmatvec cmatvec proc~cmatvec->proc~helmholtz2d_bc proc~full_pgcr full_pgcr proc~full_pgcr->proc~helmholtz2d_bc proc~full_pgmres full_pgmres proc~full_pgmres->proc~helmholtz2d_bc proc~fullgmres fullgmres proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~arnoldi proc~pfgmres pfgmres proc~pfgmres->proc~helmholtz2d_bc proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~helmholtz2d_bc proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~helmholtz2d_bc proc~restartgmres restartgmres proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~arnoldi interface~operator(ASTERISK) OPERATOR(*) interface~operator(ASTERISK)->proc~cmatvec program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_xy2d.html"},{"title":"mg_check_x2d – ParaMADP","text":"public  subroutine mg_check_x2d(f, ni, nj) Exchanges data in the x direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_check_x2d~~CallsGraph proc~mg_check_x2d mg_check_x2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_check_x2d~~CalledByGraph proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d mg_check_xy2d proc~mg_check_xy2d->proc~mg_check_x2d proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~prolongation_en_correct prolongation_en_correct proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction restriction proc~restriction->proc~mg_check_xy2d proc~ztx ZTx proc~ztx->proc~mg_check_xy2d proc~zx Zx proc~zx->proc~mg_check_xy2d proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~ex Ex proc~ex->proc~ztx proc~ex->proc~zx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~prolongation_en_correct proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~ztx proc~multileveladp_px->proc~zx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~mgcslp_invmhx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~multilevel_invey->proc~def_prefgmres proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~qx proc~p_adef1x->proc~mgcslp_invmx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~precond_x->proc~mgcslp_invmx interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_check_x2d.html"},{"title":"mg_check_y2d – ParaMADP","text":"public  subroutine mg_check_y2d(f, ni, nj) Exchanges data in the y direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_check_y2d~~CallsGraph proc~mg_check_y2d mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_check_y2d~~CalledByGraph proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d mg_check_xy2d proc~mg_check_xy2d->proc~mg_check_y2d proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~prolongation_en_correct prolongation_en_correct proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction restriction proc~restriction->proc~mg_check_xy2d proc~ztx ZTx proc~ztx->proc~mg_check_xy2d proc~zx Zx proc~zx->proc~mg_check_xy2d proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~ex Ex proc~ex->proc~ztx proc~ex->proc~zx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~prolongation_en_correct proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~ztx proc~multileveladp_px->proc~zx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~mgcslp_invmhx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~multilevel_invey->proc~def_prefgmres proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~qx proc~p_adef1x->proc~mgcslp_invmx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~precond_x->proc~mgcslp_invmx interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_check_y2d.html"},{"title":"mg_check_xy2d – ParaMADP","text":"public  subroutine mg_check_xy2d(f, ni, nj) Exchanges data first in the x direction and then y direction, for a specified-size grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_check_xy2d~~CallsGraph proc~mg_check_xy2d mg_check_xy2d proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_check_xy2d~~CalledByGraph proc~mg_check_xy2d mg_check_xy2d proc~cslp_mx_nth CSLP_Mx_nth proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_op_bc CSLP_OP_BC proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helm_ax_nth Helm_Ax_nth proc~helm_ax_nth->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~prolongation_en_correct prolongation_en_correct proc~prolongation_en_correct->proc~mg_check_xy2d proc~restriction restriction proc~restriction->proc~mg_check_xy2d proc~ztx ZTx proc~ztx->proc~mg_check_xy2d proc~zx Zx proc~zx->proc~mg_check_xy2d proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~helm_ax_nth proc~multileveladp_px MultiLevelADP_Px proc~def_prefgmres->proc~multileveladp_px proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~def_prefgmres->proc~krylovcslp_invmhx proc~ex Ex proc~ex->proc~ztx proc~ex->proc~zx proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~helm_ahx Helm_Ahx proc~ex->proc~helm_ahx proc~ztzx ZTZx proc~ex->proc~ztzx proc~mgcslp_invmhx MGCSLP_invMHx proc~ex->proc~mgcslp_invmhx proc~f_cycle F_cycle proc~f_cycle->proc~cslp_op_bc proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~prolongation_en_correct proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helm_a2hx->proc~helmholtz2d_red_glk proc~helm_ahx->proc~helmholtz2d_bc_mg proc~mg_arnoldi mg_arnoldi proc~mg_arnoldi->proc~cslp_op_bc proc~mg_bicgstab->proc~cslp_op_bc proc~mg_fullgmres->proc~cslp_op_bc proc~mg_fullgmres->proc~mg_arnoldi proc~multileveladp_px->proc~helm_ax_nth proc~multileveladp_px->proc~ztx proc~multileveladp_px->proc~zx proc~multileveladp_px->proc~krylovcslp_invmhx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~qx Qx proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~red_glk_cslp_bicgstab ReD_Glk_CSLP_bicgstab proc~red_glk_cslp_bicgstab->proc~cslp_mx_nth proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~v_cycle proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~ex proc~def_arnoldi->proc~mgcslp_invmhx proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~ex proc~def_bicgstab->proc~mgcslp_invmhx proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~ex proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~mgcslp_invmhx proc~def_px DEF_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~multilevel_invey->proc~def_prefgmres proc~p_adef1x->proc~helm_ahx proc~p_adef1x->proc~qx proc~p_adef1x->proc~mgcslp_invmx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~px Px proc~px->proc~helm_ahx proc~px->proc~qx proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~precond_x Precond_x proc~precond_x->proc~def_px proc~precond_x->proc~mgcslp_invmx interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_check_xy2d.html"},{"title":"mg_checkreal_x2d – ParaMADP","text":"public  subroutine mg_checkreal_x2d(f, ni, nj) Exchanges REAL data in the x direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_checkreal_x2d~~CallsGraph proc~mg_checkreal_x2d mg_checkreal_x2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_checkreal_x2d~~CalledByGraph proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~const_k Const_K proc~const_k->proc~mg_checkreal_xy2d proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi proc~read_wavenumber_k_marmousi->proc~mg_checkreal_xy2d proc~restriction restriction proc~restriction->proc~mg_checkreal_xy2d proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~wavenumber_k_wedge wavenumber_k_Wedge proc~wavenumber_k_wedge->proc~mg_checkreal_xy2d proc~f_cycle F_cycle proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~fromfine2coarse FromFine2Coarse proc~fromfine2coarse->proc~wavenumber_fwrestriction proc~v_cycle->proc~restriction proc~v_cycle->proc~v_cycle program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~const_k program~helmholtz_2d->proc~read_wavenumber_k_marmousi program~helmholtz_2d->proc~wavenumber_k_wedge proc~full_pgcr full_pgcr program~helmholtz_2d->proc~full_pgcr proc~full_pgmres full_pgmres program~helmholtz_2d->proc~full_pgmres proc~pfgmres pfgmres program~helmholtz_2d->proc~pfgmres proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d->proc~pre_fullgmres proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d->proc~pre_restartgmres interface~twogrids TwoGrids interface~twogrids->proc~fromfine2coarse proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr->proc~precond_x proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_checkreal_x2d.html"},{"title":"mg_checkreal_y2d – ParaMADP","text":"public  subroutine mg_checkreal_y2d(f, ni, nj) Exchanges REAL data in the y direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_checkreal_y2d~~CallsGraph proc~mg_checkreal_y2d mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_checkreal_y2d~~CalledByGraph proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~const_k Const_K proc~const_k->proc~mg_checkreal_xy2d proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi proc~read_wavenumber_k_marmousi->proc~mg_checkreal_xy2d proc~restriction restriction proc~restriction->proc~mg_checkreal_xy2d proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~wavenumber_k_wedge wavenumber_k_Wedge proc~wavenumber_k_wedge->proc~mg_checkreal_xy2d proc~f_cycle F_cycle proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~fromfine2coarse FromFine2Coarse proc~fromfine2coarse->proc~wavenumber_fwrestriction proc~v_cycle->proc~restriction proc~v_cycle->proc~v_cycle program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~const_k program~helmholtz_2d->proc~read_wavenumber_k_marmousi program~helmholtz_2d->proc~wavenumber_k_wedge proc~full_pgcr full_pgcr program~helmholtz_2d->proc~full_pgcr proc~full_pgmres full_pgmres program~helmholtz_2d->proc~full_pgmres proc~pfgmres pfgmres program~helmholtz_2d->proc~pfgmres proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d->proc~pre_fullgmres proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d->proc~pre_restartgmres interface~twogrids TwoGrids interface~twogrids->proc~fromfine2coarse proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr->proc~precond_x proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_checkreal_y2d.html"},{"title":"mg_checkreal_xy2d – ParaMADP","text":"public  subroutine mg_checkreal_xy2d(f, ni, nj) Exchanges REAL data first in the x direction and then y direction, for a specified-size grid system Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj Calls proc~~mg_checkreal_xy2d~~CallsGraph proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mg_checkreal_xy2d~~CalledByGraph proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~const_k Const_K proc~const_k->proc~mg_checkreal_xy2d proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi proc~read_wavenumber_k_marmousi->proc~mg_checkreal_xy2d proc~restriction restriction proc~restriction->proc~mg_checkreal_xy2d proc~wavenumber_fwrestriction wavenumber_FWrestriction proc~wavenumber_fwrestriction->proc~mg_checkreal_xy2d proc~wavenumber_k_wedge wavenumber_k_Wedge proc~wavenumber_k_wedge->proc~mg_checkreal_xy2d proc~f_cycle F_cycle proc~f_cycle->proc~restriction proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~fromfine2coarse FromFine2Coarse proc~fromfine2coarse->proc~wavenumber_fwrestriction proc~v_cycle->proc~restriction proc~v_cycle->proc~v_cycle program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~const_k program~helmholtz_2d->proc~read_wavenumber_k_marmousi program~helmholtz_2d->proc~wavenumber_k_wedge proc~full_pgcr full_pgcr program~helmholtz_2d->proc~full_pgcr proc~full_pgmres full_pgmres program~helmholtz_2d->proc~full_pgmres proc~pfgmres pfgmres program~helmholtz_2d->proc~pfgmres proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d->proc~pre_fullgmres proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d->proc~pre_restartgmres interface~twogrids TwoGrids interface~twogrids->proc~fromfine2coarse proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr->proc~precond_x proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mg_checkreal_xy2d.html"},{"title":"RHS_2DCloseOff – ParaMADP","text":"public  subroutine RHS_2DCloseOff(b, xx, yy) 2D close-off problem with Dirichlet boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~rhs_2dcloseoff~~CalledByGraph proc~rhs_2dcloseoff RHS_2DCloseOff program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~rhs_2dcloseoff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rhs_2dcloseoff.html"},{"title":"RHS_CenterSource2D – ParaMADP","text":"public  subroutine RHS_CenterSource2D(b, xx, yy) 2D constant wavenumber problem with a central point source\nA point source located at (0.5,0.5) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~rhs_centersource2d~~CalledByGraph proc~rhs_centersource2d RHS_CenterSource2D program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~rhs_centersource2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rhs_centersource2d.html"},{"title":"RHS_2DWedge – ParaMADP","text":"public  subroutine RHS_2DWedge(b, xx, yy) 2D Wedge problem\nA point source located at (300,0) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~rhs_2dwedge~~CalledByGraph proc~rhs_2dwedge RHS_2DWedge program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~rhs_2dwedge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rhs_2dwedge.html"},{"title":"RHS_marmousi – ParaMADP","text":"public  subroutine RHS_marmousi(b, xx, yy) Marmousi problem\nA point source located at (6000,0) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~rhs_marmousi~~CalledByGraph proc~rhs_marmousi RHS_marmousi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~rhs_marmousi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/rhs_marmousi.html"},{"title":"Const_K – ParaMADP","text":"public  subroutine Const_K() constant wavenumber, determine by input variable k0\ndata communication with neighbouring subdomains Arguments None Calls proc~~const_k~~CallsGraph proc~const_k Const_K proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~const_k->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~const_k~~CalledByGraph proc~const_k Const_K program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~const_k Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/const_k.html"},{"title":"wavenumber_k_Wedge – ParaMADP","text":"public  subroutine wavenumber_k_Wedge(xx, yy) Wavenumber for Wedge model problem\nThe top layer\nThe bottom layer\nThe middle layer Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Calls proc~~wavenumber_k_wedge~~CallsGraph proc~wavenumber_k_wedge wavenumber_k_Wedge proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~wavenumber_k_wedge->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~wavenumber_k_wedge~~CalledByGraph proc~wavenumber_k_wedge wavenumber_k_Wedge program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~wavenumber_k_wedge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/wavenumber_k_wedge.html"},{"title":"read_wavenumber_k_marmousi – ParaMADP","text":"public  subroutine read_wavenumber_k_marmousi() Read the velocity profile of Marmousi problem with specified grid size and calculate the wavenumber Arguments None Calls proc~~read_wavenumber_k_marmousi~~CallsGraph proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi mpi_recv mpi_recv proc~read_wavenumber_k_marmousi->mpi_recv mpi_send mpi_send proc~read_wavenumber_k_marmousi->mpi_send proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~read_wavenumber_k_marmousi->proc~mg_checkreal_xy2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_wavenumber_k_marmousi~~CalledByGraph proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~read_wavenumber_k_marmousi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_wavenumber_k_marmousi.html"},{"title":"wavenumber_k_destroy – ParaMADP","text":"public  subroutine wavenumber_k_destroy() Deallocate the wavenumber field in the end Arguments None Called by proc~~wavenumber_k_destroy~~CalledByGraph proc~wavenumber_k_destroy wavenumber_k_destroy program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~wavenumber_k_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/wavenumber_k_destroy.html"},{"title":"define_uniform_grid – ParaMADP","text":"public  subroutine define_uniform_grid(phys1, phys2) A square computational domain with a unit side length Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 Local coordinates in x and y directions real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2 Local coordinates in x and y directions Calls proc~~define_uniform_grid~~CallsGraph proc~define_uniform_grid define_uniform_grid mpi_recv mpi_recv proc~define_uniform_grid->mpi_recv mpi_send mpi_send proc~define_uniform_grid->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~define_uniform_grid~~CalledByGraph proc~define_uniform_grid define_uniform_grid program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~define_uniform_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/define_uniform_grid.html"},{"title":"define_wedge_grid – ParaMADP","text":"public  subroutine define_wedge_grid(phys1, phys2) Wedge model problem Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2 Calls proc~~define_wedge_grid~~CallsGraph proc~define_wedge_grid define_wedge_grid mpi_recv mpi_recv proc~define_wedge_grid->mpi_recv mpi_send mpi_send proc~define_wedge_grid->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~define_wedge_grid~~CalledByGraph proc~define_wedge_grid define_wedge_grid program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~define_wedge_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/define_wedge_grid.html"},{"title":"define_marmousi_grid – ParaMADP","text":"public  subroutine define_marmousi_grid(phys1, phys2) Marmousi problem Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2 Calls proc~~define_marmousi_grid~~CallsGraph proc~define_marmousi_grid define_marmousi_grid mpi_recv mpi_recv proc~define_marmousi_grid->mpi_recv mpi_send mpi_send proc~define_marmousi_grid->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~define_marmousi_grid~~CalledByGraph proc~define_marmousi_grid define_marmousi_grid program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~define_marmousi_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/define_marmousi_grid.html"},{"title":"Damp_Jacobi_smoother – ParaMADP","text":"public  subroutine Damp_Jacobi_smoother(x, rhs, ni, nj, hx_c, hy_c, kxy, kh2) This is a routine to apply damped Jacobbi smoother on coarse grid systems. Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: x complex(kind=realdp), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: rhs local arguements integer, intent(in) :: ni subdomain grid size on the current coarse level integer, intent(in) :: nj subdomain grid size on the current coarse level real(kind=realdp), intent(in) :: hx_c coarse-grid space step size real(kind=realdp), intent(in) :: hy_c coarse-grid space step size real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy Wavenumber and (kh)&#94;2 real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 Wavenumber and (kh)&#94;2 Calls proc~~damp_jacobi_smoother~~CallsGraph proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~cslp2d_stencils cslp2d_stencils proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~if_bcs if_BCs proc~damp_jacobi_smoother->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~damp_jacobi_smoother~~CalledByGraph proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle F_cycle proc~f_cycle->proc~damp_jacobi_smoother proc~f_cycle->proc~f_cycle proc~v_cycle V_cycle proc~f_cycle->proc~v_cycle proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~v_cycle proc~mgcslp_invmhx MGCSLP_invMHx proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmx MGCSLP_invMx proc~mgcslp_invmx->proc~f_cycle proc~mgcslp_invmx->proc~v_cycle proc~cprecon cprecon proc~cprecon->proc~mgcslp_invmx proc~def_arnoldi def_arnoldi proc~def_arnoldi->proc~mgcslp_invmhx proc~ex Ex proc~def_arnoldi->proc~ex proc~def_bicgstab DEF_bicgstab proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~ex proc~def_fullgmres DEF_fullgmres proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~def_arnoldi proc~def_fullgmres->proc~ex proc~ex->proc~mgcslp_invmhx proc~multileveladp_px MultiLevelADP_Px proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~p_adef1x P_ADEF1x proc~p_adef1x->proc~mgcslp_invmx proc~qx Qx proc~p_adef1x->proc~qx proc~p_tlkmx P_TLKMx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~qx proc~precond_x Precond_x proc~precond_x->proc~mgcslp_invmx proc~def_px DEF_Px proc~precond_x->proc~def_px interface~operator(SLASH) OPERATOR(/) interface~operator(SLASH)->proc~cprecon proc~def_prefgmres DEF_prefgmres proc~def_prefgmres->proc~multileveladp_px proc~def_px->proc~multileveladp_px proc~def_px->proc~p_adef1x proc~def_px->proc~p_tlkmx proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~invey invEy proc~invey->proc~def_bicgstab proc~invey->proc~def_fullgmres proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x proc~multilevel_invey->proc~def_prefgmres proc~qx->proc~invey program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres proc~p_defx->proc~qx proc~px Px proc~px->proc~qx Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/damp_jacobi_smoother.html"},{"title":"write_data_whole – ParaMADP","text":"public  subroutine write_data_whole(xx, yy, u) Write the solutions Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u Calls proc~~write_data_whole~~CallsGraph proc~write_data_whole write_data_whole mpi_recv mpi_recv proc~write_data_whole->mpi_recv mpi_send mpi_send proc~write_data_whole->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_data_whole~~CalledByGraph proc~write_data_whole write_data_whole program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~write_data_whole Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_data_whole.html"},{"title":"write_exact_data_whole – ParaMADP","text":"public  subroutine write_exact_data_whole(xx, yy, u) Write the analytical solutions Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u Calls proc~~write_exact_data_whole~~CallsGraph proc~write_exact_data_whole write_exact_data_whole mpi_recv mpi_recv proc~write_exact_data_whole->mpi_recv mpi_send mpi_send proc~write_exact_data_whole->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_exact_data_whole.html"},{"title":"write_real_data_whole – ParaMADP","text":"public  subroutine write_real_data_whole(xx, yy, u) Write the real wavenumber/variables Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u Calls proc~~write_real_data_whole~~CallsGraph proc~write_real_data_whole write_real_data_whole mpi_recv mpi_recv proc~write_real_data_whole->mpi_recv mpi_send mpi_send proc~write_real_data_whole->mpi_send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_real_data_whole.html"},{"title":"exact_2DCloseOff – ParaMADP","text":"public  subroutine exact_2DCloseOff(u_ex, xx, yy) The analytical solution for 2D close-off problem Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Calls proc~~exact_2dcloseoff~~CallsGraph proc~exact_2dcloseoff exact_2DCloseOff dsin dsin proc~exact_2dcloseoff->dsin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~exact_2dcloseoff~~CalledByGraph proc~exact_2dcloseoff exact_2DCloseOff program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~exact_2dcloseoff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/exact_2dcloseoff.html"},{"title":"exact_2DPointSource_1stSomer – ParaMADP","text":"public  subroutine exact_2DPointSource_1stSomer(u_ex, xx, yy) The analytical solution for constant wavenumber problem with central source point with Sommerfeld boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~exact_2dpointsource_1stsomer~~CalledByGraph proc~exact_2dpointsource_1stsomer exact_2DPointSource_1stSomer program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~exact_2dpointsource_1stsomer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/exact_2dpointsource_1stsomer.html"},{"title":"exact_2DPointSource_Dirichlet – ParaMADP","text":"public  subroutine exact_2DPointSource_Dirichlet(u_ex, xx, yy) The analytical solution for constant wavenumber problem with central source point with Dirichlet boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy Called by proc~~exact_2dpointsource_dirichlet~~CalledByGraph proc~exact_2dpointsource_dirichlet exact_2DPointSource_Dirichlet program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~exact_2dpointsource_dirichlet Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/exact_2dpointsource_dirichlet.html"},{"title":"Precond_x – ParaMADP","text":"public  function Precond_x(x) This is a routine to select which preconditioner is applied, Precond_x = P&#94;(-1)x Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: x Return Value complex(kind=realdp), (1-LAP:nx+LAP,1-LAP:ny+LAP) Calls proc~~precond_x~~CallsGraph proc~precond_x Precond_x proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~if_bcs if_BCs proc~cslp_op_bc->proc~if_bcs proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d mpi_allreduce mpi_allreduce proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex mpi_sendrecv mpi_sendrecv proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~precond_x~~CalledByGraph proc~precond_x Precond_x proc~full_pgcr full_pgcr proc~full_pgcr->proc~precond_x proc~full_pgmres full_pgmres proc~full_pgmres->proc~precond_x proc~pfgmres pfgmres proc~pfgmres->proc~precond_x proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~precond_x proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~precond_x proc~pre_restartgmres->proc~prearnoldi proc~prearnoldi->proc~precond_x program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/precond_x.html"},{"title":"fullgmres – ParaMADP","text":"public  subroutine fullgmres(b, u, Rerror, iter) Full GMRES without precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~fullgmres~~CallsGraph proc~fullgmres fullgmres proc~apply_givens_rotation apply_givens_rotation proc~fullgmres->proc~apply_givens_rotation proc~arnoldi arnoldi proc~fullgmres->proc~arnoldi proc~back_substitute back_substitute proc~fullgmres->proc~back_substitute proc~helmholtz2d_bc Helmholtz2d_BC proc~fullgmres->proc~helmholtz2d_bc proc~norm norm proc~fullgmres->proc~norm cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt proc~arnoldi->proc~helmholtz2d_bc proc~arnoldi->proc~norm proc~dot_prod dot_prod proc~arnoldi->proc~dot_prod proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs mpi_allreduce mpi_allreduce proc~norm->mpi_allreduce proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dot_prod->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fullgmres~~CalledByGraph proc~fullgmres fullgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~fullgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fullgmres.html"},{"title":"restartgmres – ParaMADP","text":"public  subroutine restartgmres(b, u, Rerror, iter_total) Restart GMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter_total Calls proc~~restartgmres~~CallsGraph proc~restartgmres restartgmres proc~apply_givens_rotation apply_givens_rotation proc~restartgmres->proc~apply_givens_rotation proc~arnoldi arnoldi proc~restartgmres->proc~arnoldi proc~back_substitute back_substitute proc~restartgmres->proc~back_substitute proc~helmholtz2d_bc Helmholtz2d_BC proc~restartgmres->proc~helmholtz2d_bc proc~norm norm proc~restartgmres->proc~norm cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt proc~arnoldi->proc~helmholtz2d_bc proc~arnoldi->proc~norm proc~dot_prod dot_prod proc~arnoldi->proc~dot_prod proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs mpi_allreduce mpi_allreduce proc~norm->mpi_allreduce proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dot_prod->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~restartgmres~~CalledByGraph proc~restartgmres restartgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/restartgmres.html"},{"title":"Pre_fullgmres – ParaMADP","text":"public  subroutine Pre_fullgmres(b, u, Rerror, iter) Full GMRES with left preconditioned Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~pre_fullgmres~~CallsGraph proc~pre_fullgmres Pre_fullgmres proc~apply_givens_rotation apply_givens_rotation proc~pre_fullgmres->proc~apply_givens_rotation proc~back_substitute back_substitute proc~pre_fullgmres->proc~back_substitute proc~helmholtz2d_bc Helmholtz2d_BC proc~pre_fullgmres->proc~helmholtz2d_bc proc~norm norm proc~pre_fullgmres->proc~norm proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~precond_x Precond_x proc~pre_fullgmres->proc~precond_x cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs mpi_allreduce mpi_allreduce proc~norm->mpi_allreduce proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~norm proc~prearnoldi->proc~precond_x proc~dot_prod dot_prod proc~prearnoldi->proc~dot_prod proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dot_prod->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->cdsqrt proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pre_fullgmres~~CalledByGraph proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~pre_fullgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pre_fullgmres.html"},{"title":"full_pgmres – ParaMADP","text":"public  subroutine full_pgmres(b, u, Rerror, iter) Full GMRES with right precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~full_pgmres~~CallsGraph proc~full_pgmres full_pgmres proc~apply_givens_rotation apply_givens_rotation proc~full_pgmres->proc~apply_givens_rotation proc~back_substitute back_substitute proc~full_pgmres->proc~back_substitute proc~dot_prod dot_prod proc~full_pgmres->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~full_pgmres->proc~helmholtz2d_bc proc~norm norm proc~full_pgmres->proc~norm proc~precond_x Precond_x proc~full_pgmres->proc~precond_x cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~norm->mpi_allreduce proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->cdsqrt proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~full_pgmres~~CalledByGraph proc~full_pgmres full_pgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/full_pgmres.html"},{"title":"Pre_restartgmres – ParaMADP","text":"public  subroutine Pre_restartgmres(b, u, Rerror, iter) Preconditioned restart GMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~pre_restartgmres~~CallsGraph proc~pre_restartgmres Pre_restartgmres proc~apply_givens_rotation apply_givens_rotation proc~pre_restartgmres->proc~apply_givens_rotation proc~back_substitute back_substitute proc~pre_restartgmres->proc~back_substitute proc~helmholtz2d_bc Helmholtz2d_BC proc~pre_restartgmres->proc~helmholtz2d_bc proc~norm norm proc~pre_restartgmres->proc~norm proc~prearnoldi Prearnoldi proc~pre_restartgmres->proc~prearnoldi proc~precond_x Precond_x proc~pre_restartgmres->proc~precond_x cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs mpi_allreduce mpi_allreduce proc~norm->mpi_allreduce proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~norm proc~prearnoldi->proc~precond_x proc~dot_prod dot_prod proc~prearnoldi->proc~dot_prod proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dot_prod->mpi_allreduce proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->cdsqrt proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pre_restartgmres~~CalledByGraph proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pre_restartgmres.html"},{"title":"arnoldi – ParaMADP","text":"public  subroutine arnoldi(V, H, k) ARNOLDI precess Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP,m_iter+1) :: V complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H integer, intent(in) :: k Calls proc~~arnoldi~~CallsGraph proc~arnoldi arnoldi proc~dot_prod dot_prod proc~arnoldi->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~arnoldi->proc~helmholtz2d_bc proc~norm norm proc~arnoldi->proc~norm mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~norm->mpi_allreduce proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~arnoldi~~CalledByGraph proc~arnoldi arnoldi proc~fullgmres fullgmres proc~fullgmres->proc~arnoldi proc~restartgmres restartgmres proc~restartgmres->proc~arnoldi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/arnoldi.html"},{"title":"Prearnoldi – ParaMADP","text":"public  subroutine Prearnoldi(V, H, k) Preconditioned ARNOLDI precess Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP,m_iter+1) :: V complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H integer, intent(in) :: k Calls proc~~prearnoldi~~CallsGraph proc~prearnoldi Prearnoldi proc~dot_prod dot_prod proc~prearnoldi->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~prearnoldi->proc~helmholtz2d_bc proc~norm norm proc~prearnoldi->proc~norm proc~precond_x Precond_x proc~prearnoldi->proc~precond_x mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~norm->mpi_allreduce proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prearnoldi~~CalledByGraph proc~prearnoldi Prearnoldi proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~prearnoldi proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~prearnoldi program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/prearnoldi.html"},{"title":"apply_givens_rotation – ParaMADP","text":"public  subroutine apply_givens_rotation(H, cs, sn, k) APPLY GIVENS ROTATION Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H complex(kind=realdp), intent(inout), dimension(m_iter+1) :: cs complex(kind=realdp), intent(inout), dimension(m_iter+1) :: sn integer, intent(in) :: k Calls proc~~apply_givens_rotation~~CallsGraph proc~apply_givens_rotation apply_givens_rotation cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~apply_givens_rotation~~CalledByGraph proc~apply_givens_rotation apply_givens_rotation proc~full_pgmres full_pgmres proc~full_pgmres->proc~apply_givens_rotation proc~fullgmres fullgmres proc~fullgmres->proc~apply_givens_rotation proc~pfgmres pfgmres proc~pfgmres->proc~apply_givens_rotation proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~apply_givens_rotation proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~apply_givens_rotation proc~restartgmres restartgmres proc~restartgmres->proc~apply_givens_rotation program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/apply_givens_rotation.html"},{"title":"back_substitute – ParaMADP","text":"public  subroutine back_substitute(H, beta, k) Apply BACK SUBSTITUTION Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(m_iter+1,m_iter) :: H complex(kind=realdp), intent(inout), dimension(m_iter+1) :: beta integer, intent(in) :: k Called by proc~~back_substitute~~CalledByGraph proc~back_substitute back_substitute proc~full_pgmres full_pgmres proc~full_pgmres->proc~back_substitute proc~fullgmres fullgmres proc~fullgmres->proc~back_substitute proc~pfgmres pfgmres proc~pfgmres->proc~back_substitute proc~pre_fullgmres Pre_fullgmres proc~pre_fullgmres->proc~back_substitute proc~pre_restartgmres Pre_restartgmres proc~pre_restartgmres->proc~back_substitute proc~restartgmres restartgmres proc~restartgmres->proc~back_substitute program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgmres program~helmholtz_2d->proc~fullgmres program~helmholtz_2d->proc~pfgmres program~helmholtz_2d->proc~pre_fullgmres program~helmholtz_2d->proc~pre_restartgmres program~helmholtz_2d->proc~restartgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/back_substitute.html"},{"title":"full_pgcr – ParaMADP","text":"public  subroutine full_pgcr(b, u, Rerror, iter) Right preconditioned GCR Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~full_pgcr~~CallsGraph proc~full_pgcr full_pgcr proc~dot_prod dot_prod proc~full_pgcr->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~full_pgcr->proc~helmholtz2d_bc proc~norm norm proc~full_pgcr->proc~norm proc~precond_x Precond_x proc~full_pgcr->proc~precond_x mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~norm->mpi_allreduce proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm cdsqrt cdsqrt proc~def_prefgmres->cdsqrt proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~red_glk_cslp_gmres->cdsqrt proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~full_pgcr~~CalledByGraph proc~full_pgcr full_pgcr program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~full_pgcr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/full_pgcr.html"},{"title":"pfgmres – ParaMADP","text":"public  subroutine pfgmres(b, u, Rerror, iter) Flexible GMRES with right precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter Calls proc~~pfgmres~~CallsGraph proc~pfgmres pfgmres proc~apply_givens_rotation apply_givens_rotation proc~pfgmres->proc~apply_givens_rotation proc~back_substitute back_substitute proc~pfgmres->proc~back_substitute proc~dot_prod dot_prod proc~pfgmres->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~pfgmres->proc~helmholtz2d_bc proc~norm norm proc~pfgmres->proc~norm proc~precond_x Precond_x proc~pfgmres->proc~precond_x cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt mpi_allreduce mpi_allreduce proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~norm->mpi_allreduce proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle mpi_sendrecv mpi_sendrecv proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~log2 LOG2 proc~multileveladp_px->proc~log2 proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~helmholtz2d_stencils proc~helm_ax_nth->proc~log2 proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_check_xy2d proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~restriction->proc~mg_checkreal_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->cdsqrt proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pfgmres~~CalledByGraph proc~pfgmres pfgmres program~helmholtz_2d helmholtz_2d program~helmholtz_2d->proc~pfgmres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pfgmres.html"},{"title":"comm_variable – ParaMADP","text":"This is a module that define some common variables for the whole project Uses mpi module~~comm_variable~~UsesGraph module~comm_variable comm_variable mpi mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~comm_variable~~UsedByGraph module~comm_variable comm_variable module~analytical_sol analytical_sol module~analytical_sol->module~comm_variable module~cslp_solver CSLP_Solver module~cslp_solver->module~comm_variable module~mpi_setup mpi_setup module~cslp_solver->module~mpi_setup module~operators operators module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber module~define_bc define_BC module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~define_grid define_grid module~define_grid->module~comm_variable module~define_rhs define_rhs module~define_rhs->module~comm_variable module~deflaion_setup deflaion_setup module~deflaion_setup->module~comm_variable module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~mpi_setup module~deflaion_setup->module~operators module~deflaion_setup->module~wavenumber module~idrs_module idrs_module module~idrs_module->module~comm_variable module~idrs_module->module~mpi_setup module~read_setup read_setup module~idrs_module->module~read_setup module~user_module user_module module~idrs_module->module~user_module module~mpi_setup->module~comm_variable module~operators->module~comm_variable module~operators->module~define_bc module~operators->module~mpi_setup module~operators->module~wavenumber module~read_setup->module~comm_variable module~smoother->module~comm_variable module~smoother->module~define_bc module~smoother->module~mpi_setup module~smoother->module~operators module~solvers solvers module~solvers->module~comm_variable module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~solvers->module~operators module~solvers->module~read_setup module~user_module->module~comm_variable module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~user_module->module~operators module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~write_data write_data module~write_data->module~comm_variable program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~comm_variable program~helmholtz_2d->module~analytical_sol program~helmholtz_2d->module~define_grid program~helmholtz_2d->module~define_rhs program~helmholtz_2d->module~idrs_module program~helmholtz_2d->module~mpi_setup program~helmholtz_2d->module~read_setup program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~wavenumber program~helmholtz_2d->module~write_data Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: realdp = 8 precision for the whole program real(kind=realdp), public, parameter :: pi = 3.141592653589793238d0 real(kind=realdp), public, parameter :: e = 2.7182818285d0 integer, public, parameter :: npMax = 400 the maximun number of partitions in one dimension complex(kind=realdp), public, parameter :: cone = (0.d0, 1.d0) complex(kind=realdp), public, parameter :: czero = (0.d0, 0.d0) Constants for complex numbers character(len=100), public :: filename character(len=100), public :: output_name character(len=100), public :: logname Strings for file names real(kind=realdp), public :: eps eps: tolerance for the outer iterations real(kind=realdp), public :: def_rtol def_rtol: tolerance for the coarse-grid solver in two-level deflation method real(kind=realdp), public :: cslp_mg_tol cslp_mg_tol: tolerance for Krylov based CSLP solver on coarse-grid levels integer, public :: m_iter m_iter: maximum number of outer iterations integer, public :: Algorithm Algorithm: solver identifier integer, public :: Irestart Irestart: Restart GMRES (1) or full GMRES (0) integer, public :: M_flag M_flag: Flag for preconditioner type integer, public :: M2h_flag M2h_flag: In two-level deflation method, flag for using CSLP for the coarse level (1) or not (0) integer, public :: A2h_flag A2h_flag: In two-level deflation method, flag for the ReD method used for the coarse level operator integer, public :: def_mg_miter def_mg_miter: maximum number of iterations for deflation on the coarse levels integer, public :: cslp_mg_miter cslp_mg_miter: maximum number of iterations for solving CSLP by multigrid method on the coarsest level integer, public :: MG_flag MG_flag: flag for the type of multigrid method integer, public :: nx_min nx_min: minimum number of grid points in x-direction for the coarsest grid, it is used to specified the grid size of the coarsest grid when coarsening integer, public :: def_nlevel def_nlevel: Number of levels in multilevel deflation method integer, public :: indf_level indf_level: The level that the linear system becomes indefinite integer, public :: Sv_L2 Sv_L2: In multilevel method, a single-digit number that sets the tolerance for the second coarse grid iterations, ex. 1 means 1E-1 integer, public :: Sv_L3 Sv_L3: In multilevel method, a single-digit number that sets the tolerance for the third coarse grid iterations, ex. 3 means 3E-1 integer, public :: Sv_L4 Sv_L4: In multilevel method, a single-digit number that sets the tolerance for the fourth coarse grid iterations, ex. 10 means one iteration integer, public :: npx0 npx0: Number of partitions in x-direction integer, public :: npy0 npy0: Number of partitions in y-direction integer, public :: npx npx: The coordinate/order of the current partition in x-direction integer, public :: npy npy: The coordinate/order of the current partition in y-direction integer, public :: nx_global nx_global: Global number of grid points in x-direction integer, public :: ny_global ny_global: Global number of grid points in y-direction integer, public :: nx nx: Local number of grid points of the current subdomain in x-direction integer, public :: ny ny: Local number of grid points of the current subdomain in y-direction integer, public :: ID_XM1 ID_XM1: Identifier for neighboring partition in the -x direction integer, public :: ID_XP1 ID_XP1: Identifier for neighboring partition in the +x direction integer, public :: ID_YM1 ID_YM1: Identifier for neighboring partition in the -y direction integer, public :: ID_YP1 ID_YP1: Identifier for neighboring partition in the +y direction integer, public :: Iperiodic_X Iperiodic_X: Periodicity flag in x-direction integer, public :: Iperiodic_Y Iperiodic_Y: Periodicity flag in y-direction real(kind=realdp), public :: slx slx: Physical length of the computational domain in x direction real(kind=realdp), public :: sly sly: Physical length of the computational domain in y direction real(kind=realdp), public :: hx hx: Grid spacing in x-direction real(kind=realdp), public :: hy hy: Grid spacing in y-direction real(kind=realdp), public :: hxhy hxhy: Product of grid spacings hx * hy, for this project hx must equal to hy, so hxhy=h&#94;2 integer, public, dimension(0:npMax - 1) :: i_offset i_offset: an array that contains the index offset for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: j_offset j_offset: an array that contains the index offset for MPI ranks in y direction integer, public, dimension(0:npMax - 1) :: i_nn i_nn: an array that contains the number of grid points for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: j_nn j_nn: an array that contains the number of grid points for MPI ranks in y direction integer, public :: LAP The number of overlapping layers. The higher order deflation will be turned on once LAP > 1 integer, public :: i_case Case identifier real(kind=realdp), public :: freq freq: the frequency for Helmholtz problem real(kind=realdp), public :: k0 k0: the wavenumber for constant-wavenumber model problem real(kind=realdp), public :: beta1 beta1: the real term for CSLP, usually 1.d0 real(kind=realdp), public :: beta2 beta2: the complex shift for CSLP integer, public :: k_case k_case: Case identifier for constant (0) or non-constant (1) wavenumber integer, public :: flag_BCs flag_BCs: Boundary conditions flag integer, public :: ierr ierr: MPI error code integer, public :: np_size np_size: the total number of MPI processes integer, public :: my_id my_id: MPI rank ID integer, public :: STATUS (MPI_STATUS_SIZE) MPI status array integer, public :: request1 MPI status array integer, public :: request2 MPI status array Derived Types type, public :: Gridpara Type definition for grid parameters Components Type Visibility Attributes Name Initial integer(kind=4), public :: nx_global integer(kind=4), public :: ny_global integer(kind=4), public :: nx integer(kind=4), public :: ny real(kind=realdp), public :: hx real(kind=realdp), public :: hy real(kind=realdp), public :: hxhy integer, public, dimension(0:npMax - 1) :: i_offset integer, public, dimension(0:npMax - 1) :: j_offset integer, public, dimension(0:npMax - 1) :: i_nn integer, public, dimension(0:npMax - 1) :: j_nn real(kind=realdp), public, allocatable, dimension(:,:) :: wavenumber_k wavenumber_k: the wavenumber profile of the domain real(kind=realdp), public, allocatable, dimension(:,:) :: wavenumber_kh_pow_2 wavenumber_kh_pow_2 = (kh)&#94;2","tags":"","loc":"module/comm_variable.html"},{"title":"user_module – ParaMADP","text":"A module for IDR(s) to make data type and operators compatible Uses deflaion_setup comm_variable mpi CSLP_Solver operators module~~user_module~~UsesGraph module~user_module user_module module~comm_variable comm_variable module~user_module->module~comm_variable module~cslp_solver CSLP_Solver module~user_module->module~cslp_solver module~deflaion_setup deflaion_setup module~user_module->module~deflaion_setup module~operators operators module~user_module->module~operators mpi mpi module~user_module->mpi module~comm_variable->mpi module~cslp_solver->module~comm_variable module~cslp_solver->module~operators module~cslp_solver->mpi module~mpi_setup mpi_setup module~cslp_solver->module~mpi_setup module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber module~deflaion_setup->module~comm_variable module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~deflaion_setup->mpi module~deflaion_setup->module~mpi_setup module~deflaion_setup->module~wavenumber module~operators->module~comm_variable module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~operators->module~mpi_setup module~operators->module~wavenumber module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~smoother->module~comm_variable module~smoother->module~operators module~smoother->module~define_bc module~smoother->module~mpi_setup module~wavenumber->module~comm_variable module~wavenumber->mpi module~wavenumber->module~mpi_setup Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~user_module~~UsedByGraph module~user_module user_module module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface OPERATOR(*) public  function rmatvec (A, v) This is an empty matrix-vector multiplication for real-type input v Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in) :: v (:,:) Return Value real(kind=realdp), (size(v,1),size(v,2)) public  function cmatvec (A, v) This is complex matrix-vector multiplication Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in) :: v (:,:) Return Value complex(kind=realdp), (size(v,1),size(v,2)) public        interface OPERATOR(/) public  function rprecon (v, M1) This is an empty preconditioner for real-type input v Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(:,:) :: v type( preconditioner ), intent(in) :: M1 Return Value real(kind=realdp), dimension(size(v,1),size(v,2)) public  function cprecon (v, M1) This is an preconditioner for complex-type input v, i.e. M1&#94;(-1)v\nWe can manully call different preconditioners here. Here only use multigrid-based CLSP Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (:,:) type( preconditioner ), intent(in) :: M1 Return Value complex(kind=realdp), (size(v,1),size(v,2)) Derived Types type, public :: matrix This is an empty matrix type type, public :: preconditioner Components Type Visibility Attributes Name Initial integer, public :: ni integer, public :: nj real(kind=realdp), public :: hx_c real(kind=realdp), public :: hy_c Functions public  function rmatvec (A, v) This is an empty matrix-vector multiplication for real-type input v Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in) :: v (:,:) Return Value real(kind=realdp), (size(v,1),size(v,2)) public  function cmatvec (A, v) This is complex matrix-vector multiplication Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in) :: v (:,:) Return Value complex(kind=realdp), (size(v,1),size(v,2)) public  function rprecon (v, M1) This is an empty preconditioner for real-type input v Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(:,:) :: v type( preconditioner ), intent(in) :: M1 Return Value real(kind=realdp), dimension(size(v,1),size(v,2)) public  function cprecon (v, M1) This is an preconditioner for complex-type input v, i.e. M1&#94;(-1)v\nWe can manully call different preconditioners here. Here only use multigrid-based CLSP Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (:,:) type( preconditioner ), intent(in) :: M1 Return Value complex(kind=realdp), (size(v,1),size(v,2))","tags":"","loc":"module/user_module.html"},{"title":"operators – ParaMADP","text":"This is a module to implement some matrix-free operations Uses define_BC comm_variable mpi mpi_setup wavenumber module~~operators~~UsesGraph module~operators operators module~comm_variable comm_variable module~operators->module~comm_variable module~define_bc define_BC module~operators->module~define_bc module~mpi_setup mpi_setup module~operators->module~mpi_setup module~wavenumber wavenumber module~operators->module~wavenumber mpi mpi module~operators->mpi module~comm_variable->mpi module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~operators~~UsedByGraph module~operators operators module~cslp_solver CSLP_Solver module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~deflaion_setup deflaion_setup module~deflaion_setup->module~operators module~deflaion_setup->module~cslp_solver module~smoother->module~operators module~solvers solvers module~solvers->module~operators module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~user_module user_module module~user_module->module~operators module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function norm (v) Compute the L2-norm of a complex variable, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v Return Value real(kind=realdp) public  function Realnorm (v) Compute the L2-norm of a real variable, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v Return Value real(kind=realdp) public  function dot_prod (v, w) Compute the do product of two complex variables, ONLY for the default grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: w Return Value complex(kind=realdp) public  function mg_norm (v, ni, nj) Compute the L2-norm of a complex variable, for a coarse-grid system. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v integer, intent(in) :: ni ni, nj: grid size of the subdomain on the current coarse grid level integer, intent(in) :: nj ni, nj: grid size of the subdomain on the current coarse grid level Return Value real(kind=realdp) public  function mg_dot_prod (v, w, ni, nj) Compute the dot product of two complex variables, for a coarse-grid system.\nNote that the dimension is not specified here, it means it calculate all the elements Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v complex(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: w integer, intent(in) :: ni ni, nj: grid size of the subdomain on the current coarse grid level integer, intent(in) :: nj ni, nj: grid size of the subdomain on the current coarse grid level Return Value complex(kind=realdp) public  function LOG2 (x) Compute log2(x) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: x Return Value real(kind=realdp) public  function Helm_Ax_nth (v_in, grid) ReD-Glk Helmholtz operator for coarse levels Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Parameters of the current grid system Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) public  function CSLP_Mx_nth (v_in, grid) ReD-Glk CSLP operator for coarse levels Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Subroutines public  subroutine Helmholtz2d_stencils (ap, an, as, aw, ae, hxhykxy2) Computational stencils for the Helmholtz operator, second-order central FD scheme Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae real(kind=realdp), intent(in) :: hxhykxy2 The value of (kh)&#94;2, which is computed and stored in advance. public  subroutine cslp2d_stencils (ap, an, as, aw, ae, hxhykxy2) Computational stencils for the CSLP operator Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae real(kind=realdp), intent(in) :: hxhykxy2 The value of (kh)&#94;2, which is computed and stored in advance public  subroutine Helmholtz2d_BC (v_in, v_out) matrix-free Helmholtz operator, ONLY for the default gird system\nFirst deal with the boundary grid points and then the internals Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: v_out public  subroutine Helmholtz2d_BC_mg (v_in, v_out, ni, nj, hx_c, hy_c, kxy, kh2) matrix-free Helmholtz operator, for the specified coarse gird systems Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_out integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 public  subroutine CSLP_OP_BC (v_in, v_out, ni, nj, hx_c, hy_c, kxy, kh2) matrix-free CSLP operator, for the specified gird systems Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_in complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: v_out integer, intent(in) :: ni ni,nj: grid size of subdomain on the current grid level integer, intent(in) :: nj ni,nj: grid size of subdomain on the current grid level real(kind=realdp), intent(in) :: hx_c hx_c,hy_c: space step of subdomain on the current grid level real(kind=realdp), intent(in) :: hy_c hx_c,hy_c: space step of subdomain on the current grid level real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy kxy: wavenumber profile of subdomain on the current grid level,kh2=(kh)&#94;2 real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 kxy: wavenumber profile of subdomain on the current grid level,kh2=(kh)&#94;2 public  subroutine GridBase_ExtrpltGhostBCs (v_in, grid) Extrapolation of a layer of ghost grid points Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid public  subroutine Helm_Ax_nth_stencils (Stcl_nth, grid, ic, jc) ReD-Glk computational stencils of the Helmholtz operator for differnet coarse-grid level\nDefault 2nd-ordr stencils Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: Stcl_nth (-3:3,-3:3) Resulting stencils for the Helmholtz operator type( Gridpara ), intent(inout) :: grid parameters for the current coarse-grid system integer :: ic Index for the wavenumber field integer :: jc Index for the wavenumber field public  subroutine CSLP_Mx_nth_stencils (Stcl_nth, grid, ic, jc) ReD-Glk computational stencils of the CSLP operator for differnet coarse-grid level Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: Stcl_nth (-3:3,-3:3) Resulting stencils for the CSLP operator type( Gridpara ), intent(inout) :: grid parameters for the current coarse-grid system integer :: ic Index for the wavenumber field integer :: jc Index for the wavenumber field","tags":"","loc":"module/operators.html"},{"title":"idrs_module – ParaMADP","text":"IDRS Induced Dimension Reduction method Uses user_module read_setup comm_variable mpi mpi_setup module~~idrs_module~~UsesGraph module~idrs_module idrs_module module~comm_variable comm_variable module~idrs_module->module~comm_variable module~mpi_setup mpi_setup module~idrs_module->module~mpi_setup module~read_setup read_setup module~idrs_module->module~read_setup module~user_module user_module module~idrs_module->module~user_module mpi mpi module~idrs_module->mpi module~comm_variable->mpi module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~read_setup->module~comm_variable module~read_setup->mpi module~user_module->module~comm_variable module~user_module->mpi module~cslp_solver CSLP_Solver module~user_module->module~cslp_solver module~deflaion_setup deflaion_setup module~user_module->module~deflaion_setup module~operators operators module~user_module->module~operators module~cslp_solver->module~comm_variable module~cslp_solver->module~mpi_setup module~cslp_solver->mpi module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber module~deflaion_setup->module~comm_variable module~deflaion_setup->module~mpi_setup module~deflaion_setup->mpi module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~deflaion_setup->module~wavenumber module~operators->module~comm_variable module~operators->module~mpi_setup module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~operators->module~wavenumber module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~smoother->module~comm_variable module~smoother->module~mpi_setup module~smoother->module~operators module~smoother->module~define_bc module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~idrs_module~~UsedByGraph module~idrs_module idrs_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface TRACE_DOT private  function CTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value complex(kind=realdp) private  function RTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) real(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp) private  function RCTRACE_DOT(v, w) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value complex(kind=realdp) public        interface P_DOT private  function CP_DOT(P, R0, w, s) Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), allocatable :: P (:,:,:) complex(kind=realdp), intent(in), allocatable :: R0 (:,:) complex(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) integer :: s Return Value complex(kind=realdp), (s) private  function RP_DOT(P, R0, w, s) made a big mistake here, only found after done numerous tests, Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in), allocatable :: P (:,:,:) real(kind=realdp), intent(in), allocatable :: R0 (:,:) real(kind=realdp), intent(in) :: w (1-LAP:nx+LAP,1-LAP:ny+LAP) integer :: s Return Value real(kind=realdp), (s) public        interface FROB_NORM private  function CFROB_NORM(v) Frobenius norm of complex matrix Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp) private  function RFROB_NORM(v) Frobenius norm of real matrix Arguments Type Intent Optional Attributes Name real(kind=realdp), intent(in) :: v (1-LAP:nx+LAP,1-LAP:ny+LAP) Return Value real(kind=realdp) public        interface IDRS private  function CIDRS(A, b, M1, s, tolerance, maximum_iterations, variant, flag, relres, iterations, x0, U0, omega, resvec, H) +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A complex(kind=realdp), intent(in), allocatable :: b (:,:) type( preconditioner ), intent(in) :: M1 integer, intent(in) :: s real(kind=realdp), intent(in), optional :: tolerance integer, intent(in), optional :: maximum_iterations character(len=8), intent(in), optional :: variant integer, intent(out), optional :: flag real(kind=realdp), intent(out), optional :: relres integer, intent(out), optional :: iterations complex(kind=realdp), intent(in), optional :: x0 (:,:) complex(kind=realdp), intent(in), optional :: U0 (:,:,:) complex(kind=realdp), intent(in), optional :: omega (:) real(kind=realdp), intent(out), optional :: resvec (:) complex(kind=realdp), intent(out), optional :: H (:,:) Return Value complex(kind=realdp), (size(b,1),size(b,2)) private  function RIDRS(A, b, M1, s, tolerance, maximum_iterations, variant, flag, relres, iterations, x0, U0, omega, H, resvec) +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++++++++++++ Arguments Type Intent Optional Attributes Name type( matrix ), intent(in) :: A real(kind=realdp), intent(in), allocatable :: b (:,:) type( preconditioner ), intent(in) :: M1 integer, intent(in) :: s real(kind=realdp), intent(in), optional :: tolerance integer, intent(in), optional :: maximum_iterations character(len=8), intent(in), optional :: variant integer, intent(out), optional :: flag real(kind=realdp), intent(out), optional :: relres integer, intent(out), optional :: iterations real(kind=realdp), intent(in), optional :: x0 (:,:) real(kind=realdp), intent(in), optional :: U0 (:,:,:) real(kind=realdp), intent(in), optional :: omega (:) real(kind=realdp), intent(out), optional :: H (:,:) real(kind=realdp), intent(out), optional :: resvec (:) Return Value real(kind=realdp), (size(b,1),size(b,2))","tags":"","loc":"module/idrs_module.html"},{"title":"read_setup – ParaMADP","text":"This is a module to read the input parameters for the solver settings Uses comm_variable mpi module~~read_setup~~UsesGraph module~read_setup read_setup module~comm_variable comm_variable module~read_setup->module~comm_variable mpi mpi module~read_setup->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~read_setup~~UsedByGraph module~read_setup read_setup module~idrs_module idrs_module module~idrs_module->module~read_setup module~solvers solvers module~solvers->module~read_setup program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~read_setup program~helmholtz_2d->module~idrs_module program~helmholtz_2d->module~solvers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: NparaMax = 50 the maximun number of integer input parameter integer, public, parameter :: RparaMax = 50 the maximun number of real input parameter Subroutines public  subroutine read_parameter () read the input parameters for the solver settings\nRead by Rank 0 and then broadcast to the other ranks\nGet the input filename Read more… Arguments None","tags":"","loc":"module/read_setup.html"},{"title":"define_BC – ParaMADP","text":"This is a module to deal with the computational stencils for the Dirichlet of Sommerfeld boundary conditions Uses comm_variable wavenumber module~~define_bc~~UsesGraph module~define_bc define_BC module~comm_variable comm_variable module~define_bc->module~comm_variable module~wavenumber wavenumber module~define_bc->module~wavenumber mpi mpi module~comm_variable->mpi module~wavenumber->module~comm_variable module~mpi_setup mpi_setup module~wavenumber->module~mpi_setup module~wavenumber->mpi module~mpi_setup->module~comm_variable module~mpi_setup->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~define_bc~~UsedByGraph module~define_bc define_BC module~operators operators module~operators->module~define_bc module~smoother smoother module~smoother->module~define_bc module~smoother->module~operators module~cslp_solver CSLP_Solver module~cslp_solver->module~operators module~cslp_solver->module~smoother module~deflaion_setup deflaion_setup module~deflaion_setup->module~operators module~deflaion_setup->module~cslp_solver module~solvers solvers module~solvers->module~operators module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~user_module user_module module~user_module->module~operators module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine if_BCs (ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c, kxy) Determine which BC, for specified coarse grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in) :: kxy public  subroutine Dirichlet (ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c) Dirichlet, ap=h&#94;2, which will devided by h&#94;2 in the rountine of the operator\nWhen use this Dirichlet, you have to be carefull with the RHS respectively Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c public  subroutine first_order_Neum (ap, an, as, aw, ae, i, j, ni, nj, hx_c, hy_c, kxy) Sommerfeld boundary conditions. Eliminate the ghost grid points by second-order discretization Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: ap real(kind=realdp) :: an real(kind=realdp) :: as real(kind=realdp) :: aw real(kind=realdp) :: ae integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in) :: kxy","tags":"","loc":"module/define_bc.html"},{"title":"deflaion_setup – ParaMADP","text":"This is an integrated module for deflation preconditioning Uses mpi_setup comm_variable mpi CSLP_Solver operators wavenumber module~~deflaion_setup~~UsesGraph module~deflaion_setup deflaion_setup module~comm_variable comm_variable module~deflaion_setup->module~comm_variable module~cslp_solver CSLP_Solver module~deflaion_setup->module~cslp_solver module~mpi_setup mpi_setup module~deflaion_setup->module~mpi_setup module~operators operators module~deflaion_setup->module~operators module~wavenumber wavenumber module~deflaion_setup->module~wavenumber mpi mpi module~deflaion_setup->mpi module~comm_variable->mpi module~cslp_solver->module~comm_variable module~cslp_solver->module~mpi_setup module~cslp_solver->module~operators module~cslp_solver->module~wavenumber module~cslp_solver->mpi module~smoother smoother module~cslp_solver->module~smoother module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~operators->module~comm_variable module~operators->module~mpi_setup module~operators->module~wavenumber module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~smoother->module~comm_variable module~smoother->module~mpi_setup module~smoother->module~operators module~smoother->module~define_bc Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~deflaion_setup~~UsedByGraph module~deflaion_setup deflaion_setup module~solvers solvers module~solvers->module~deflaion_setup module~user_module user_module module~user_module->module~deflaion_setup module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface TwoGrids public  function FromFine2Coarse (OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: OneGrid Return Value type( TwoGrids ) Derived Types type, public :: TwoGrids Type definition for a two-grid system. \"f\" in variable names stands for fine grid, \"c\" in variable names stands for coarse grid Components Type Visibility Attributes Name Initial integer(kind=4), public :: nxf_global integer(kind=4), public :: nyf_global integer(kind=4), public :: nxf integer(kind=4), public :: nyf integer(kind=4), public :: nxc_global integer(kind=4), public :: nyc_global integer(kind=4), public :: nxc integer(kind=4), public :: nyc real(kind=realdp), public :: hxf real(kind=realdp), public :: hyf real(kind=realdp), public :: hxhyf real(kind=realdp), public :: hxc real(kind=realdp), public :: hyc real(kind=realdp), public :: hxhyc integer, public, dimension(0:npMax - 1) :: if_offset integer, public, dimension(0:npMax - 1) :: jf_offset integer, public, dimension(0:npMax - 1) :: if_nn integer, public, dimension(0:npMax - 1) :: jf_nn integer, public, dimension(0:npMax - 1) :: ic_offset integer, public, dimension(0:npMax - 1) :: jc_offset integer, public, dimension(0:npMax - 1) :: ic_nn integer, public, dimension(0:npMax - 1) :: jc_nn real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_f real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_c real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_f real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_c Constructor public\n\n                    \n                    function FromFine2Coarse (OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Functions public  function DEF_Px (x) Identifier for different deflation methods, ONLY for an input array from the default (finest) grid system\nA basic deflation method Read more… Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: x Return Value complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) public  function FromFine2Coarse (OneGrid) A procedure to create a two-grid system from a given fine Gridpara type\nThe wavenumber of the coarse level is restricted from the fine level Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: OneGrid Return Value type( TwoGrids ) public  function CoarseGridpara (f2c) A procedure to create a Gridpara type of the coarse grid system from a given a two-grid system Arguments Type Intent Optional Attributes Name type( TwoGrids ), intent(inout) :: f2c Return Value type( Gridpara ) public  function ZTx (x, f2c) Restriction of a variable, by full-weight restriction or higher-order restriction depending on the laylers of overlapping grid points used. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public  function Zx (x, f2c) Interpolation of a variable from coarse to fine, by bilinear or higher-order interpolation depending on the laylers of overlapping grid points used. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public  function ZTZx (x, f2c) A routine that first perform restriction and then interpolation Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public  function Helm_Ahx (x, f2c) A function that performs the Helmholtz operator on the fine grid of the two-grid system, by ReD-O2 method Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public  function Helm_A2hx (x, f2c) A function that performs the Helmholtz operator on the coarse grid of the two-grid system, by different methods\nReD-O2\nReD-Glk\nReD-cmpO4 Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public  function Ex (x, f2c) Coarse-grid operation for two-level deflation\nStraight-forward Galerkin coarsening approach Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public  function invEy (y, f2c) Invert the coarse-grid operator for two-level delfation method, by using GMRES or Bi-CGSTAB\ndetermined by the specified maximum number of iterations on the coarse grid Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public recursive function MultiLevel_invEy (y, f2c) A recursive function to invert the coarse-level operators for multilevel delfation methods, by using preconditioned FGMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) public  function Qx (x, f2c) Perform y=Qx in deflation definition, where Q=ZE&#94;(-1)Z&#94;T Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public  function Px (x, f2c) Perform y=Px in deflation definition, where P=I-AQ Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public  function P_DEFx (x, f2c) Deflation preconditioning, P = (I-AQ)+Q Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public  function P_ADEF1x (x, f2c) Adapted Deflation Preconditioning, P = M&#94;(-1)(I-AQ)+Q, including higher-order deflation (ADP) if LAP > 1 Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) public recursive function MultiLevelADP_Px (x, grid) Multilevel deflation preconditioning (MADP) \nMultigrid-based CSLP on the finest and second level\nKrylov-based CSLP on the finest and second level Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: x (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) type( Gridpara ), intent(inout) :: grid Return Value complex(kind=realdp), (1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) public  function P_TLKMx (x, f2c) Two-Level Krylov Method, P = [(I-M&#94;(-1)AQ )+Q ]M&#94;(-1), where Q' is defined based on M&#94;(-1)A\nM&#94;(-1)x\nQM&#94;(-1)x Read more… Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) type( TwoGrids ), intent(inout) :: f2c Return Value complex(kind=realdp), (1-LAP:f2c%nxf+LAP,1-LAP:f2c%nyf+LAP) Subroutines public  subroutine default_gridpara (finestgrid) This is a rountine to define the default finest Gridpara from the common grid parameters of the whole project Arguments Type Intent Optional Attributes Name type( Gridpara ), intent(inout) :: finestgrid public  subroutine wavenumber_FWrestriction (f2c) This routine obtains the wavenumber of the coarse level by full-weight restriction from the fine level Arguments Type Intent Optional Attributes Name type( TwoGrids ), intent(inout) :: f2c public  subroutine DEF_fullgmres (y, x, f2c) A (CSLP preconditioned) GMRES solver for the coarse-grid problem in two-level deflation method\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"def_mg_miter+1\".So we need a k. Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c public  subroutine def_arnoldi (V, H, k, f2c, CurrentGrid) Arnoldi prosess of DEF_fullgmres\nAttention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP,def_mg_miter+1) :: V complex(kind=realdp), intent(inout), dimension(def_mg_miter+1,def_mg_miter) :: H integer, intent(in) :: k type( TwoGrids ), intent(inout) :: f2c type( Gridpara ) :: CurrentGrid public  subroutine def_apply_givens_rotation (H, cs, sn, k) Apply givens rotation of DEF_fullgmres Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(def_mg_miter+1,def_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: cs complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: sn integer, intent(in) :: k public  subroutine def_back_substitute (H, beta, k) Perform back substitute in of DEF_fullgmres Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(def_mg_miter+1,def_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(def_mg_miter+1) :: beta integer, intent(in) :: k public  subroutine DEF_bicgstab (y, x, f2c) A (CSLP preconditioned) Bi-CGSTAB solver for the coarse-grid problem in two-level deflation method Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c public recursive subroutine DEF_prefgmres (y, x, f2c, maximum_iterations, level, rtol) A recursive flexible GMRES with right deflation preconditioning\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"maxit+1\".So we need a k. Read more… Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: y (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: x (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c integer, intent(in), optional :: maximum_iterations integer, intent(in), optional :: level real(kind=realdp), intent(in), optional :: rtol public  subroutine Helmholtz2d_O4cmpct (v_in, v_out, f2c) A coarse-grid Helmholtz operator for two-level deflation, descretized by a classic compact fourth-order FD scheme Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: v_out (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c public  subroutine Helmholtz2d_ReD_Glk (v_in, v_out, f2c) A coarse-grid Helmholtz operator for two-level deflation, descretized by ReD-GLK FD scheme\nfill in a layer of ghost grid points by boundary conditions Read more… Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) complex(kind=realdp), intent(inout) :: v_out (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c public  subroutine ReD_Glk_stencils (a, b, f2c, ic, jc) ReD-Glk computational stencils of the Helmholtz operator for coarse-grid level in two-deflation method Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: a (-2:2,-2:2) a: Laplace operator complex(kind=realdp) :: b (-2:2,-2:2) b: wavenumber operator type( TwoGrids ), intent(inout) :: f2c integer :: ic integer :: jc public  subroutine ExtrpltGhostBCs (v_in, f2c) Extrapolate a layer of ghost grid points based on the boundary conditions \nThe zero padding of wavenumber is ok in practical Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout) :: v_in (1-LAP:f2c%nxc+LAP,1-LAP:f2c%nyc+LAP) type( TwoGrids ), intent(inout) :: f2c","tags":"","loc":"module/deflaion_setup.html"},{"title":"CSLP_Solver – ParaMADP","text":"This is a module to solve the inverse of CSLP approximately\nBy multigrid methods or Krylov iterations Uses mpi_setup comm_variable mpi smoother operators wavenumber module~~cslp_solver~~UsesGraph module~cslp_solver CSLP_Solver module~comm_variable comm_variable module~cslp_solver->module~comm_variable module~mpi_setup mpi_setup module~cslp_solver->module~mpi_setup module~operators operators module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber mpi mpi module~cslp_solver->mpi module~comm_variable->mpi module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~operators->module~comm_variable module~operators->module~mpi_setup module~operators->module~wavenumber module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~smoother->module~comm_variable module~smoother->module~mpi_setup module~smoother->module~operators module~smoother->module~define_bc module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi module~define_bc->module~comm_variable module~define_bc->module~wavenumber Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~cslp_solver~~UsedByGraph module~cslp_solver CSLP_Solver module~deflaion_setup deflaion_setup module~deflaion_setup->module~cslp_solver module~solvers solvers module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~user_module user_module module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: GridSystem A data type that collect some info of a (coarse) grid system \nIt is different the type Gridpara, which does not consist any variable like u, rhs, res, and etc. Components Type Visibility Attributes Name Initial integer(kind=4), public :: nxc_global Global grid size, in x and y directions respectively. integer(kind=4), public :: nyc_global Global grid size, in x and y directions respectively. integer(kind=4), public :: nxc Local grid size of a subdomain, in x and y directions respectively. integer(kind=4), public :: nyc Local grid size of a subdomain, in x and y directions respectively. integer, public, dimension(0:npMax - 1) :: ic_offset ic_offset: an array that contains the index offset for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: jc_offset jc_offset: an array that contains the index offset for MPI ranks in y direction integer, public, dimension(0:npMax - 1) :: ic_nn ic_nn: an array that contains the number of grid points for MPI ranks in x direction integer, public, dimension(0:npMax - 1) :: jc_nn jc_nn: an array that contains the number of grid points for MPI ranks in y direction real(kind=realdp), public :: hxc space step, hxhyc==hx*hy==hx&#94;2 real(kind=realdp), public :: hyc space step, hxhyc==hx*hy==hx&#94;2 real(kind=realdp), public :: hxhyc space step, hxhyc==hx*hy==hx&#94;2 complex(kind=realdp), public, allocatable, dimension(:,:) :: u_c Solution variable in subdomain complex(kind=realdp), public, allocatable, dimension(:,:) :: rhs_c RHS variable in subdomain complex(kind=realdp), public, allocatable, dimension(:,:) :: res_c Residual variable in subdomain real(kind=realdp), public, allocatable, dimension(:,:) :: kxy_c wavenumber in subdomain real(kind=realdp), public, allocatable, dimension(:,:) :: kh2_c wavenumber in subdomain Functions public  function MGCSLP_invMx (b_in) Multigrid-Based CSLP, ONLY starts from the default (finest) grid sysyem\nOne V-cycle\nTwo V-cycle\nOne F-cycle Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b_in Return Value complex(kind=realdp), (1-LAP:nx+LAP,1-LAP:ny+LAP) MGCSLP_invMx = M_h&#94;(-1)(b_h) public  function MGCSLP_invMHx (b_in, grid) Multigrid-based CSLP, starts from the a specified grid system\nOne V-cycle\nTwo V-cycle\nOne F-cycle Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) :: b_in type( Gridpara ) :: grid A data type that collect some parameters of a system Return Value complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) MGCSLP_invMHx = M_H&#94;(-1)(b_H) public  function KrylovCSLP_invMHx (b_in, grid) Krylov-based CSLP, starts from the a specified grid sysyem\nChoose Bi-CGSATB or GMRES by uncomment or comment Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) :: b_in type( Gridpara ) :: grid A data type that collect some parameters of a system Return Value complex(kind=realdp), dimension(1-LAP:grid%nx+LAP,1-LAP:grid%ny+LAP) Subroutines public  subroutine finestgrid_define (mg_finest) This is a routine that define the finest grid system from the default (finest) grid parameters Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_finest public  subroutine gridsys_define (grid, basegridsys) This is a routine that define a GridSystem type from the grid parameters of a data type Gridpara\nOne can find the differnece of GridSystem and Gridpara Arguments Type Intent Optional Attributes Name type( Gridpara ) :: grid type( GridSystem ) :: basegridsys public  subroutine coarsegrid_create (mg_coarse, mg_fine) This is a routine that define a coarse grid system mg_coarse from a fine grid system mg_fine Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine public  subroutine grid_destroy (mg_dm) This is a routine that deallocate the arrays of a grid system Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_dm public  subroutine restriction (mg_coarse, mg_fine) This is routine that perform full-weight resctriction from fine to coarse grid system, mainly\nresidual (res) on fine grid --> right-hand side (rhs) on coarse grid,\nwavenumber on fine grid --> wavenumber on the coarse grid\nBased on the relationship of the index between the fine and coarse grid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine public  subroutine prolongation_en_correct (mg_coarse, mg_fine) This is routine that perform bilinear interpolation and correction from coarse to fine grid system, mainly\nsolution (u) on coarse grid --> correction (e_h) for solution (u) of fine grid\nBased on the relationship of the index between the fine and coarse grid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_coarse type( GridSystem ), intent(inout) :: mg_fine public recursive subroutine V_cycle (mg_fine) A classic multigrid V-cycle\nA classic Two-Cycle\nGMRES or Bi-CGSTAB can be chose to solve the coarse-grid problem\nGMRES or Bi-CGSTAB can be chose to solve the coarsest-grid problem Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_fine public recursive subroutine F_cycle (mg_fine) This is a classic F-cycle multigrid Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_fine public  subroutine mg_fullgmres (mg_solve) This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using GMRES\n The CSLP is define by ReD-O2 scheme\nBe careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k.\n The default tolerance is 1E-08 Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve The current coarsest grid system public  subroutine mg_arnoldi (V, H, k, ni, nj, hx_c, hy_c, kxy, kh2) Arnoldi precess\n w=A*v_i Read more… Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP,cslp_mg_miter+1) :: V complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H integer, intent(in) :: k integer, intent(in) :: ni integer, intent(in) :: nj real(kind=realdp), intent(in) :: hx_c real(kind=realdp), intent(in) :: hy_c real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 public  subroutine mg_apply_givens_rotation (H, cs, sn, k) This is routine to perform apply_givens_rotation Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: cs complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: sn integer, intent(in) :: k public  subroutine mg_back_substitute (H, beta, k) This is routine that performs back substitute Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(cslp_mg_miter+1,cslp_mg_miter) :: H complex(kind=realdp), intent(inout), dimension(cslp_mg_miter+1) :: beta integer, intent(in) :: k public  subroutine mg_bicgstab (mg_solve, maximum_iterations) This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using Bi-CGSTAB\nThe CSLP is define by ReD-O2 scheme Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve integer, intent(in), optional :: maximum_iterations User-specified maximum number of iterations public  subroutine ReD_Glk_CSLP_bicgstab (mg_solve, grid, maximum_iterations) This is a rountine to solve a coarse grid CSLP system approximately by using Bi-CGSTAB. \nThe CSLP operator is defined by ReD-Glk scheme. \nCSLP operator by ReD-Glk Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve The current coarse grid system type( Gridpara ) :: grid Parameters of current coarse grid integer, intent(in), optional :: maximum_iterations public  subroutine ReD_Glk_CSLP_gmres (mg_solve, grid, maximum_iterations) This is a rountine to solve a coarse grid CSLP system approximately by using GMRES\n The CSLP operator is defined by ReD-Glk scheme\n CSLP operator by ReD-Glk Read more… Arguments Type Intent Optional Attributes Name type( GridSystem ), intent(inout) :: mg_solve type( Gridpara ) :: grid integer, intent(in), optional :: maximum_iterations User-specified maximum number of iterations,default is 300","tags":"","loc":"module/cslp_solver.html"},{"title":"mpi_setup – ParaMADP","text":"Module for setting up MPI partition and data exchange Uses comm_variable mpi module~~mpi_setup~~UsesGraph module~mpi_setup mpi_setup module~comm_variable comm_variable module~mpi_setup->module~comm_variable mpi mpi module~mpi_setup->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mpi_setup~~UsedByGraph module~mpi_setup mpi_setup module~cslp_solver CSLP_Solver module~cslp_solver->module~mpi_setup module~operators operators module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber module~deflaion_setup deflaion_setup module~deflaion_setup->module~mpi_setup module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~deflaion_setup->module~wavenumber module~idrs_module idrs_module module~idrs_module->module~mpi_setup module~user_module user_module module~idrs_module->module~user_module module~operators->module~mpi_setup module~operators->module~wavenumber module~define_bc define_BC module~operators->module~define_bc module~smoother->module~mpi_setup module~smoother->module~operators module~smoother->module~define_bc module~wavenumber->module~mpi_setup program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~mpi_setup program~helmholtz_2d->module~idrs_module program~helmholtz_2d->module~wavenumber module~solvers solvers program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module module~define_bc->module~wavenumber module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~solvers->module~operators module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~user_module->module~operators Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function my_mod1 (na, nb) A function to calculate the modulo of two integers na and nb Arguments Type Intent Optional Attributes Name integer :: na integer :: nb Return Value integer Subroutines public  subroutine part2d () Partitions the 2D domain for parallel processing and calculates offsets and sizes for each partition\nthe ID of partion along 2 directions\n-1 proc in x-direction\n+1 proc in x-direction\nif not periodic, 0 node donot send mesg to npx0-1 node\nif not periodic, npx0-1 node donot send mesg to 0 node Arguments None public  subroutine check_x2d (f) Exchanges data in the x direction, ONLY for the default (finest) grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) public  subroutine check_y2d (f) Exchanges data in the y direction, ONLY for the default (finest) grid system\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) public  subroutine check_xy2d (f) Exchanges data first in the x direction and then y direction, ONLY for the default (finest) grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:nx+LAP,1-LAP:ny+LAP) public  subroutine mg_check_x2d (f, ni, nj) Exchanges data in the x direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj public  subroutine mg_check_y2d (f, ni, nj) Exchanges data in the y direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj public  subroutine mg_check_xy2d (f, ni, nj) Exchanges data first in the x direction and then y direction, for a specified-size grid system Arguments Type Intent Optional Attributes Name complex(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj public  subroutine mg_checkreal_x2d (f, ni, nj) Exchanges REAL data in the x direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj public  subroutine mg_checkreal_y2d (f, ni, nj) Exchanges REAL data in the y direction, for a specified-size grid system\nno2\nno2 Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj public  subroutine mg_checkreal_xy2d (f, ni, nj) Exchanges REAL data first in the x direction and then y direction, for a specified-size grid system Arguments Type Intent Optional Attributes Name real(kind=realdp) :: f (1-LAP:ni+LAP,1-LAP:nj+LAP) integer, intent(in) :: ni integer, intent(in) :: nj","tags":"","loc":"module/mpi_setup.html"},{"title":"define_rhs – ParaMADP","text":"This is a module to determine the right-hand side for different model problems Uses comm_variable mpi module~~define_rhs~~UsesGraph module~define_rhs define_rhs module~comm_variable comm_variable module~define_rhs->module~comm_variable mpi mpi module~define_rhs->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~define_rhs~~UsedByGraph module~define_rhs define_rhs program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~define_rhs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine RHS_2DCloseOff (b, xx, yy) 2D close-off problem with Dirichlet boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine RHS_CenterSource2D (b, xx, yy) 2D constant wavenumber problem with a central point source\nA point source located at (0.5,0.5) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine RHS_2DWedge (b, xx, yy) 2D Wedge problem\nA point source located at (300,0) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine RHS_marmousi (b, xx, yy) Marmousi problem\nA point source located at (6000,0) Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy","tags":"","loc":"module/define_rhs.html"},{"title":"wavenumber – ParaMADP","text":"This module is used to determine the wavenumber of the computational domain, as well as (kh)&#94;2 Uses comm_variable mpi mpi_setup module~~wavenumber~~UsesGraph module~wavenumber wavenumber module~comm_variable comm_variable module~wavenumber->module~comm_variable module~mpi_setup mpi_setup module~wavenumber->module~mpi_setup mpi mpi module~wavenumber->mpi module~comm_variable->mpi module~mpi_setup->module~comm_variable module~mpi_setup->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~wavenumber~~UsedByGraph module~wavenumber wavenumber module~cslp_solver CSLP_Solver module~cslp_solver->module~wavenumber module~operators operators module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~define_bc define_BC module~define_bc->module~wavenumber module~deflaion_setup deflaion_setup module~deflaion_setup->module~wavenumber module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~operators->module~wavenumber module~operators->module~define_bc program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~wavenumber module~solvers solvers program~helmholtz_2d->module~solvers module~user_module user_module program~helmholtz_2d->module~user_module module~idrs_module idrs_module program~helmholtz_2d->module~idrs_module module~smoother->module~define_bc module~smoother->module~operators module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~solvers->module~operators module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~user_module->module~operators module~idrs_module->module~user_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=realdp), public, allocatable, dimension(:,:) :: wavenumber_k real(kind=realdp), public, allocatable, dimension(:,:) :: kh_pow_2 Subroutines public  subroutine Const_K () constant wavenumber, determine by input variable k0\ndata communication with neighbouring subdomains Arguments None public  subroutine wavenumber_k_Wedge (xx, yy) Wavenumber for Wedge model problem\nThe top layer\nThe bottom layer\nThe middle layer Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine read_wavenumber_k_marmousi () Read the velocity profile of Marmousi problem with specified grid size and calculate the wavenumber Arguments None public  subroutine wavenumber_k_destroy () Deallocate the wavenumber field in the end Arguments None","tags":"","loc":"module/wavenumber.html"},{"title":"define_grid – ParaMADP","text":"This is a module to determine the grid coordinate. \nFirst determined by Rank 0 and then distributed to the other ranks. \nFor now, only rectangular domain with uniform space step size, i.e. hx==hy. Uses comm_variable mpi module~~define_grid~~UsesGraph module~define_grid define_grid module~comm_variable comm_variable module~define_grid->module~comm_variable mpi mpi module~define_grid->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~define_grid~~UsedByGraph module~define_grid define_grid program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~define_grid Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine define_uniform_grid (phys1, phys2) A square computational domain with a unit side length Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 Local coordinates in x and y directions real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2 Local coordinates in x and y directions public  subroutine define_wedge_grid (phys1, phys2) Wedge model problem Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2 public  subroutine define_marmousi_grid (phys1, phys2) Marmousi problem Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys1 real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: phys2","tags":"","loc":"module/define_grid.html"},{"title":"smoother – ParaMADP","text":"A smoother module Uses define_BC comm_variable operators mpi_setup module~~smoother~~UsesGraph module~smoother smoother module~comm_variable comm_variable module~smoother->module~comm_variable module~define_bc define_BC module~smoother->module~define_bc module~mpi_setup mpi_setup module~smoother->module~mpi_setup module~operators operators module~smoother->module~operators mpi mpi module~comm_variable->mpi module~define_bc->module~comm_variable module~wavenumber wavenumber module~define_bc->module~wavenumber module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~operators->module~comm_variable module~operators->module~define_bc module~operators->module~mpi_setup module~operators->module~wavenumber module~operators->mpi module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~smoother~~UsedByGraph module~smoother smoother module~cslp_solver CSLP_Solver module~cslp_solver->module~smoother module~deflaion_setup deflaion_setup module~deflaion_setup->module~cslp_solver module~solvers solvers module~solvers->module~cslp_solver module~solvers->module~deflaion_setup module~user_module user_module module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~idrs_module idrs_module module~idrs_module->module~user_module program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers program~helmholtz_2d->module~user_module program~helmholtz_2d->module~idrs_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Damp_Jacobi_smoother (x, rhs, ni, nj, hx_c, hy_c, kxy, kh2) This is a routine to apply damped Jacobbi smoother on coarse grid systems. Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: x complex(kind=realdp), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: rhs local arguements integer, intent(in) :: ni subdomain grid size on the current coarse level integer, intent(in) :: nj subdomain grid size on the current coarse level real(kind=realdp), intent(in) :: hx_c coarse-grid space step size real(kind=realdp), intent(in) :: hy_c coarse-grid space step size real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kxy Wavenumber and (kh)&#94;2 real(kind=realdp), intent(in), dimension(1-LAP:ni+LAP,1-LAP:nj+LAP) :: kh2 Wavenumber and (kh)&#94;2","tags":"","loc":"module/smoother.html"},{"title":"write_data – ParaMADP","text":"A module for solutions output. \nThe idea is to collect the data from the other ranks to rank 0, and then write into a tecplot file (.plt). Uses comm_variable mpi module~~write_data~~UsesGraph module~write_data write_data module~comm_variable comm_variable module~write_data->module~comm_variable mpi mpi module~write_data->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~write_data~~UsedByGraph module~write_data write_data program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~write_data Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine write_data_whole (xx, yy, u) Write the solutions Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u public  subroutine write_exact_data_whole (xx, yy, u) Write the analytical solutions Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u public  subroutine write_real_data_whole (xx, yy, u) Write the real wavenumber/variables Arguments Type Intent Optional Attributes Name real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u","tags":"","loc":"module/write_data.html"},{"title":"analytical_sol – ParaMADP","text":"This is a module to compute analytical solutions for some model problems Uses comm_variable mpi module~~analytical_sol~~UsesGraph module~analytical_sol analytical_sol module~comm_variable comm_variable module~analytical_sol->module~comm_variable mpi mpi module~analytical_sol->mpi module~comm_variable->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~analytical_sol~~UsedByGraph module~analytical_sol analytical_sol program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~analytical_sol Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine exact_2DCloseOff (u_ex, xx, yy) The analytical solution for 2D close-off problem Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine exact_2DPointSource_1stSomer (u_ex, xx, yy) The analytical solution for constant wavenumber problem with central source point with Sommerfeld boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy public  subroutine exact_2DPointSource_Dirichlet (u_ex, xx, yy) The analytical solution for constant wavenumber problem with central source point with Dirichlet boundary condition Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u_ex real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: xx real(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: yy","tags":"","loc":"module/analytical_sol.html"},{"title":"solvers – ParaMADP","text":"Serveral GMRES-type Krylov solvers. Only applies to the (default) finest grid level Uses read_setup comm_variable deflaion_setup mpi CSLP_Solver operators module~~solvers~~UsesGraph module~solvers solvers module~comm_variable comm_variable module~solvers->module~comm_variable module~cslp_solver CSLP_Solver module~solvers->module~cslp_solver module~deflaion_setup deflaion_setup module~solvers->module~deflaion_setup module~operators operators module~solvers->module~operators module~read_setup read_setup module~solvers->module~read_setup mpi mpi module~solvers->mpi module~comm_variable->mpi module~cslp_solver->module~comm_variable module~cslp_solver->module~operators module~cslp_solver->mpi module~mpi_setup mpi_setup module~cslp_solver->module~mpi_setup module~smoother smoother module~cslp_solver->module~smoother module~wavenumber wavenumber module~cslp_solver->module~wavenumber module~deflaion_setup->module~comm_variable module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~deflaion_setup->mpi module~deflaion_setup->module~mpi_setup module~deflaion_setup->module~wavenumber module~operators->module~comm_variable module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~operators->module~mpi_setup module~operators->module~wavenumber module~read_setup->module~comm_variable module~read_setup->mpi module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~smoother->module~comm_variable module~smoother->module~operators module~smoother->module~define_bc module~smoother->module~mpi_setup module~wavenumber->module~comm_variable module~wavenumber->mpi module~wavenumber->module~mpi_setup Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~solvers~~UsedByGraph module~solvers solvers program~helmholtz_2d helmholtz_2d program~helmholtz_2d->module~solvers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function Precond_x (x) This is a routine to select which preconditioner is applied, Precond_x = P&#94;(-1)x Arguments Type Intent Optional Attributes Name complex(kind=realdp), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: x Return Value complex(kind=realdp), (1-LAP:nx+LAP,1-LAP:ny+LAP) Subroutines public  subroutine fullgmres (b, u, Rerror, iter) Full GMRES without precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter public  subroutine restartgmres (b, u, Rerror, iter_total) Restart GMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter_total public  subroutine Pre_fullgmres (b, u, Rerror, iter) Full GMRES with left preconditioned Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter public  subroutine full_pgmres (b, u, Rerror, iter) Full GMRES with right precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter public  subroutine Pre_restartgmres (b, u, Rerror, iter) Preconditioned restart GMRES Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter public  subroutine arnoldi (V, H, k) ARNOLDI precess Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP,m_iter+1) :: V complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H integer, intent(in) :: k public  subroutine Prearnoldi (V, H, k) Preconditioned ARNOLDI precess Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP,m_iter+1) :: V complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H integer, intent(in) :: k public  subroutine apply_givens_rotation (H, cs, sn, k) APPLY GIVENS ROTATION Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(inout), dimension(m_iter+1,m_iter) :: H complex(kind=realdp), intent(inout), dimension(m_iter+1) :: cs complex(kind=realdp), intent(inout), dimension(m_iter+1) :: sn integer, intent(in) :: k public  subroutine back_substitute (H, beta, k) Apply BACK SUBSTITUTION Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(m_iter+1,m_iter) :: H complex(kind=realdp), intent(inout), dimension(m_iter+1) :: beta integer, intent(in) :: k public  subroutine full_pgcr (b, u, Rerror, iter) Right preconditioned GCR Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter public  subroutine pfgmres (b, u, Rerror, iter) Flexible GMRES with right precondition Arguments Type Intent Optional Attributes Name complex(kind=realdp), intent(in), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: b complex(kind=realdp), intent(inout), dimension(1-LAP:nx+LAP,1-LAP:ny+LAP) :: u real(kind=realdp), intent(out) :: Rerror integer, intent(inout) :: iter","tags":"","loc":"module/solvers.html"},{"title":"helmholtz_2d – ParaMADP","text":"Uses user_module define_grid read_setup analytical_sol solvers write_data comm_variable mpi define_rhs mpi_setup idrs_module wavenumber program~~helmholtz_2d~~UsesGraph program~helmholtz_2d helmholtz_2d module~analytical_sol analytical_sol program~helmholtz_2d->module~analytical_sol module~comm_variable comm_variable program~helmholtz_2d->module~comm_variable module~define_grid define_grid program~helmholtz_2d->module~define_grid module~define_rhs define_rhs program~helmholtz_2d->module~define_rhs module~idrs_module idrs_module program~helmholtz_2d->module~idrs_module module~mpi_setup mpi_setup program~helmholtz_2d->module~mpi_setup module~read_setup read_setup program~helmholtz_2d->module~read_setup module~solvers solvers program~helmholtz_2d->module~solvers module~user_module user_module program~helmholtz_2d->module~user_module module~wavenumber wavenumber program~helmholtz_2d->module~wavenumber module~write_data write_data program~helmholtz_2d->module~write_data mpi mpi program~helmholtz_2d->mpi module~analytical_sol->module~comm_variable module~analytical_sol->mpi module~comm_variable->mpi module~define_grid->module~comm_variable module~define_grid->mpi module~define_rhs->module~comm_variable module~define_rhs->mpi module~idrs_module->module~comm_variable module~idrs_module->module~mpi_setup module~idrs_module->module~read_setup module~idrs_module->module~user_module module~idrs_module->mpi module~mpi_setup->module~comm_variable module~mpi_setup->mpi module~read_setup->module~comm_variable module~read_setup->mpi module~solvers->module~comm_variable module~solvers->module~read_setup module~solvers->mpi module~cslp_solver CSLP_Solver module~solvers->module~cslp_solver module~deflaion_setup deflaion_setup module~solvers->module~deflaion_setup module~operators operators module~solvers->module~operators module~user_module->module~comm_variable module~user_module->mpi module~user_module->module~cslp_solver module~user_module->module~deflaion_setup module~user_module->module~operators module~wavenumber->module~comm_variable module~wavenumber->module~mpi_setup module~wavenumber->mpi module~write_data->module~comm_variable module~write_data->mpi module~cslp_solver->module~comm_variable module~cslp_solver->module~mpi_setup module~cslp_solver->module~wavenumber module~cslp_solver->mpi module~cslp_solver->module~operators module~smoother smoother module~cslp_solver->module~smoother module~deflaion_setup->module~comm_variable module~deflaion_setup->module~mpi_setup module~deflaion_setup->module~wavenumber module~deflaion_setup->mpi module~deflaion_setup->module~cslp_solver module~deflaion_setup->module~operators module~operators->module~comm_variable module~operators->module~mpi_setup module~operators->module~wavenumber module~operators->mpi module~define_bc define_BC module~operators->module~define_bc module~define_bc->module~comm_variable module~define_bc->module~wavenumber module~smoother->module~comm_variable module~smoother->module~mpi_setup module~smoother->module~operators module~smoother->module~define_bc Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Parallel proconditioned Krylov slover for 2D Helmholtz equation Calls program~~helmholtz_2d~~CallsGraph program~helmholtz_2d helmholtz_2d interface~idrs IDRS program~helmholtz_2d->interface~idrs mpi_allreduce mpi_allreduce program~helmholtz_2d->mpi_allreduce mpi_barrier mpi_barrier program~helmholtz_2d->mpi_barrier mpi_comm_rank mpi_comm_rank program~helmholtz_2d->mpi_comm_rank mpi_comm_size mpi_comm_size program~helmholtz_2d->mpi_comm_size mpi_finalize mpi_finalize program~helmholtz_2d->mpi_finalize mpi_init mpi_init program~helmholtz_2d->mpi_init mpi_reduce mpi_reduce program~helmholtz_2d->mpi_reduce mpi_wtime mpi_wtime program~helmholtz_2d->mpi_wtime proc~const_k Const_K program~helmholtz_2d->proc~const_k proc~define_marmousi_grid define_marmousi_grid program~helmholtz_2d->proc~define_marmousi_grid proc~define_uniform_grid define_uniform_grid program~helmholtz_2d->proc~define_uniform_grid proc~define_wedge_grid define_wedge_grid program~helmholtz_2d->proc~define_wedge_grid proc~exact_2dcloseoff exact_2DCloseOff program~helmholtz_2d->proc~exact_2dcloseoff proc~exact_2dpointsource_1stsomer exact_2DPointSource_1stSomer program~helmholtz_2d->proc~exact_2dpointsource_1stsomer proc~exact_2dpointsource_dirichlet exact_2DPointSource_Dirichlet program~helmholtz_2d->proc~exact_2dpointsource_dirichlet proc~full_pgcr full_pgcr program~helmholtz_2d->proc~full_pgcr proc~full_pgmres full_pgmres program~helmholtz_2d->proc~full_pgmres proc~fullgmres fullgmres program~helmholtz_2d->proc~fullgmres proc~log2 LOG2 program~helmholtz_2d->proc~log2 proc~part2d part2d program~helmholtz_2d->proc~part2d proc~pfgmres pfgmres program~helmholtz_2d->proc~pfgmres proc~pre_fullgmres Pre_fullgmres program~helmholtz_2d->proc~pre_fullgmres proc~pre_restartgmres Pre_restartgmres program~helmholtz_2d->proc~pre_restartgmres proc~read_parameter read_parameter program~helmholtz_2d->proc~read_parameter proc~read_wavenumber_k_marmousi read_wavenumber_k_marmousi program~helmholtz_2d->proc~read_wavenumber_k_marmousi proc~restartgmres restartgmres program~helmholtz_2d->proc~restartgmres proc~rhs_2dcloseoff RHS_2DCloseOff program~helmholtz_2d->proc~rhs_2dcloseoff proc~rhs_2dwedge RHS_2DWedge program~helmholtz_2d->proc~rhs_2dwedge proc~rhs_centersource2d RHS_CenterSource2D program~helmholtz_2d->proc~rhs_centersource2d proc~rhs_marmousi RHS_marmousi program~helmholtz_2d->proc~rhs_marmousi proc~wavenumber_k_destroy wavenumber_k_destroy program~helmholtz_2d->proc~wavenumber_k_destroy proc~wavenumber_k_wedge wavenumber_k_Wedge program~helmholtz_2d->proc~wavenumber_k_wedge proc~write_data_whole write_data_whole program~helmholtz_2d->proc~write_data_whole proc~mg_checkreal_xy2d mg_checkreal_xy2d proc~const_k->proc~mg_checkreal_xy2d mpi_recv mpi_recv proc~define_marmousi_grid->mpi_recv mpi_send mpi_send proc~define_marmousi_grid->mpi_send proc~define_uniform_grid->mpi_recv proc~define_uniform_grid->mpi_send proc~define_wedge_grid->mpi_recv proc~define_wedge_grid->mpi_send dsin dsin proc~exact_2dcloseoff->dsin proc~dot_prod dot_prod proc~full_pgcr->proc~dot_prod proc~helmholtz2d_bc Helmholtz2d_BC proc~full_pgcr->proc~helmholtz2d_bc proc~norm norm proc~full_pgcr->proc~norm proc~precond_x Precond_x proc~full_pgcr->proc~precond_x proc~apply_givens_rotation apply_givens_rotation proc~full_pgmres->proc~apply_givens_rotation proc~back_substitute back_substitute proc~full_pgmres->proc~back_substitute proc~full_pgmres->proc~dot_prod proc~full_pgmres->proc~helmholtz2d_bc proc~full_pgmres->proc~norm proc~full_pgmres->proc~precond_x proc~fullgmres->proc~apply_givens_rotation proc~arnoldi arnoldi proc~fullgmres->proc~arnoldi proc~fullgmres->proc~back_substitute proc~fullgmres->proc~helmholtz2d_bc proc~fullgmres->proc~norm proc~part2d->mpi_barrier proc~my_mod1 my_mod1 proc~part2d->proc~my_mod1 proc~pfgmres->proc~apply_givens_rotation proc~pfgmres->proc~back_substitute proc~pfgmres->proc~dot_prod proc~pfgmres->proc~helmholtz2d_bc proc~pfgmres->proc~norm proc~pfgmres->proc~precond_x proc~pre_fullgmres->proc~apply_givens_rotation proc~pre_fullgmres->proc~back_substitute proc~pre_fullgmres->proc~helmholtz2d_bc proc~pre_fullgmres->proc~norm proc~prearnoldi Prearnoldi proc~pre_fullgmres->proc~prearnoldi proc~pre_fullgmres->proc~precond_x proc~pre_restartgmres->proc~apply_givens_rotation proc~pre_restartgmres->proc~back_substitute proc~pre_restartgmres->proc~helmholtz2d_bc proc~pre_restartgmres->proc~norm proc~pre_restartgmres->proc~prearnoldi proc~pre_restartgmres->proc~precond_x proc~read_parameter->mpi_barrier mpi_bcast mpi_bcast proc~read_parameter->mpi_bcast proc~read_wavenumber_k_marmousi->mpi_recv proc~read_wavenumber_k_marmousi->mpi_send proc~read_wavenumber_k_marmousi->proc~mg_checkreal_xy2d proc~restartgmres->proc~apply_givens_rotation proc~restartgmres->proc~arnoldi proc~restartgmres->proc~back_substitute proc~restartgmres->proc~helmholtz2d_bc proc~restartgmres->proc~norm proc~wavenumber_k_wedge->proc~mg_checkreal_xy2d proc~write_data_whole->mpi_recv proc~write_data_whole->mpi_send cdsqrt cdsqrt proc~apply_givens_rotation->cdsqrt proc~arnoldi->proc~dot_prod proc~arnoldi->proc~helmholtz2d_bc proc~arnoldi->proc~norm proc~dot_prod->mpi_allreduce proc~check_xy2d check_xy2d proc~helmholtz2d_bc->proc~check_xy2d proc~helmholtz2d_stencils Helmholtz2d_stencils proc~helmholtz2d_bc->proc~helmholtz2d_stencils proc~if_bcs if_BCs proc~helmholtz2d_bc->proc~if_bcs proc~mg_checkreal_x2d mg_checkreal_x2d proc~mg_checkreal_xy2d->proc~mg_checkreal_x2d proc~mg_checkreal_y2d mg_checkreal_y2d proc~mg_checkreal_xy2d->proc~mg_checkreal_y2d proc~norm->mpi_allreduce proc~prearnoldi->proc~dot_prod proc~prearnoldi->proc~helmholtz2d_bc proc~prearnoldi->proc~norm proc~prearnoldi->proc~precond_x proc~def_px DEF_Px proc~precond_x->proc~def_px proc~mgcslp_invmx MGCSLP_invMx proc~precond_x->proc~mgcslp_invmx proc~check_x2d check_x2d proc~check_xy2d->proc~check_x2d proc~check_y2d check_y2d proc~check_xy2d->proc~check_y2d proc~default_gridpara default_gridpara proc~def_px->proc~default_gridpara proc~multileveladp_px MultiLevelADP_Px proc~def_px->proc~multileveladp_px proc~p_adef1x P_ADEF1x proc~def_px->proc~p_adef1x proc~p_defx P_DEFx proc~def_px->proc~p_defx proc~p_tlkmx P_TLKMx proc~def_px->proc~p_tlkmx proc~dirichlet Dirichlet proc~if_bcs->proc~dirichlet proc~first_order_neum first_order_Neum proc~if_bcs->proc~first_order_neum mpi_sendrecv mpi_sendrecv proc~mg_checkreal_x2d->mpi_sendrecv proc~mg_checkreal_y2d->mpi_sendrecv proc~f_cycle F_cycle proc~mgcslp_invmx->proc~f_cycle proc~finestgrid_define finestgrid_define proc~mgcslp_invmx->proc~finestgrid_define proc~grid_destroy grid_destroy proc~mgcslp_invmx->proc~grid_destroy proc~v_cycle V_cycle proc~mgcslp_invmx->proc~v_cycle proc~check_x2d->mpi_sendrecv proc~check_y2d->mpi_sendrecv proc~f_cycle->proc~f_cycle proc~f_cycle->proc~grid_destroy proc~f_cycle->proc~v_cycle proc~coarsegrid_create coarsegrid_create proc~f_cycle->proc~coarsegrid_create proc~cslp_op_bc CSLP_OP_BC proc~f_cycle->proc~cslp_op_bc proc~damp_jacobi_smoother Damp_Jacobi_smoother proc~f_cycle->proc~damp_jacobi_smoother proc~mg_bicgstab mg_bicgstab proc~f_cycle->proc~mg_bicgstab proc~mg_fullgmres mg_fullgmres proc~f_cycle->proc~mg_fullgmres proc~prolongation_en_correct prolongation_en_correct proc~f_cycle->proc~prolongation_en_correct proc~restriction restriction proc~f_cycle->proc~restriction proc~multileveladp_px->proc~log2 proc~helm_ax_nth Helm_Ax_nth proc~multileveladp_px->proc~helm_ax_nth proc~krylovcslp_invmhx KrylovCSLP_invMHx proc~multileveladp_px->proc~krylovcslp_invmhx proc~mgcslp_invmhx MGCSLP_invMHx proc~multileveladp_px->proc~mgcslp_invmhx proc~multilevel_invey MultiLevel_invEy proc~multileveladp_px->proc~multilevel_invey proc~ztx ZTx proc~multileveladp_px->proc~ztx proc~zx Zx proc~multileveladp_px->proc~zx proc~p_adef1x->proc~mgcslp_invmx proc~helm_ahx Helm_Ahx proc~p_adef1x->proc~helm_ahx proc~qx Qx proc~p_adef1x->proc~qx proc~p_defx->proc~helm_ahx proc~p_defx->proc~qx proc~p_tlkmx->proc~mgcslp_invmx proc~p_tlkmx->proc~helm_ahx proc~p_tlkmx->proc~qx proc~v_cycle->proc~grid_destroy proc~v_cycle->proc~v_cycle proc~v_cycle->proc~coarsegrid_create proc~v_cycle->proc~cslp_op_bc proc~v_cycle->proc~damp_jacobi_smoother proc~v_cycle->proc~mg_bicgstab proc~v_cycle->proc~mg_fullgmres proc~v_cycle->proc~prolongation_en_correct proc~v_cycle->proc~restriction proc~cslp_op_bc->proc~if_bcs proc~cslp2d_stencils cslp2d_stencils proc~cslp_op_bc->proc~cslp2d_stencils proc~mg_check_xy2d mg_check_xy2d proc~cslp_op_bc->proc~mg_check_xy2d proc~damp_jacobi_smoother->proc~if_bcs proc~damp_jacobi_smoother->proc~cslp2d_stencils proc~damp_jacobi_smoother->proc~mg_check_xy2d proc~helmholtz2d_bc_mg Helmholtz2d_BC_mg proc~helm_ahx->proc~helmholtz2d_bc_mg proc~helm_ax_nth->proc~log2 proc~helm_ax_nth->proc~helmholtz2d_stencils proc~gridbase_extrpltghostbcs GridBase_ExtrpltGhostBCs proc~helm_ax_nth->proc~gridbase_extrpltghostbcs proc~helm_ax_nth_stencils Helm_Ax_nth_stencils proc~helm_ax_nth->proc~helm_ax_nth_stencils proc~helm_ax_nth->proc~mg_check_xy2d proc~krylovcslp_invmhx->proc~grid_destroy proc~gridsys_define gridsys_define proc~krylovcslp_invmhx->proc~gridsys_define proc~red_glk_cslp_gmres ReD_Glk_CSLP_gmres proc~krylovcslp_invmhx->proc~red_glk_cslp_gmres proc~mg_bicgstab->proc~cslp_op_bc proc~mg_dot_prod mg_dot_prod proc~mg_bicgstab->proc~mg_dot_prod proc~mg_norm mg_norm proc~mg_bicgstab->proc~mg_norm proc~mg_fullgmres->proc~cslp_op_bc proc~mg_apply_givens_rotation mg_apply_givens_rotation proc~mg_fullgmres->proc~mg_apply_givens_rotation proc~mg_arnoldi mg_arnoldi proc~mg_fullgmres->proc~mg_arnoldi proc~mg_back_substitute mg_back_substitute proc~mg_fullgmres->proc~mg_back_substitute proc~mg_fullgmres->proc~mg_norm proc~mgcslp_invmhx->proc~f_cycle proc~mgcslp_invmhx->proc~grid_destroy proc~mgcslp_invmhx->proc~v_cycle proc~mgcslp_invmhx->proc~gridsys_define proc~multilevel_invey->proc~log2 proc~def_prefgmres DEF_prefgmres proc~multilevel_invey->proc~def_prefgmres proc~prolongation_en_correct->proc~mg_check_xy2d proc~qx->proc~ztx proc~qx->proc~zx proc~invey invEy proc~qx->proc~invey proc~restriction->proc~mg_checkreal_xy2d proc~restriction->proc~mg_check_xy2d proc~ztx->proc~mg_check_xy2d proc~zx->proc~mg_check_xy2d proc~def_prefgmres->cdsqrt proc~def_prefgmres->proc~multileveladp_px proc~def_prefgmres->proc~helm_ax_nth proc~def_prefgmres->proc~krylovcslp_invmhx proc~def_prefgmres->proc~mg_dot_prod proc~def_prefgmres->proc~mg_norm proc~coarsegridpara CoarseGridpara proc~def_prefgmres->proc~coarsegridpara proc~helm_ax_nth_stencils->proc~log2 proc~helmholtz2d_bc_mg->proc~helmholtz2d_stencils proc~helmholtz2d_bc_mg->proc~if_bcs proc~helmholtz2d_bc_mg->proc~mg_check_xy2d proc~def_bicgstab DEF_bicgstab proc~invey->proc~def_bicgstab proc~def_fullgmres DEF_fullgmres proc~invey->proc~def_fullgmres proc~mg_apply_givens_rotation->cdsqrt proc~mg_arnoldi->proc~cslp_op_bc proc~mg_arnoldi->proc~mg_dot_prod proc~mg_arnoldi->proc~mg_norm proc~mg_check_x2d mg_check_x2d proc~mg_check_xy2d->proc~mg_check_x2d proc~mg_check_y2d mg_check_y2d proc~mg_check_xy2d->proc~mg_check_y2d proc~mg_dot_prod->mpi_allreduce proc~mg_norm->mpi_allreduce proc~red_glk_cslp_gmres->proc~log2 proc~red_glk_cslp_gmres->cdsqrt proc~red_glk_cslp_gmres->proc~mg_dot_prod proc~red_glk_cslp_gmres->proc~mg_norm proc~cslp_mx_nth CSLP_Mx_nth proc~red_glk_cslp_gmres->proc~cslp_mx_nth proc~cslp_mx_nth->proc~log2 proc~cslp_mx_nth->proc~cslp2d_stencils proc~cslp_mx_nth->proc~gridbase_extrpltghostbcs proc~cslp_mx_nth->proc~mg_check_xy2d proc~cslp_mx_nth_stencils CSLP_Mx_nth_stencils proc~cslp_mx_nth->proc~cslp_mx_nth_stencils proc~def_bicgstab->proc~mgcslp_invmhx proc~def_bicgstab->proc~mg_dot_prod proc~def_bicgstab->proc~mg_norm proc~def_bicgstab->proc~coarsegridpara proc~ex Ex proc~def_bicgstab->proc~ex proc~def_fullgmres->proc~mgcslp_invmhx proc~def_fullgmres->proc~mg_norm proc~def_fullgmres->proc~coarsegridpara proc~def_apply_givens_rotation def_apply_givens_rotation proc~def_fullgmres->proc~def_apply_givens_rotation proc~def_arnoldi def_arnoldi proc~def_fullgmres->proc~def_arnoldi proc~def_back_substitute def_back_substitute proc~def_fullgmres->proc~def_back_substitute proc~def_fullgmres->proc~ex proc~mg_check_x2d->mpi_sendrecv proc~mg_check_y2d->mpi_sendrecv proc~cslp_mx_nth_stencils->proc~log2 proc~def_apply_givens_rotation->cdsqrt proc~def_arnoldi->proc~mgcslp_invmhx proc~def_arnoldi->proc~mg_dot_prod proc~def_arnoldi->proc~mg_norm proc~def_arnoldi->proc~ex proc~ex->proc~helm_ahx proc~ex->proc~mgcslp_invmhx proc~ex->proc~ztx proc~ex->proc~zx proc~ex->proc~coarsegridpara proc~helm_a2hx Helm_A2hx proc~ex->proc~helm_a2hx proc~ztzx ZTZx proc~ex->proc~ztzx proc~helm_a2hx->proc~helmholtz2d_bc_mg proc~helmholtz2d_o4cmpct Helmholtz2d_O4cmpct proc~helm_a2hx->proc~helmholtz2d_o4cmpct proc~helmholtz2d_red_glk Helmholtz2d_ReD_Glk proc~helm_a2hx->proc~helmholtz2d_red_glk proc~ztzx->proc~ztx proc~ztzx->proc~zx proc~helmholtz2d_o4cmpct->proc~mg_check_xy2d proc~helmholtz2d_red_glk->proc~helmholtz2d_stencils proc~helmholtz2d_red_glk->proc~mg_check_xy2d proc~extrpltghostbcs ExtrpltGhostBCs proc~helmholtz2d_red_glk->proc~extrpltghostbcs proc~red_glk_stencils ReD_Glk_stencils proc~helmholtz2d_red_glk->proc~red_glk_stencils Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( matrix ) :: A An empty matrix type for calling idrs solver type( preconditioner ) :: M1 a preconditioner type for calling idrs solver. Since the IDR(s) solver part is ported, its input and output parameters are somewhat different from other solvers. complex(kind=realdp), allocatable, dimension(:,:) :: u arrays for the solution complex(kind=realdp), allocatable, dimension(:,:) :: u_ex arrays for exact solution complex(kind=realdp), allocatable, dimension(:,:) :: u_err arrays for the error of solution complex(kind=realdp), allocatable, dimension(:,:) :: b arrays for the right-hand side real(kind=realdp), allocatable, dimension(:,:) :: xx coordinates real(kind=realdp), allocatable, dimension(:,:) :: yy coordinates real(kind=realdp), allocatable :: resvec (:) Residual vector for idrs solver real(kind=realdp) :: time_start time_start: variable for runtime measurement start real(kind=realdp) :: time_end time_end: variable for runtime measurement end real(kind=realdp) :: u_err_max u_err_max: local max|u_err|=max|u-u_ex| real(kind=realdp) :: Aerror Aerror: global max|u_err|=max|u-u_ex| real(kind=realdp) :: Rerror Rerror: relative residual ||b-Au||/||b|| real(kind=realdp) :: max_k_local max_k_local: local maximum wavenumber real(kind=realdp) :: max_k_global max_k_global: global maximum wavenumber integer :: iter number of iterations and loop indexs integer :: k number of iterations and loop indexs integer :: i number of iterations and loop indexs integer :: j number of iterations and loop indexs integer :: flag an output flag for idrs solvers","tags":"","loc":"program/helmholtz_2d.html"},{"title":"comm_variable.f90 – ParaMADP","text":"Files dependent on this one sourcefile~~comm_variable.f90~~AfferentGraph sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~analytical_sol.f90 analytical_sol.f90 sourcefile~analytical_sol.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~definegrid.f90 DefineGrid.f90 sourcefile~definegrid.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~comm_variable.f90 sourcefile~idrs_module.f90->sourcefile~mpi_setup.f90 sourcefile~read_setup.f90 read_setup.f90 sourcefile~idrs_module.f90->sourcefile~read_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~comm_variable.f90 sourcefile~main.f90->sourcefile~analytical_sol.f90 sourcefile~main.f90->sourcefile~definegrid.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 sourcefile~main.f90->sourcefile~mpi_setup.f90 sourcefile~main.f90->sourcefile~read_setup.f90 sourcefile~rhs.f90 RHS.f90 sourcefile~main.f90->sourcefile~rhs.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~wavenumber.f90 sourcefile~write_data.f90 Write_data.f90 sourcefile~main.f90->sourcefile~write_data.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~read_setup.f90->sourcefile~comm_variable.f90 sourcefile~rhs.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~solvers.f90->sourcefile~comm_variable.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~solvers.f90->sourcefile~read_setup.f90 sourcefile~user_module.f90->sourcefile~comm_variable.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~write_data.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module comm_variable !! This is a module that define some common variables for the whole project use mpi implicit none !=====================math parameter=================== integer , parameter :: realdp = 8 !! precision for the whole program real ( kind = realdp ), parameter :: pi = 3.141592653589793238d0 real ( kind = realdp ), parameter :: e = 2.7182818285d0 !========= program parameter================= integer , parameter :: npMax = 400 !! the maximun number of partitions in one dimension complex ( kind = realdp ), parameter :: cone = ( 0.d0 , 1.d0 ) complex ( kind = realdp ), parameter :: czero = ( 0.d0 , 0.d0 ) !! Constants for complex numbers character ( len = 100 ) :: filename character ( len = 100 ) :: output_name character ( len = 100 ) :: logname !! Strings for file names !=========solver parameter================ real ( kind = realdp ) :: eps !! eps: tolerance for the outer iterations real ( kind = realdp ) :: def_rtol !! def_rtol: tolerance for the coarse-grid solver in two-level deflation method real ( kind = realdp ) :: cslp_mg_tol !! cslp_mg_tol: tolerance for Krylov based CSLP solver on coarse-grid levels integer :: m_iter !! m_iter: maximum number of outer iterations integer :: Algorithm !! Algorithm: solver identifier integer :: Irestart !! Irestart: Restart GMRES (1) or full GMRES (0) integer :: M_flag !! M_flag: Flag for preconditioner type integer :: M2h_flag !! M2h_flag: In two-level deflation method, flag for using CSLP for the coarse level (1) or not (0) integer :: A2h_flag !! A2h_flag: In two-level deflation method, flag for the ReD method used for the coarse level operator integer :: def_mg_miter !! def_mg_miter: maximum number of iterations for deflation on the coarse levels integer :: cslp_mg_miter !! cslp_mg_miter: maximum number of iterations for solving CSLP by multigrid method on the coarsest level integer :: MG_flag !! MG_flag: flag for the type of multigrid method integer :: nx_min !! nx_min: minimum number of grid points in x-direction for the coarsest grid, it is used to specified the grid size of the coarsest grid when coarsening integer :: def_nlevel !! def_nlevel: Number of levels in multilevel deflation method integer :: indf_level !! indf_level: The level that the linear system becomes indefinite integer :: Sv_L2 !! Sv_L2: In multilevel method, a single-digit number that sets the tolerance for the second coarse grid iterations, ex. 1 means 1E-1 integer :: Sv_L3 !! Sv_L3: In multilevel method, a single-digit number that sets the tolerance for the third coarse grid iterations, ex. 3 means 3E-1 integer :: Sv_L4 !! Sv_L4: In multilevel method, a single-digit number that sets the tolerance for the fourth coarse grid iterations, ex. 10 means one iteration integer :: npx0 !! npx0: Number of partitions in x-direction integer :: npy0 !! npy0: Number of partitions in y-direction integer :: npx !! npx: The coordinate/order of the current partition in x-direction integer :: npy !! npy: The coordinate/order of the current partition in y-direction integer :: nx_global !! nx_global: Global number of grid points in x-direction integer :: ny_global !! ny_global: Global number of grid points in y-direction integer :: nx !! nx: Local number of grid points of the current subdomain in x-direction integer :: ny !! ny: Local number of grid points of the current subdomain in y-direction integer :: ID_XM1 !! ID_XM1: Identifier for neighboring partition in the -x direction integer :: ID_XP1 !! ID_XP1: Identifier for neighboring partition in the +x direction integer :: ID_YM1 !! ID_YM1: Identifier for neighboring partition in the -y direction integer :: ID_YP1 !! ID_YP1: Identifier for neighboring partition in the +y direction integer :: Iperiodic_X !! Iperiodic_X: Periodicity flag in x-direction integer :: Iperiodic_Y !! Iperiodic_Y: Periodicity flag in y-direction real ( kind = realdp ) :: slx !! slx: Physical length of the computational domain in x direction real ( kind = realdp ) :: sly !! sly: Physical length of the computational domain in y direction real ( kind = realdp ) :: hx !! hx: Grid spacing in x-direction real ( kind = realdp ) :: hy !! hy: Grid spacing in y-direction real ( kind = realdp ) :: hxhy !! hxhy: Product of grid spacings hx * hy, for this project hx must equal to hy, so hxhy=h&#94;2 integer , dimension ( 0 : npMax - 1 ) :: i_offset !! i_offset: an array that contains the index offset for MPI ranks in x direction integer , dimension ( 0 : npMax - 1 ) :: j_offset !! j_offset: an array that contains the index offset for MPI ranks in y direction integer , dimension ( 0 : npMax - 1 ) :: i_nn !! i_nn: an array that contains the number of grid points for MPI ranks in x direction integer , dimension ( 0 : npMax - 1 ) :: j_nn !! j_nn: an array that contains the number of grid points for MPI ranks in y direction integer :: LAP !! The number of overlapping layers. The higher order deflation will be turned on once LAP > 1 integer :: i_case !! Case identifier real ( kind = realdp ) :: freq !! freq: the frequency for Helmholtz problem real ( kind = realdp ) :: k0 !! k0: the wavenumber for constant-wavenumber model problem real ( kind = realdp ) :: beta1 !! beta1: the real term for CSLP, usually 1.d0 real ( kind = realdp ) :: beta2 !! beta2: the complex shift for CSLP integer :: k_case !! k_case: Case identifier for constant (0) or non-constant (1) wavenumber integer :: flag_BCs !! flag_BCs: Boundary conditions flag integer :: ierr !! ierr: MPI error code integer :: np_size !! np_size: the total number of MPI processes integer :: my_id !! my_id: MPI rank ID integer :: STATUS ( MPI_STATUS_SIZE ), request1 , request2 !! MPI status array type , public :: Gridpara !! Type definition for grid parameters integer ( kind = 4 ) :: nx_global , ny_global integer ( kind = 4 ) :: nx , ny real ( kind = realdp ) :: hx , hy , hxhy integer , dimension ( 0 : npMax - 1 ) :: i_offset , j_offset , i_nn , j_nn real ( kind = realdp ), allocatable , dimension (:,:) :: wavenumber_k !! wavenumber_k: the wavenumber profile of the domain real ( kind = realdp ), allocatable , dimension (:,:) :: wavenumber_kh_pow_2 !! wavenumber_kh_pow_2 = (kh)&#94;2 end type Gridpara end module comm_variable","tags":"","loc":"sourcefile/comm_variable.f90.html"},{"title":"user_module.f90 – ParaMADP","text":"This file depends on sourcefile~~user_module.f90~~EfferentGraph sourcefile~user_module.f90 user_module.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~user_module.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~user_module.f90~~AfferentGraph sourcefile~user_module.f90 user_module.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module user_module !! A module for IDR(s) to make data type and operators compatible use mpi use comm_variable use operators use CSLP_Solver use deflaion_setup !use preconditioned implicit none type matrix !! This is an empty matrix type end type matrix ! Overload * to define the matrix-vector multiplication using the matrix type INTERFACE OPERATOR ( * ) module procedure rmatvec , cmatvec END INTERFACE ! Define the preconditioner type type preconditioner integer :: ni , nj real ( kind = realdp ) :: hx_c , hy_c end type preconditioner ! Overload / to define the preconditioner operation using the preconditioner type INTERFACE OPERATOR ( / ) module procedure rprecon , cprecon END INTERFACE contains function rmatvec ( A , v ) !! This is an empty matrix-vector multiplication for real-type input v type ( matrix ), intent ( in ) :: A real ( kind = realdp ), intent ( in ) :: v (:,:) real ( kind = realdp ) :: w ( size ( v , 1 ), size ( v , 2 )) real ( kind = realdp ) :: rmatvec ( size ( v , 1 ), size ( v , 2 )) w = v rmatvec = w end function rmatvec function cmatvec ( A , v ) !! This is complex matrix-vector multiplication type ( matrix ), intent ( in ) :: A complex ( kind = realdp ), intent ( in ) :: v (:,:) complex ( kind = realdp ) :: w ( size ( v , 1 ), size ( v , 2 )) complex ( kind = realdp ) :: v_tmp ( size ( v , 1 ), size ( v , 2 )) complex ( kind = realdp ) :: cmatvec ( size ( v , 1 ), size ( v , 2 )) v_tmp = v call Helmholtz2d_BC ( v_tmp , w ) cmatvec = w end function cmatvec function rprecon ( v , M1 ) !! This is an empty preconditioner for real-type input v implicit none type ( preconditioner ), intent ( in ) :: M1 real ( kind = realdp ), dimension (:,:), intent ( in ) :: v real ( kind = realdp ), dimension ( size ( v , 1 ), size ( v , 2 )) :: rprecon rprecon = v end function rprecon function cprecon ( v , M1 ) !! This is an preconditioner for complex-type input v, i.e. M1&#94;(-1)v !! We can manully call different preconditioners here. Here only use multigrid-based CLSP type ( preconditioner ), intent ( in ) :: M1 complex ( kind = realdp ), intent ( in ) :: v (:,:) complex ( kind = realdp ) :: w ( size ( v , 1 ), size ( v , 2 )) complex ( kind = realdp ) :: cprecon ( size ( v , 1 ), size ( v , 2 )) w = v cprecon = MGCSLP_invMx ( w ) end function cprecon end module user_module","tags":"","loc":"sourcefile/user_module.f90.html"},{"title":"Operators.f90 – ParaMADP","text":"This file depends on sourcefile~~operators.f90~~EfferentGraph sourcefile~operators.f90 Operators.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~operators.f90~~AfferentGraph sourcefile~operators.f90 Operators.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module operators !! This is a module to implement some matrix-free operations use mpi use comm_variable use mpi_setup use wavenumber use define_BC implicit none contains ! FUNCTION NORM ===================================================================== real ( kind = realdp ) function norm ( v ) !! Compute the L2-norm of a complex variable, ONLY for the default grid system. ! Note that the dimension is not specified here, it means it calculate all the elements !  without exception. Thus, we must be careful about the input range of the vector v, as !  it was extended to (1-LAP:nx+LAP) implicit none real ( kind = realdp ) :: norm_local complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: v integer :: j norm_local = 0.d0 do j = 1 , ny norm_local = norm_local + real ( dot_product ( v ( 1 : nx , j ), v ( 1 : nx , j ))) enddo call MPI_Allreduce ( norm_local , & norm , & 1 , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) norm = dsqrt ( norm ) return end function norm real ( kind = realdp ) function Realnorm ( v ) !! Compute the L2-norm of a real variable, ONLY for the default grid system. ! Note that the dimension is not specified here, it means it calculate all the elements !  without exception. Thus, we must be careful about the input range of the vector v, as !  it was extended to (1-LAP:nx+LAP) implicit none real ( kind = realdp ) :: norm_local real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: v integer :: j norm_local = 0.d0 do j = 1 , ny norm_local = norm_local + dot_product ( v ( 1 : nx , j ), v ( 1 : nx , j )) enddo call MPI_Allreduce ( norm_local , & Realnorm , & 1 , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) Realnorm = dsqrt ( Realnorm ) return end function Realnorm ! FUNCTION DOT_PROD ================================================================= complex ( kind = realdp ) function dot_prod ( v , w ) !! Compute the do product of two complex variables, ONLY for the default grid system. ! Note that the dimension is not specified here, it means it calculate all the elements !  without exception. Thus, we must be careful about the input range of the vector v, as !  it was extended to (1-LAP:nx+LAP) implicit none complex ( kind = realdp ) :: dot_prod_local complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: v , w integer :: j dot_prod_local = czero dot_prod = czero do j = 1 , ny dot_prod_local = dot_prod_local + dot_product ( v ( 1 : nx , j ), w ( 1 : nx , j )) enddo call MPI_Allreduce ( dot_prod_local , & dot_prod , & 1 , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) return end function dot_prod ! FUNCTION NORM ===================================================================== real ( kind = realdp ) function mg_norm ( v , ni , nj ) !! Compute the L2-norm of a complex variable, for a coarse-grid system. ! Note that the dimension is not specified here, it means it calculate all the elements !  without exception. Thus, we must be careful about the input range of the vector v, as !  it was extended to (1-LAP:ni+LAP) implicit none integer , intent ( in ) :: ni , nj !! ni, nj: grid size of the subdomain on the current coarse grid level complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: v real ( kind = realdp ) :: norm_local integer :: j norm_local = 0.d0 do j = 1 , nj norm_local = norm_local + real ( dot_product ( v ( 1 : ni , j ), v ( 1 : ni , j ))) enddo call MPI_Allreduce ( norm_local , & mg_norm , & 1 , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) mg_norm = dsqrt ( mg_norm ) return end function mg_norm ! FUNCTION DOT_PROD ================================================================= complex ( kind = realdp ) function mg_dot_prod ( v , w , ni , nj ) !! Compute the dot product of two complex variables, for a coarse-grid system. !! Note that the dimension is not specified here, it means it calculate all the elements !  without exception. Thus, we must be careful about the input range of the vector v, as !  it was extended to (1-LAP:ni+LAP) implicit none integer , intent ( in ) :: ni , nj !! ni, nj: grid size of the subdomain on the current coarse grid level complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: v , w complex ( kind = realdp ) :: dot_prod_local integer :: j dot_prod_local = czero mg_dot_prod = czero do j = 1 , nj dot_prod_local = dot_prod_local + dot_product ( v ( 1 : ni , j ), w ( 1 : ni , j )) enddo call MPI_Allreduce ( dot_prod_local , & mg_dot_prod , & 1 , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) return end function mg_dot_prod !============================================================================================================= real ( kind = realdp ) function LOG2 ( x ) !! Compute log2(x) implicit none real ( kind = realdp ), intent ( in ) :: x LOG2 = log ( x ) / log ( 2.d0 ) end function LOG2 !============================================================================================================= !==                                             Linear operators                                            == !============================================================================================================= subroutine Helmholtz2d_stencils ( ap , an , as , aw , ae , hxhykxy2 ) !! Computational stencils for the Helmholtz operator, second-order central FD scheme implicit none complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as real ( kind = realdp ), intent ( in ) :: hxhykxy2 !! The value of (kh)&#94;2, which is computed and stored in advance. ap = 4.d0 - hxhykxy2 + czero ae = - 1.d0 aw = - 1.d0 an = - 1.d0 as = - 1.d0 end subroutine Helmholtz2d_stencils subroutine cslp2d_stencils ( ap , an , as , aw , ae , hxhykxy2 ) !! Computational stencils for the CSLP operator implicit none complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as real ( kind = realdp ), intent ( in ) :: hxhykxy2 !! The value of (kh)&#94;2, which is computed and stored in advance ap = 4.d0 - ( beta1 - beta2 * cone ) * hxhykxy2 ae = - 1.d0 aw = - 1.d0 an = - 1.d0 as = - 1.d0 end subroutine cslp2d_stencils subroutine Helmholtz2d_BC ( v_in , v_out ) !! matrix-free Helmholtz operator, ONLY for the default gird system !! First deal with the boundary grid points and then the internals implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: v_in complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: v_out integer :: i , j real ( kind = realdp ) :: ae , aw , an , as complex ( kind = realdp ) :: ap v_out = czero call check_xy2d ( v_in ) j = 1 do i = 1 , nx call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , nx , ny , hx , hy , wavenumber_k ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo j = ny do i = 1 , nx call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , nx , ny , hx , hy , wavenumber_k ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = 1 do j = 2 , ny - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , nx , ny , hx , hy , wavenumber_k ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = nx do j = 2 , ny - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , nx , ny , hx , hy , wavenumber_k ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo if ( flag_BCs == 1 ) then do j = 2 , ny - 1 do i = 2 , nx - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , nx , ny , hx , hy , wavenumber_k ( i , j )) !Actually no need anymore !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo elseif ( flag_BCs == 2 ) then do j = 2 , ny - 1 do i = 2 , nx - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh_pow_2 ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo endif v_out = v_out / hxhy end subroutine Helmholtz2d_BC subroutine Helmholtz2d_BC_mg ( v_in , v_out , ni , nj , hx_c , hy_c , kxy , kh2 ) !! matrix-free Helmholtz operator, for the specified coarse gird systems implicit none integer , intent ( in ) :: ni , nj real ( kind = realdp ), intent ( in ) :: hx_c , hy_c real ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: kxy , kh2 complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( inout ) :: v_in complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( inout ) :: v_out real ( kind = realdp ) :: hxhy_c real ( kind = realdp ) :: ae , aw , an , as integer :: i , j complex ( kind = realdp ) :: ap if ( hx_c /= hy_c ) then write ( * , * ) \"careful, hx not equals to hy, in helmholtzOP\" endif hxhy_c = hx_c * hy_c v_out = czero call mg_check_xy2d ( v_in , ni , nj ) j = 1 do i = 1 , ni call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo j = nj do i = 1 , ni call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = 1 do j = 2 , nj - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = ni do j = 2 , nj - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo if ( flag_BCs == 1 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo elseif ( flag_BCs == 2 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call Helmholtz2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo endif v_out = v_out / hxhy_c end subroutine Helmholtz2d_BC_mg subroutine CSLP_OP_BC ( v_in , v_out , ni , nj , hx_c , hy_c , kxy , kh2 ) !! matrix-free CSLP operator, for the specified gird systems implicit none integer , intent ( in ) :: ni , nj !! ni,nj: grid size of subdomain on the current grid level real ( kind = realdp ), intent ( in ) :: hx_c , hy_c !! hx_c,hy_c: space step of subdomain on the current grid level real ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: kxy , kh2 !! kxy: wavenumber profile of subdomain on the current grid level,kh2=(kh)&#94;2 complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( inout ) :: v_in complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( inout ) :: v_out complex ( kind = realdp ) :: ap real ( kind = realdp ) :: hxhy_c real ( kind = realdp ) :: ae , aw , an , as integer :: i , j if ( hx_c /= hy_c ) then write ( * , * ) \"careful, hx not equals to hy, in CSLP op\" endif hxhy_c = hx_c * hy_c v_out = czero call mg_check_xy2d ( v_in , ni , nj ) j = 1 do i = 1 , ni call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo j = nj do i = 1 , ni call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = 1 do j = 2 , nj - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo i = ni do j = 2 , nj - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo if ( flag_BCs == 1 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo elseif ( flag_BCs == 2 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo enddo endif v_out = v_out / hxhy_c end subroutine CSLP_OP_BC function Helm_Ax_nth ( v_in , grid ) !! *ReD-Glk* Helmholtz operator for coarse levels implicit none type ( Gridpara ), intent ( inout ) :: grid !! Parameters of the current grid system complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) complex ( kind = realdp ) :: Helm_Ax_nth ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) real ( kind = realdp ) :: ae , aw , an , as complex ( kind = realdp ) :: ap , coefA ( - 3 : 3 , - 3 : 3 ) !! computational stencils integer :: i , j , ia , ja integer ( kind = 4 ) :: level_i level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 Helm_Ax_nth = czero v_in ( 1 - LAP : 0 ,:) = czero v_in (:, 1 - LAP : 0 ) = czero v_in ( grid % nx + 1 : grid % nx + LAP ,:) = czero v_in (:, grid % ny + 1 : grid % ny + LAP ) = czero call mg_check_xy2d ( v_in , grid % nx , grid % ny ) call GridBase_ExtrpltGhostBCs ( v_in , grid ) do j = 1 , grid % ny do i = 1 , grid % nx call Helm_Ax_nth_stencils ( coefA , grid , i , j ) do ja =- 3 , 3 do ia =- 3 , 3 Helm_Ax_nth ( i , j ) = Helm_Ax_nth ( i , j ) + coefA ( ia , ja ) * v_in ( i + ia , j + ja ) enddo enddo enddo enddo if ( flag_BCs == 1 ) then if ( npy == 0 ) then Helm_Ax_nth (:, 1 ) = v_in (:, 1 ) * grid % hxhy endif if ( npy == npy0 - 1 ) then Helm_Ax_nth (:, grid % ny ) = v_in (:, grid % ny ) * grid % hxhy endif if ( npx == 0 ) then Helm_Ax_nth ( 1 ,:) = v_in ( 1 ,:) * grid % hxhy endif if ( npx == npx0 - 1 ) then Helm_Ax_nth ( grid % nx ,:) = v_in ( grid % nx ,:) * grid % hxhy endif elseif ( flag_BCs == 2 ) then if ( npy == 0 ) then j = 1 do i = 1 , grid % nx call Helmholtz2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== Helm_Ax_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npy == npy0 - 1 ) then j = grid % ny do i = 1 , grid % nx call Helmholtz2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== Helm_Ax_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == 0 ) then i = 1 do j = 1 , grid % ny call Helmholtz2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== Helm_Ax_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == npx0 - 1 ) then i = grid % nx do j = 1 , grid % ny call Helmholtz2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== Helm_Ax_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif endif Helm_Ax_nth = Helm_Ax_nth / grid % hxhy end function Helm_Ax_nth function CSLP_Mx_nth ( v_in , grid ) !! *ReD-Glk* CSLP operator for coarse levels implicit none type ( Gridpara ), intent ( inout ) :: grid complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) complex ( kind = realdp ) :: CSLP_Mx_nth ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) real ( kind = realdp ) :: ae , aw , an , as complex ( kind = realdp ) :: ap , coefA ( - 3 : 3 , - 3 : 3 ) integer :: i , j , ia , ja integer ( kind = 4 ) :: level_i level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 CSLP_Mx_nth = czero v_in ( 1 - LAP : 0 ,:) = czero v_in (:, 1 - LAP : 0 ) = czero v_in ( grid % nx + 1 : grid % nx + LAP ,:) = czero v_in (:, grid % ny + 1 : grid % ny + LAP ) = czero call mg_check_xy2d ( v_in , grid % nx , grid % ny ) call GridBase_ExtrpltGhostBCs ( v_in , grid ) do j = 1 , grid % ny do i = 1 , grid % nx call CSLP_Mx_nth_stencils ( coefA , grid , i , j ) do ja =- 3 , 3 do ia =- 3 , 3 CSLP_Mx_nth ( i , j ) = CSLP_Mx_nth ( i , j ) + coefA ( ia , ja ) * v_in ( i + ia , j + ja ) enddo enddo enddo enddo if ( flag_BCs == 1 ) then if ( npy == 0 ) then CSLP_Mx_nth (:, 1 ) = v_in (:, 1 ) * grid % hxhy endif if ( npy == npy0 - 1 ) then CSLP_Mx_nth (:, grid % ny ) = v_in (:, grid % ny ) * grid % hxhy endif if ( npx == 0 ) then CSLP_Mx_nth ( 1 ,:) = v_in ( 1 ,:) * grid % hxhy endif if ( npx == npx0 - 1 ) then CSLP_Mx_nth ( grid % nx ,:) = v_in ( grid % nx ,:) * grid % hxhy endif elseif ( flag_BCs == 2 ) then if ( npy == 0 ) then j = 1 do i = 1 , grid % nx call cslp2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== CSLP_Mx_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npy == npy0 - 1 ) then j = grid % ny do i = 1 , grid % nx call cslp2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== CSLP_Mx_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == 0 ) then i = 1 do j = 1 , grid % ny call cslp2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== CSLP_Mx_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == npx0 - 1 ) then i = grid % nx do j = 1 , grid % ny call cslp2d_stencils ( ap , an , as , aw , ae , grid % wavenumber_kh_pow_2 ( i , j )) !============================== CSLP_Mx_nth ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif endif CSLP_Mx_nth = CSLP_Mx_nth / grid % hxhy end function CSLP_Mx_nth subroutine GridBase_ExtrpltGhostBCs ( v_in , grid ) !! Extrapolation of a layer of ghost grid points implicit none type ( Gridpara ), intent ( inout ) :: grid complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) integer :: i , j if ( flag_BCs == 1 ) then if ( npx == 0 ) then do j = 1 - LAP , grid % ny + LAP v_in ( 0 , j ) = 2.d0 * v_in ( 1 , j ) - v_in ( 2 , j ) grid % wavenumber_k ( 0 , j ) = 2.d0 * grid % wavenumber_k ( 1 , j ) - grid % wavenumber_k ( 2 , j ) grid % wavenumber_kh_pow_2 ( 0 , j ) = grid % wavenumber_k ( 0 , j ) * grid % hxhy enddo endif if ( npx == npx0 - 1 ) then do j = 1 - LAP , grid % ny + LAP v_in ( grid % nx + 1 , j ) = 2.d0 * v_in ( grid % nx , j ) - v_in ( grid % nx - 1 , j ) grid % wavenumber_k ( grid % nx + 1 , j ) = 2.d0 * grid % wavenumber_k ( grid % nx , j ) - grid % wavenumber_k ( grid % nx - 1 , j ) grid % wavenumber_kh_pow_2 ( grid % nx + 1 , j ) = grid % wavenumber_k ( grid % nx + 1 , j ) * grid % hxhy enddo endif if ( npy == 0 ) then do i = 1 - LAP , grid % nx + LAP v_in ( i , 0 ) = 2.d0 * v_in ( i , 1 ) - v_in ( i , 2 ) grid % wavenumber_k ( i , 0 ) = 2.d0 * grid % wavenumber_k ( i , 1 ) - grid % wavenumber_k ( i , 2 ) grid % wavenumber_kh_pow_2 ( i , 0 ) = grid % wavenumber_k ( i , 0 ) * grid % hxhy enddo endif if ( npy == npy0 - 1 ) then do i = 1 - LAP , grid % nx + LAP v_in ( i , grid % ny + 1 ) = 2.d0 * v_in ( i , grid % ny ) - v_in ( i , grid % ny - 1 ) grid % wavenumber_k ( i , grid % ny + 1 ) = 2.d0 * grid % wavenumber_k ( i , grid % ny ) - grid % wavenumber_k ( i , grid % ny - 1 ) grid % wavenumber_kh_pow_2 ( i , grid % ny + 1 ) = grid % wavenumber_k ( i , grid % ny + 1 ) * grid % hxhy enddo endif !=THE CORNER= if ( npx == 0 . and . npy == 0 ) then v_in ( 0 , 0 ) = 4.d0 * v_in ( 1 , 1 ) - v_in ( 2 , 2 ) - v_in ( 0 , 2 ) - v_in ( 2 , 0 ) grid % wavenumber_k ( 0 , 0 ) = 4.d0 * grid % wavenumber_k ( 1 , 1 ) - grid % wavenumber_k ( 2 , 2 ) - grid % wavenumber_k ( 0 , 2 ) - grid % wavenumber_k ( 2 , 0 ) grid % wavenumber_kh_pow_2 ( 0 , 0 ) = grid % wavenumber_k ( 0 , 0 ) * grid % hxhy endif if ( npx == 0 . and . npy == npy0 - 1 ) then v_in ( 0 , grid % ny + 1 ) = 4.d0 * v_in ( 1 , grid % ny ) - v_in ( 2 , grid % ny - 1 ) - v_in ( 2 , grid % ny + 1 ) - v_in ( 0 , grid % ny - 1 ) grid % wavenumber_k ( 0 , grid % ny + 1 ) = 4.d0 * grid % wavenumber_k ( 1 , grid % ny ) - grid % wavenumber_k ( 2 , grid % ny - 1 ) & - grid % wavenumber_k ( 2 , grid % ny + 1 ) - grid % wavenumber_k ( 0 , grid % ny - 1 ) grid % wavenumber_kh_pow_2 ( 0 , grid % ny + 1 ) = grid % wavenumber_k ( 0 , grid % ny + 1 ) * grid % hxhy endif if ( npx == npx0 - 1 . and . npy == 0 ) then v_in ( grid % nx + 1 , 0 ) = 4.d0 * v_in ( grid % nx , 1 ) - v_in ( grid % nx - 1 , 2 ) - v_in ( grid % nx - 1 , 0 ) - v_in ( grid % nx + 1 , 2 ) grid % wavenumber_k ( grid % nx + 1 , 0 ) = 4.d0 * grid % wavenumber_k ( grid % nx , 1 ) - grid % wavenumber_k ( grid % nx - 1 , 2 ) & - grid % wavenumber_k ( grid % nx - 1 , 0 ) - grid % wavenumber_k ( grid % nx + 1 , 2 ) grid % wavenumber_kh_pow_2 ( grid % nx + 1 , 0 ) = grid % wavenumber_k ( grid % nx + 1 , 0 ) * grid % hxhy endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then v_in ( grid % nx + 1 , grid % ny + 1 ) = 4.d0 * v_in ( grid % nx , grid % ny ) - v_in ( grid % nx - 1 , grid % ny - 1 ) & - v_in ( grid % nx - 1 , grid % ny + 1 ) - v_in ( grid % nx + 1 , grid % ny - 1 ) grid % wavenumber_k ( grid % nx + 1 , grid % ny + 1 ) = 4.d0 * grid % wavenumber_k ( grid % nx , grid % ny ) - grid % wavenumber_k ( grid % nx - 1 , grid % ny - 1 ) & - grid % wavenumber_k ( grid % nx - 1 , grid % ny + 1 ) - grid % wavenumber_k ( grid % nx + 1 , grid % ny - 1 ) grid % wavenumber_kh_pow_2 ( grid % nx + 1 , grid % ny + 1 ) = grid % wavenumber_k ( grid % nx + 1 , grid % ny + 1 ) * grid % hxhy endif elseif ( flag_BCs == 2 ) then if ( npx == 0 ) then do j = 1 - LAP , grid % ny + LAP v_in ( 0 , j ) = 2.d0 * cone * grid % wavenumber_k ( 1 , j ) * grid % hx * v_in ( 1 , j ) + v_in ( 2 , j ) grid % wavenumber_k ( 0 , j ) = 0.d0 grid % wavenumber_kh_pow_2 ( 0 , j ) = grid % wavenumber_k ( 0 , j ) * grid % hxhy enddo endif if ( npx == npx0 - 1 ) then do j = 1 - LAP , grid % ny + LAP v_in ( grid % nx + 1 , j ) = 2.d0 * cone * grid % wavenumber_k ( grid % nx , j ) * grid % hx * & v_in ( grid % nx , j ) + v_in ( grid % nx - 1 , j ) grid % wavenumber_k ( grid % nx + 1 , j ) = 0.d0 grid % wavenumber_kh_pow_2 ( grid % nx + 1 , j ) = grid % wavenumber_k ( grid % nx + 1 , j ) * grid % hxhy enddo endif if ( npy == 0 ) then do i = 1 - LAP , grid % nx + LAP v_in ( i , 0 ) = 2.d0 * cone * grid % wavenumber_k ( i , 1 ) * grid % hy * v_in ( i , 1 ) + v_in ( i , 2 ) grid % wavenumber_k ( i , 0 ) = 0.d0 grid % wavenumber_kh_pow_2 ( i , 0 ) = grid % wavenumber_k ( i , 0 ) * grid % hxhy ! !!Another Ghost point seems no gains enddo endif if ( npy == npy0 - 1 ) then do i = 1 - LAP , grid % nx + LAP v_in ( i , grid % ny + 1 ) = 2.d0 * cone * grid % wavenumber_k ( i , grid % ny ) * grid % hy * & v_in ( i , grid % ny ) + v_in ( i , grid % ny - 1 ) grid % wavenumber_k ( i , grid % ny + 1 ) = 0.d0 grid % wavenumber_kh_pow_2 ( i , grid % ny + 1 ) = grid % wavenumber_k ( i , grid % ny + 1 ) * grid % hxhy enddo endif !=THE CORNER= if ( npx == 0 . and . npy == 0 ) then !   (-1, 3)--(0, 3)-|-(1, 3)--(2, 3)--(3, 3) !      |        |   |    |       |       | !   (-1, 2)--(0, 2)-|-(1, 2)--(2, 2)--(3, 2) !      |        |   |    |       |       | !   (-1, 1)--(0, 1)-|-(1, 1)--(2, 1)--(3, 1) !    __|________|___|____|_______|_______|__ !   (-1, 0)--(0, 0)-|-(1, 0)--(2, 0)--(3, 0) !      |        |   |    |       |       | !   (-1,-1)--(0,-1)-|-(1,-1)--(2,-1)--(3,-1) v_in ( 0 , 0 ) = (( 2.d0 * cone * grid % wavenumber_k ( 1 , 0 ) * grid % hx * v_in ( 1 , 0 ) + v_in ( 2 , 0 )) & + ( 2.d0 * cone * grid % wavenumber_k ( 0 , 1 ) * grid % hy * v_in ( 0 , 1 ) + v_in ( 0 , 2 ))) / 2.d0 grid % wavenumber_k ( 0 , 0 ) = 0.d0 grid % wavenumber_kh_pow_2 ( 0 , 0 ) = grid % wavenumber_k ( 0 , 0 ) * grid % hxhy endif if ( npx == 0 . and . npy == npy0 - 1 ) then !   (-1,n+2)--(0,n+2)-|-(1,n+2)--(2,n+2)--(3,n+2) !      |        |     |    |       |       | !   (-1,n+1)--(0,n+1)-|-(1,n+1)--(2,n+1)--(3,n+1) !    __|________|_____|____|_______|_______|____ !   (-1, n )--(0, n )-|-(1, n )--(2, n )--(3, n ) !      |        |     |    |       |       | !   (-1,n-1)--(0,n-1)-|-(1,n-1)--(2,n-1)--(3,n-1) !      |        |     |    |       |       | !   (-1,n-2)--(0,n-2)-|-(1,n-2)--(2,n-2)--(3,n-2) v_in ( 0 , grid % ny + 1 ) = (( 2.d0 * cone * grid % wavenumber_k ( 1 , grid % ny + 1 ) * grid % hx * v_in ( 1 , grid % ny + 1 ) + v_in ( 2 , grid % ny + 1 )) & + ( 2.d0 * cone * grid % wavenumber_k ( 0 , grid % ny ) * grid % hy * v_in ( 0 , grid % ny ) + v_in ( 0 , grid % ny - 1 ))) / 2.d0 grid % wavenumber_k ( 0 , grid % ny + 1 ) = 0.d0 grid % wavenumber_kh_pow_2 ( 0 , grid % ny + 1 ) = grid % wavenumber_k ( 0 , grid % ny + 1 ) * grid % hxhy endif if ( npx == npx0 - 1 . and . npy == 0 ) then !   (n-2, 3)--(n-1, 3)--( n , 3)--|--(n+1, 3)--(n+2, 3) !       |        |          |     |      |       | !   (n-2, 2)--(n-1, 2)--( n , 2)--|--(n+1, 2)--(n+2, 2) !       |        |          |     |      |       | !   (n-2, 1)--(n-1, 1)--( n , 1)--|--(n+1, 1)--(n+2, 1) !   ____|________|__________|_____|______|_______|______ !       |        |          |     |      |       | !   (n-2, 0)--(n-1, 0)--( n , 0)--|--(n+1, 0)--(n+2, 0) !       |        |          |     |      |       | !   (n-2,-1)--(n-1,-1)--( n ,-1)--|--(n+1,-1)--(n+2,-1) v_in ( grid % nx + 1 , 0 ) = (( 2.d0 * cone * grid % wavenumber_k ( grid % nx , 0 ) * grid % hx * v_in ( grid % nx , 0 ) + v_in ( grid % nx - 1 , 0 )) & + ( 2.d0 * cone * grid % wavenumber_k ( grid % nx + 1 , 1 ) * grid % hy * v_in ( grid % nx + 1 , 1 ) + v_in ( grid % nx + 1 , 2 ))) / 2.d0 grid % wavenumber_k ( grid % nx + 1 , 0 ) = 0.d0 grid % wavenumber_kh_pow_2 ( grid % nx + 1 , 0 ) = grid % wavenumber_k ( grid % nx + 1 , 0 ) * grid % hxhy endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then !   (n-2,n+2)--(n-1,n+2)--( n ,n+2)--|--(n+1,n+2)--(n+2,n+2) !       |          |          |      |      |          | !   (n-2,n+1)--(n-1,n+1)--( n ,n+1)--|--(n+1,n+1)--(n+2,n+1) !   ____|__________|__________|______|______|__________|______ !       |          |          |      |      |          | !   (n-2, n )--(n-1, n )--( n , n )--|--(n+1, n )--(n+2, n ) !       |          |          |      |      |          | !   (n-2,n-1)--(n-1,n-1)--( n ,n-1)--|--(n+1,n-1)--(n+2,n-1) !       |          |          |      |      |          | !   (n-2,n-2)--(n-1,n-2)--( n ,n-2)--|--(n+1,n-2)--(n+2,n-2) v_in ( grid % nx + 1 , grid % ny + 1 ) = (( 2.d0 * cone * grid % wavenumber_k ( grid % nx , grid % ny + 1 ) * grid % hx * v_in ( grid % nx , grid % ny + 1 )& + v_in ( grid % nx - 1 , grid % ny + 1 )) & + ( 2.d0 * cone * grid % wavenumber_k ( grid % nx + 1 , grid % ny ) * grid % hy * v_in ( grid % nx + 1 , grid % ny )& + v_in ( grid % nx + 1 , grid % ny - 1 ))) / 2.d0 grid % wavenumber_k ( grid % nx + 1 , grid % ny + 1 ) = 0.d0 grid % wavenumber_kh_pow_2 ( grid % nx + 1 , grid % ny + 1 ) = grid % wavenumber_k ( grid % nx + 1 , grid % ny + 1 ) * grid % hxhy endif else write ( * , * ) \"There is no such a boundary conditions yet!!!\" stop endif end subroutine GridBase_ExtrpltGhostBCs subroutine Helm_Ax_nth_stencils ( Stcl_nth , grid , ic , jc ) !! *ReD-Glk* computational stencils of the Helmholtz operator for differnet coarse-grid level implicit none type ( Gridpara ), intent ( inout ) :: grid !! parameters for the current coarse-grid system integer :: ic , jc !! Index for the wavenumber field integer :: ib , jb complex ( kind = realdp ) :: a ( 0 : 3 , 0 : 3 ), b ( 0 : 3 , 0 : 3 ) !! a: stencils for Laplace operator; b: stencils for wavenumber operator complex ( kind = realdp ) :: Stcl_nth ( - 3 : 3 , - 3 : 3 ) !! Resulting stencils for the Helmholtz operator integer ( kind = 4 ) :: level_i !! The current #level_i level level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 Stcl_nth = czero if ( level_i == 2 ) then a (:, 0 ) = [ complex ( realdp ) :: 3.82812500000d0 , 0.21875000000d0 , - 0.38281250000d0 , 0.d0 ] a (:, 1 ) = [ complex ( realdp ) :: 0.21875000000d0 , - 0.43750000000d0 , - 0.17187500000d0 , 0.d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 0.38281250000d0 , - 0.17187500000d0 , - 0.01171875000d0 , 0.d0 ] a (:, 3 ) = [ complex ( realdp ) :: 0.00000000000d0 , 0.00000000000d0 , 0.00000000000d0 , 0.d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1.196289062500d0 , 0.478515625000d0 , 0.017089843750d0 , 0.d0 ] b (:, 1 ) = [ complex ( realdp ) :: 0.478515625000d0 , 0.191406250000d0 , 0.006835937500d0 , 0.d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.017089843750d0 , 0.006835937500d0 , 0.000244140625d0 , 0.d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.000000000000d0 , 0.000000000000d0 , 0.000000000000d0 , 0.d0 ] elseif ( level_i == 3 ) then a (:, 0 ) = [ complex ( realdp ) :: 1 1.2361450195313d0 , 1.46577453613281d0 , - 1.35073852539063d0 , - 0.0456085205078125d0 ] a (:, 1 ) = [ complex ( realdp ) :: 1.46577453613281d0 , - 1.12293624877930d0 , - 0.791053771972656d0 , - 0.0220222473144531d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 1.35073852539063d0 , - 0.791053771972656d0 , - 0.125289916992188d0 , - 0.00203704833984375d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.0456085205078125d0 , - 0.0220222473144531d0 , - 0.00203704833984375d0 , - 1.14440917968750d-5 ] b (:, 0 ) = [ complex ( realdp ) :: 3.90293979644775d0 , 1.84391236305237d0 , 0.155307292938232d0 , 0.000482320785522461d0 ] b (:, 1 ) = [ complex ( realdp ) :: 1.84391236305237d0 , 0.871141493320465d0 , 0.0733736753463745d0 , 0.000227868556976318d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.155307292938232d0 , 0.0733736753463745d0 , 0.00618004798889160d0 , 1.91926956176758d-5 ] b (:, 3 ) = [ complex ( realdp ) :: 0.000482320785522461d0 , 0.000227868556976318d0 , 1.91926956176758d-5 , 5.96046447753906d-8 ] elseif ( level_i == 4 ) then a (:, 0 ) = [ complex ( realdp ) :: 4 1.8592979907990d0 , 6.16552120447159d0 , - 5.19245016574860d0 , - 0.230845034122467d0 ] a (:, 1 ) = [ complex ( realdp ) :: 6.16552120447159d0 , - 3.95059673488140d0 , - 3.20627358555794d0 , - 0.117296531796455d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 5.19245016574860d0 , - 3.20627358555794d0 , - 0.582719027996063d0 , - 0.0132198035717011d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.230845034122467d0 , - 0.117296531796455d0 , - 0.0132198035717011d0 , - 0.000154897570610046d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1 4.9228199282661d0 , 7.28212934662588d0 , 0.703624110203236d0 , 0.00486294622533023d0 ] b (:, 1 ) = [ complex ( realdp ) :: 7.28212934662588d0 , 3.55357821617508d0 , 0.343358815996908d0 , 0.00237305037444457d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.703624110203236d0 , 0.343358815996908d0 , 0.0331764968577772d0 , 0.000229292199946940d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.00486294622533023d0 , 0.00237305037444457d0 , 0.000229292199946940d0 , 1.58470356836915d-6 ] elseif ( level_i == 5 ) then a (:, 0 ) = [ complex ( realdp ) :: 16 4.563205060549d0 , 2 4.9116344174836d0 , - 2 0.5528745003976d0 , - 0.972393697360531d0 ] a (:, 1 ) = [ complex ( realdp ) :: 2 4.9116344174836d0 , - 1 5.2913385086576d0 , - 1 2.8529095315607d0 , - 0.500045731023420d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 2 0.5528745003976d0 , - 1 2.8529095315607d0 , - 2.41139203752391d0 , - 0.0588705557165667d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.972393697360531d0 , - 0.500045731023420d0 , - 0.0588705557165667d0 , - 0.000785302079748362d0 ] b (:, 0 ) = [ complex ( realdp ) :: 5 9.0402948639394d0 , 2 9.0317872028857d0 , 2.89513443097121d0 , 0.0230771133726648d0 ] b (:, 1 ) = [ complex ( realdp ) :: 2 9.0317872028857d0 , 1 4.2757530282666d0 , 1.42361969765568d0 , 0.0113476710479858d0 ] b (:, 2 ) = [ complex ( realdp ) :: 2.89513443097121d0 , 1.42361969765568d0 , 0.141967505289585d0 , 0.00113162282889334d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.0230771133726648d0 , 0.0113476710479858d0 , 0.00113162282889334d0 , 9.02016432746677d-6 ] elseif ( level_i == 6 ) then a (:, 0 ) = [ complex ( realdp ) :: 65 5.429688162392d0 , 9 9.8838619755779d0 , - 8 1.9929805306983d0 , - 3.93873333857573d0 ] a (:, 1 ) = [ complex ( realdp ) :: 9 9.8838619755779d0 , - 6 0.6622323345425d0 , - 5 1.4359953570679d0 , - 2.03144743680355d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 8 1.9929805306983d0 , - 5 1.4359953570679d0 , - 9.72570502689905d0 , - 0.241711694433889d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 3.93873333857573d0 , - 2.03144743680355d0 , - 0.241711694433889d0 , - 0.00332380884970007d0 ] b (:, 0 ) = [ complex ( realdp ) :: 23 5.519105626998d0 , 11 6.029743978018d0 , 1 1.6606996686767d0 , 0.0961113088190835d0 ] b (:, 1 ) = [ complex ( realdp ) :: 11 6.029743978018d0 , 5 7.1626724369705d0 , 5.74470590638153d0 , 0.0473497490829131d0 ] b (:, 2 ) = [ complex ( realdp ) :: 1 1.6606996686767d0 , 5.74470590638153d0 , 0.577328605257279d0 , 0.00475853160158357d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.0961113088190835d0 , 0.0473497490829131d0 , 0.00475853160158357d0 , 3.92213772140715d-5 ] else !! Default 2nd-ordr stencils a (:, 0 ) = [ complex ( realdp ) :: 4.d0 , - 1.d0 , 0.d0 , 0.d0 ] a (:, 1 ) = [ complex ( realdp ) :: - 1.d0 , 0.d0 , 0.d0 , 0.d0 ] a (:, 2 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] a (:, 3 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 1 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] endif do jb =- 3 , 3 do ib =- 3 , 3 Stcl_nth ( ib , jb ) = a ( ABS ( ib ), ABS ( jb )) - b ( ABS ( ib ), ABS ( jb )) * grid % wavenumber_kh_pow_2 ( ic + ib , jc + jb ) enddo enddo end subroutine Helm_Ax_nth_stencils subroutine CSLP_Mx_nth_stencils ( Stcl_nth , grid , ic , jc ) !! *ReD-Glk* computational stencils of the CSLP operator for differnet coarse-grid level implicit none type ( Gridpara ), intent ( inout ) :: grid !! parameters for the current coarse-grid system integer :: ic , jc !! Index for the wavenumber field integer :: ib , jb complex ( kind = realdp ) :: a ( 0 : 3 , 0 : 3 ), b ( 0 : 3 , 0 : 3 ) !! a: stencils for Laplace operator; b: stencils for wavenumber operator complex ( kind = realdp ) :: Stcl_nth ( - 3 : 3 , - 3 : 3 ) !! Resulting stencils for the CSLP operator integer ( kind = 4 ) :: level_i !! The current #level_i level level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 Stcl_nth = czero if ( level_i == 2 ) then a (:, 0 ) = [ complex ( realdp ) :: 3.82812500000d0 , 0.21875000000d0 , - 0.38281250000d0 , 0.d0 ] a (:, 1 ) = [ complex ( realdp ) :: 0.21875000000d0 , - 0.43750000000d0 , - 0.17187500000d0 , 0.d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 0.38281250000d0 , - 0.17187500000d0 , - 0.01171875000d0 , 0.d0 ] a (:, 3 ) = [ complex ( realdp ) :: 0.00000000000d0 , 0.00000000000d0 , 0.00000000000d0 , 0.d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1.196289062500d0 , 0.478515625000d0 , 0.017089843750d0 , 0.d0 ] b (:, 1 ) = [ complex ( realdp ) :: 0.478515625000d0 , 0.191406250000d0 , 0.006835937500d0 , 0.d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.017089843750d0 , 0.006835937500d0 , 0.000244140625d0 , 0.d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.000000000000d0 , 0.000000000000d0 , 0.000000000000d0 , 0.d0 ] elseif ( level_i == 3 ) then a (:, 0 ) = [ complex ( realdp ) :: 1 1.2361450195313d0 , 1.46577453613281d0 , - 1.35073852539063d0 , - 0.0456085205078125d0 ] a (:, 1 ) = [ complex ( realdp ) :: 1.46577453613281d0 , - 1.12293624877930d0 , - 0.791053771972656d0 , - 0.0220222473144531d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 1.35073852539063d0 , - 0.791053771972656d0 , - 0.125289916992188d0 , - 0.00203704833984375d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.0456085205078125d0 , - 0.0220222473144531d0 , - 0.00203704833984375d0 , - 1.14440917968750d-5 ] b (:, 0 ) = [ complex ( realdp ) :: 3.90293979644775d0 , 1.84391236305237d0 , 0.155307292938232d0 , 0.000482320785522461d0 ] b (:, 1 ) = [ complex ( realdp ) :: 1.84391236305237d0 , 0.871141493320465d0 , 0.0733736753463745d0 , 0.000227868556976318d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.155307292938232d0 , 0.0733736753463745d0 , 0.00618004798889160d0 , 1.91926956176758d-5 ] b (:, 3 ) = [ complex ( realdp ) :: 0.000482320785522461d0 , 0.000227868556976318d0 , 1.91926956176758d-5 , 5.96046447753906d-8 ] elseif ( level_i == 4 ) then a (:, 0 ) = [ complex ( realdp ) :: 4 1.8592979907990d0 , 6.16552120447159d0 , - 5.19245016574860d0 , - 0.230845034122467d0 ] a (:, 1 ) = [ complex ( realdp ) :: 6.16552120447159d0 , - 3.95059673488140d0 , - 3.20627358555794d0 , - 0.117296531796455d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 5.19245016574860d0 , - 3.20627358555794d0 , - 0.582719027996063d0 , - 0.0132198035717011d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.230845034122467d0 , - 0.117296531796455d0 , - 0.0132198035717011d0 , - 0.000154897570610046d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1 4.9228199282661d0 , 7.28212934662588d0 , 0.703624110203236d0 , 0.00486294622533023d0 ] b (:, 1 ) = [ complex ( realdp ) :: 7.28212934662588d0 , 3.55357821617508d0 , 0.343358815996908d0 , 0.00237305037444457d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.703624110203236d0 , 0.343358815996908d0 , 0.0331764968577772d0 , 0.000229292199946940d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.00486294622533023d0 , 0.00237305037444457d0 , 0.000229292199946940d0 , 1.58470356836915d-6 ] elseif ( level_i == 5 ) then a (:, 0 ) = [ complex ( realdp ) :: 16 4.563205060549d0 , 2 4.9116344174836d0 , - 2 0.5528745003976d0 , - 0.972393697360531d0 ] a (:, 1 ) = [ complex ( realdp ) :: 2 4.9116344174836d0 , - 1 5.2913385086576d0 , - 1 2.8529095315607d0 , - 0.500045731023420d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 2 0.5528745003976d0 , - 1 2.8529095315607d0 , - 2.41139203752391d0 , - 0.0588705557165667d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 0.972393697360531d0 , - 0.500045731023420d0 , - 0.0588705557165667d0 , - 0.000785302079748362d0 ] b (:, 0 ) = [ complex ( realdp ) :: 5 9.0402948639394d0 , 2 9.0317872028857d0 , 2.89513443097121d0 , 0.0230771133726648d0 ] b (:, 1 ) = [ complex ( realdp ) :: 2 9.0317872028857d0 , 1 4.2757530282666d0 , 1.42361969765568d0 , 0.0113476710479858d0 ] b (:, 2 ) = [ complex ( realdp ) :: 2.89513443097121d0 , 1.42361969765568d0 , 0.141967505289585d0 , 0.00113162282889334d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.0230771133726648d0 , 0.0113476710479858d0 , 0.00113162282889334d0 , 9.02016432746677d-6 ] elseif ( level_i == 6 ) then a (:, 0 ) = [ complex ( realdp ) :: 65 5.429688162392d0 , 9 9.8838619755779d0 , - 8 1.9929805306983d0 , - 3.93873333857573d0 ] a (:, 1 ) = [ complex ( realdp ) :: 9 9.8838619755779d0 , - 6 0.6622323345425d0 , - 5 1.4359953570679d0 , - 2.03144743680355d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 8 1.9929805306983d0 , - 5 1.4359953570679d0 , - 9.72570502689905d0 , - 0.241711694433889d0 ] a (:, 3 ) = [ complex ( realdp ) :: - 3.93873333857573d0 , - 2.03144743680355d0 , - 0.241711694433889d0 , - 0.00332380884970007d0 ] b (:, 0 ) = [ complex ( realdp ) :: 23 5.519105626998d0 , 11 6.029743978018d0 , 1 1.6606996686767d0 , 0.0961113088190835d0 ] b (:, 1 ) = [ complex ( realdp ) :: 11 6.029743978018d0 , 5 7.1626724369705d0 , 5.74470590638153d0 , 0.0473497490829131d0 ] b (:, 2 ) = [ complex ( realdp ) :: 1 1.6606996686767d0 , 5.74470590638153d0 , 0.577328605257279d0 , 0.00475853160158357d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.0961113088190835d0 , 0.0473497490829131d0 , 0.00475853160158357d0 , 3.92213772140715d-5 ] else a (:, 0 ) = [ complex ( realdp ) :: 4.d0 , - 1.d0 , 0.d0 , 0.d0 ] a (:, 1 ) = [ complex ( realdp ) :: - 1.d0 , 0.d0 , 0.d0 , 0.d0 ] a (:, 2 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] a (:, 3 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 0 ) = [ complex ( realdp ) :: 1.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 1 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] b (:, 3 ) = [ complex ( realdp ) :: 0.d0 , 0.d0 , 0.d0 , 0.d0 ] endif do jb =- 3 , 3 do ib =- 3 , 3 Stcl_nth ( ib , jb ) = a ( ABS ( ib ), ABS ( jb )) - ( beta1 - beta2 * cone ) * b ( ABS ( ib ), ABS ( jb )) * grid % wavenumber_kh_pow_2 ( ic + ib , jc + jb ) enddo enddo end subroutine CSLP_Mx_nth_stencils end module operators","tags":"","loc":"sourcefile/operators.f90.html"},{"title":"idrs_module.f90 – ParaMADP","text":"This file depends on sourcefile~~idrs_module.f90~~EfferentGraph sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~idrs_module.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~idrs_module.f90->sourcefile~mpi_setup.f90 sourcefile~read_setup.f90 read_setup.f90 sourcefile~idrs_module.f90->sourcefile~read_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~read_setup.f90->sourcefile~comm_variable.f90 sourcefile~user_module.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~idrs_module.f90~~AfferentGraph sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! IDRS Induced Dimension Reduction method ! !   x = IDRS( A, b, M, s,                             (mandatory) !           [ tolerance, maximum_iterations, variant, (optional input scalars) !             flag, relres, iterations,               (optional output scalars) !             x0, U0, omega,                          (optional input vectors) !             resvec, H] )                            (optional output vectors) ! !   solves the system of linear equations A*x=b for x with the method IDRS !   The dimension of the matrix A is NxN !   The dimension of the right-hand-side b is NxNRHS !   (NRHS: number of rhs vectors) ! !   IDRS uses a user defined TYPE MATRIX, which is a structure that contains !   all the parameters that define the system matrix A !   The operator * must be overloaded to perform the operation A*v !   To this end overloading must be defined for (real and complex) user !   routines that perform the matrix-vector multiplication. These !   routines should be included in the module user_module that is used in the !   module idrs_module.f90. ! !   IDRS uses a user defined TYPE PRECONDITIONER, which is a structure that !   contains all the parameters that define the preconditioning matrix M !   Overloading of the operator / is used to perform the preconditioning !   operation v/M1. To this end overloading must be defined for (real and !   complex) user routines that perform the preconditiong operations. These !   routines should be included in the module user_module that is used in the !   module idrs_module.f90. ! !   The precision of the complex and real variables are defined by the !   parameters rp (real precision)and cp (complex precision). These parameters !   should be set in the module user_module. ! !   Input and output variables of IDRS: ! !   Function output: !        x: REAL (kind=rp) or COMPLEX (kind=cp) vector of dimension NxNRHS ! !   Function parameters: !     Input, required: !        A: TYPE MATRIX (user defined), A defines the system matrix !        b: REAL (kind=rp) or COMPLEX (kind=cp) matrix of dimension NxNRHS, !           b is the matrix of right-hand-side vectors !        M: TYPE PRECONDITIONER, M defines the preconditioner !        s: INTEGER (must be > 0), s defines the dimension of the shadow space !           in IDRS, and by this the depth of the recursions ! !     Input, optional parameters: !        tolerance: REAL (kind=rp). IDRS is terminated if |b-Ax|/|b| < tolerance !           Default: tolerance = 1e-6 !        maximum_iterations: INTEGER. IDRS stops of the number of iterations !           exceeds maximum_iterations. !           Default: maximum_iterations = min(2*N,1000) !        variant: CHARACTER*8. Selects the specific IDR-variant. !           Possible variants are: !           variant = 'biortho ': IDR(s) with random shadow vectors, !                                 'maintaining convergence' for computing omega !           variant = 'minsync ': Piecewise constant shadow vectors, !                                 'minimal residual' for computing omega !           variant = 'bicgstab': s must be set to 1. !                                 Initial residual is the shadow vector, !                                 'minimal residual' for omega. !                                 This gives an algorithm that is !                                 mathematically the same as BiCGSTAB !           Default: variant = 'biortho ' ! !     Output, optional parameters: !        flag: INTEGER. Indicates convergence condition !           flag = 0: required tolerance satisfied !           flag = 1: no convergence to the required tolerance within maximum !                     number of iterations !           flag = 2: final residual norm above tolerance !           flag = 3: one of the iteration parameters became zero, !                     causing break down !        relres: REAL (kind=rp), |b-Ax|/|b|. The norms are trace norms. !        iterations: INTEGER. The number of iterations that has been performed !                             to compute the solution ! !     Input, optional arrays: !        x0: REAL (kind=rp) or COMPLEX (kind=cp) matrix of dimension NxNRHS, !           initial guess for the solution. Default: x0 = 0. !        U0: REAL (kind=rp) or COMPLEX (kind=cp) array of dimension NxNRHSxs, !           Initial search space. Default: no initial search space. !        omega: REAL (kind=rp) or COMPLEX (kind=cp) array of dimension n_omega, !           where n_omega is the number of user defined omega-parameters. !           The parameters are used cyclicly. User defined omega's make it !           possible to define and examine new IDR(s) variants. ! !     Output, optional arrays: !        resvec: REAL (kind=rp), array of dimension maximum_iterations+1 !           resvec contains for every iteration the norm of the residual !        H: REAL (kind=rp) or COMPLEX (kind=cp) matrix of dimension !           (nritz+1) x nritz, in which nritz is the number of ritz values !           that can be computed. Note that in s+1 iterations s additional !           ritz values can be computed.  H is an extended upper Hessenberg !           matrix of which the upper bandwidth is s. It can be used for !           analysis purposes, the eigenvalues of the leading submatrices of !           H are ritzvalues ! !   Acknowledgement: Duncan van der Heul, Reinaldo Astudillo, Jan de Gier and !                    Marielba Rojas are gratefully acknowledged for their !                    advise on many aspects of this software. ! !   The software is distributed without any warranty. ! !   Martin van Gijzen !   Copyright (c) July 2015 ! module idrs_module !! IDRS Induced Dimension Reduction method use mpi use comm_variable use read_setup use mpi_setup use user_module implicit none private public :: IDRS , TRACE_DOT , FROB_NORM , P_DOT !public :: CIDRS, RIDRS, TRACE_DOT, FROB_NORM, P_DOT interface TRACE_DOT module procedure CTRACE_DOT , RTRACE_DOT , RCTRACE_DOT end interface interface P_DOT module procedure CP_DOT , RP_DOT end interface interface FROB_NORM module procedure CFROB_NORM , RFROB_NORM end interface interface IDRS module procedure CIDRS , RIDRS end interface contains ! Trace inner product of complex matrices function CTRACE_DOT ( v , w ) complex ( kind = realdp ), intent ( in ) :: v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), w ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ) :: CTRACE_DOT_local complex ( kind = realdp ) :: CTRACE_DOT CTRACE_DOT_local = sum ( conjg ( v ( 1 : nx , 1 : ny )) * w ( 1 : nx , 1 : ny ) ) call MPI_Allreduce ( CTRACE_DOT_local , & CTRACE_DOT , & 1 , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) end function CTRACE_DOT ! Trace inner product of real matrices function RTRACE_DOT ( v , w ) real ( kind = realdp ), intent ( in ) :: v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), w ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) real ( kind = realdp ) :: RTRACE_DOT_local real ( kind = realdp ) :: RTRACE_DOT RTRACE_DOT_local = sum ( v ( 1 : nx , 1 : ny ) * w ( 1 : nx , 1 : ny ) ) call MPI_Allreduce ( RTRACE_DOT_local , & RTRACE_DOT , & 1 , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) end function RTRACE_DOT ! Trace inner product of real and complex matrices function RCTRACE_DOT ( v , w ) real ( kind = realdp ), intent ( in ) :: v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ), intent ( in ) :: w ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ) :: RCTRACE_DOT complex ( kind = realdp ) :: RCTRACE_DOT_local RCTRACE_DOT_local = sum ( v ( 1 : nx , 1 : ny ) * w ( 1 : nx , 1 : ny ) ) call MPI_Allreduce ( RCTRACE_DOT_local , & RCTRACE_DOT , & 1 , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) end function RCTRACE_DOT ! P inner product of complex matrices function CP_DOT ( P , R0 , w , s ) integer :: s real ( kind = realdp ), allocatable , intent ( in ) :: P (:,:,:) !(1-LAP:nx+LAP,1-LAP:ny+LAP,s) complex ( kind = realdp ), allocatable , intent ( in ) :: R0 (:,:) complex ( kind = realdp ), intent ( in ) :: w ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ) :: v ( s ), CP_DOT ( s ) complex ( kind = realdp ) :: vi_local ( s ) integer :: i , j , N , low ( s ), up ( s ), step , nrhs if ( allocated ( P ) ) then ! Biortho: P has orthogonal random numbers !write(*,*) \"Hi, Do you call me? CP_DOT\" do i = 1 , s vi_local ( i ) = sum ( P ( 1 : nx , 1 : ny , i ) * w ( 1 : nx , 1 : ny ) ) end do call MPI_Allreduce ( vi_local , & v , & s , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) else if ( allocated ( R0 ) ) then ! BiCGSTAB: shadow vector equal to initial residual vi_local ( 1 ) = sum ( conjg ( R0 ( 1 : nx , 1 : ny )) * w ( 1 : nx , 1 : ny ) ) !no!!! sum( conjg(R0)*w ) no!!! !made a big mistake here, only found after done numerous tests, only not converge for MP-4 nx=2209,np>13?!! call MPI_Allreduce ( vi_local ( 1 ), & v ( 1 ), & 1 , & MPI_DOUBLE_COMPLEX , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) else ! Minsync: P is piecewise constant N = size ( w , 1 ) nrhs = size ( w , 2 ) step = N / s low ( 1 ) = 1 do i = 1 , s - 1 low ( i + 1 ) = i * step + 1 up ( i ) = i * step end do up ( s ) = N do i = 1 , s v ( i ) = 0. do j = 1 , nrhs v ( i ) = v ( i ) + sum ( w ( low ( i ): up ( i ), j ) ) end do end do end if CP_DOT = v end function CP_DOT ! P inner product of real matrices function RP_DOT ( P , R0 , w , s ) integer :: s real ( kind = realdp ), allocatable , intent ( in ) :: P (:,:,:) !(1-LAP:nx+LAP,1-LAP:ny+LAP,s) real ( kind = realdp ), allocatable , intent ( in ) :: R0 (:,:) real ( kind = realdp ), intent ( in ) :: w ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) real ( kind = realdp ) :: v ( s ), RP_DOT ( s ) real ( kind = realdp ) :: vi_local ( s ) integer :: i , j , N , nrhs , low ( s ), up ( s ), step if ( allocated ( P ) ) then ! Biortho: P has orthogonal random numbers !write(*,*) \"Hi, Do you call me? RP_DOT\" do i = 1 , s vi_local ( i ) = sum ( P ( 1 : nx , 1 : ny , i ) * w ( 1 : nx , 1 : ny ) ) end do call MPI_Allreduce ( vi_local , & v , & s , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) else if ( allocated ( R0 ) ) then ! Bi-CGSTAB: shadow vector equal to initial residual vi_local ( 1 ) = sum ( R0 ( 1 : nx , 1 : ny ) * w ( 1 : nx , 1 : ny ) ) !!made a big mistake here, only found after done numerous tests, call MPI_Allreduce ( vi_local ( 1 ), & v ( 1 ), & 1 , & MPI_DOUBLE_PRECISION ,& MPI_SUM , & MPI_COMM_WORLD , & ierr ) else ! Minsync: P has piecewise constant columns N = size ( w , 1 ) nrhs = size ( w , 2 ) step = N / s low ( 1 ) = 1 up ( s ) = N do i = 1 , s - 1 low ( i + 1 ) = i * step + 1 up ( i ) = i * step end do do i = 1 , s v ( i ) = 0. do j = 1 , nrhs v ( i ) = sum ( w ( low ( i ): up ( i ), j ) ) end do end do end if RP_DOT = v end function RP_DOT function CFROB_NORM ( v ) !! Frobenius norm of complex matrix complex ( kind = realdp ), intent ( in ) :: v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) real ( kind = realdp ) :: CFROB_NORM real ( kind = realdp ) :: CFROB_NORM_local CFROB_NORM_local = sum ( conjg ( v ( 1 : nx , 1 : ny )) * v ( 1 : nx , 1 : ny ) ) call MPI_Allreduce ( CFROB_NORM_local , & CFROB_NORM , & 1 , & MPI_DOUBLE_PRECISION , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) CFROB_NORM = sqrt ( CFROB_NORM ) end function CFROB_NORM function RFROB_NORM ( v ) !! Frobenius norm of real matrix real ( kind = realdp ), intent ( in ) :: v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) real ( kind = realdp ) :: RFROB_NORM_local real ( kind = realdp ) :: RFROB_NORM RFROB_NORM_local = sum ( v ( 1 : nx , 1 : ny ) * v ( 1 : nx , 1 : ny ) ) call MPI_Allreduce ( RFROB_NORM_local , & RFROB_NORM , & 1 , & MPI_DOUBLE_PRECISION , & MPI_SUM , & MPI_COMM_WORLD , & ierr ) RFROB_NORM = sqrt ( RFROB_NORM ) end function RFROB_NORM function CIDRS ( A , b , M1 , s , & ! required tolerance , maximum_iterations , variant , & ! optional input flag , relres , iterations , & ! optional output x0 , U0 , omega , resvec , H ) ! optional arrays IMPLICIT NONE ! Required input parameters: type ( matrix ), intent ( in ) :: A ! system matrix complex ( kind = realdp ), allocatable , intent ( in ) :: b (:,:) !(1-LAP:nx+LAP,1-LAP:ny+LAP)          ! system rhs !complex(kind=realdp), allocatable,dimension(:,:) :: b type ( preconditioner ), intent ( in ) :: M1 ! preconditioner integer , intent ( in ) :: s ! s parameter ! Solution: complex ( kind = realdp ) :: CIDRS ( size ( b , 1 ), size ( b , 2 )) ! Optional input parameters: real ( kind = realdp ), optional , intent ( in ) :: tolerance integer , optional , intent ( in ) :: maximum_iterations character ( len = 8 ), optional , intent ( in ) :: variant ! Optional output parameters: integer , optional , intent ( out ) :: flag real ( kind = realdp ), optional , intent ( out ) :: relres integer , optional , intent ( out ) :: iterations ! Optional input arrays: complex ( kind = realdp ), optional , intent ( in ) :: x0 (:,:) complex ( kind = realdp ), optional , intent ( in ) :: U0 (:,:,:) complex ( kind = realdp ), optional , intent ( in ) :: omega (:) ! Optional output arrays: real ( kind = realdp ), optional , intent ( out ) :: resvec (:) !Jchen, change it to relresvec complex ( kind = realdp ), optional , intent ( out ) :: H (:,:) ! Local arrays: real ( kind = realdp ), allocatable :: P (:,:,:) complex ( kind = realdp ), allocatable :: R0 (:,:) complex ( kind = realdp ), allocatable , dimension (:) :: f , mu , alpha , beta , gamma complex ( kind = realdp ), allocatable , dimension (:,:) :: x , r , v , t , M complex ( kind = realdp ), allocatable , dimension (:,:,:) :: G , U complex ( kind = realdp ) :: om , tr real ( kind = realdp ) :: nr , nt , rho , kappa ! complex(kind=realdp)                       :: x(size(b,1),size(b,2)) ! complex(kind=realdp)                       :: G(size(b,1),size(b,2),s) ! complex(kind=realdp)                       :: U(size(b,1),size(b,2),s) ! complex(kind=realdp)                       :: r(size(b,1),size(b,2)) ! complex(kind=realdp)                       :: v(size(b,1),size(b,2)) ! complex(kind=realdp)                       :: t(size(b,1),size(b,2)) ! complex(kind=realdp)                       :: M(s,s), f(s), mu(s) ! complex(kind=realdp)                       :: alpha(s), beta(s), gamma(s) !include 'idrs_body.f90' !------------------------------idrs_body.f90------------------------------------- ! Declarations: integer :: n ! dimension of the system integer :: nrhs ! Number of RHS-vectors integer :: maxit ! maximum number of iterations integer :: method ! which IDR(s) variant? real ( kind = realdp ) :: tol ! actual tolerance integer :: info ! convergence indicator logical :: out_flag ! store flag logical :: out_relres ! store relres logical :: out_iterations ! store number of iterations logical :: inispace ! initial search space logical :: user_omega ! user defined omega present integer :: n_omega ! number of user defined omega's logical :: out_resvec ! store residual norms logical :: out_H ! store iteration parameters in H integer :: nritz ! Number of wanted ritz values integer :: iter ! number of iterations integer :: ii ! inner iterations index integer :: jj ! G-space index real ( kind = realdp ) :: normb , normr , tolb ! for tolerance check integer :: i , j , k , l ! loop counters ! Problem size: n = size ( b , 1 ) ! Number of right-hand-side vectors: nrhs = size ( b , 2 ) ! allocate local arrays: allocate ( f ( s ), mu ( s ), alpha ( s ), beta ( s ), gamma ( s )) allocate ( x ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , r ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) ) allocate ( t ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , M ( s , s )) allocate ( G ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , s ), U ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , s )) ! Check optional input parameters: if ( present ( tolerance ) ) then if ( tolerance < 0 ) stop \"Illegal value for parameter tolerance\" tol = tolerance else tol = 1e-6 endif maxit = min ( 2 * n , 1000 ) if ( present ( maximum_iterations ) ) maxit = maximum_iterations method = 1 ! biortho if ( present ( variant ) ) then if ( variant == 'minsync' ) then method = 2 elseif ( variant == 'bicgstab' ) then method = 3 endif endif ! Initialize the output variables out_flag = present ( flag ) if ( out_flag ) flag = - 1 out_relres = present ( relres ) if ( out_relres ) relres = 1. out_iterations = present ( iterations ) if ( out_iterations ) iterations = 0 ! Check optional input arrays: x = 0. if ( present ( x0 ) ) x = x0 U = 0. inispace = present ( U0 ) if ( inispace ) U = U0 user_omega = present ( omega ) if ( user_omega ) then n_omega = size ( omega ) end if ! Check output arrays out_resvec = present ( resvec ) if ( out_resvec ) then if ( maxit + 1 > size ( resvec ) ) & stop \"Length of vector with residual norms too small, should be maxit+1\" end if out_H = present ( H ) if ( out_H ) then nritz = size ( H , 1 ) - 1 if ( size ( H , 2 ) /= nritz ) & stop \"Second dimension of H incompatible, with first\" H = 0. end if ! compute initial residual, set absolute tolerance normb = FROB_NORM ( b ) tolb = tol * normb r = b - A * x normr = FROB_NORM ( r ) if ( out_resvec ) resvec ( 1 ) = normr / normb ! check if the initial solution is not already a solution within the prescribed ! tolerance if ( normr <= tolb ) then if ( out_iterations ) iterations = 0 if ( out_flag ) flag = 0 if ( out_relres ) relres = normr / normb return end if ! Define P and kappa (depending on the method) if ( method == 1 ) then !allocate(P(n,nrhs,s)) allocate ( P ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , s ) ) call RANDOM_SEED call RANDOM_NUMBER ( P ) do j = 1 , s do k = 1 , j - 1 alpha ( k ) = TRACE_DOT ( P (:,:, k ), P (:,:, j ) ) P (:,:, j ) = P (:,:, j ) - alpha ( k ) * P (:,:, k ) end do !P(:,:,j) = P(:,:,j)/FROB_NORM(P(:,:,j)) P (:,:, j ) = P (:,:, j ) / RFROB_NORM ( P (:,:, j )) end do kappa = 0.7 elseif ( method == 2 ) then ! P is piecewise constant, minimum residual for omega kappa = 0. elseif ( method == 3 ) then if ( s /= 1 ) stop \"s=1 is required for variant bicgstab\" !allocate(R0(n,nrhs)) allocate ( R0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) ) R0 = r kappa = 0. endif ! Initialize local variables: M = 0. om = 1. iter = 0 info = - 1 jj = 0 ii = 0 ! This concludes the initialisation phase ! Main iteration loop, build G-spaces: do while ( info < 0 ) ! start of iteration loop !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Generate s vectors in G_j !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! New right-hand side for small system: f = P_DOT ( P , R0 , r , s ) do k = 1 , s ! Update inner iteration counter ii = ii + 1 ! Compute new v v = r if ( jj > 0 ) then ! Solve small system (Note: M is lower triangular) and make v orthogonal to P: do i = k , s gamma ( i ) = f ( i ) do j = k , i - 1 gamma ( i ) = gamma ( i ) - M ( i , j ) * gamma ( j ) end do gamma ( i ) = gamma ( i ) / M ( i , i ) v = v - gamma ( i ) * G (:,:, i ) end do ! Compute new U(:,:,k) t = om * ( v / M1 ) do i = k , s t = t + gamma ( i ) * U (:,:, i ) end do U (:,:, k ) = t ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz ) & H ( ii - s : ii - k , ii ) = - gamma ( k : s ) / beta ( k : s ) else if ( . not . inispace ) then ! Updates for the first s iterations (in G_0): U (:,:, k ) = v / M1 end if ! Compute new G(:,:,k), G(:,:,k) is in space G_j G (:,:, k ) = A * U (:,:, k ) ! Bi-Orthogonalise the new basis vectors: mu = P_DOT ( P , R0 , G (:,:, k ), s ) do i = 1 , k - 1 alpha ( i ) = mu ( i ) do j = 1 , i - 1 alpha ( i ) = alpha ( i ) - M ( i , j ) * alpha ( j ) end do alpha ( i ) = alpha ( i ) / M ( i , i ) G (:,:, k ) = G (:,:, k ) - G (:,:, i ) * alpha ( i ) U (:,:, k ) = U (:,:, k ) - U (:,:, i ) * alpha ( i ) mu ( k : s ) = mu ( k : s ) - M ( k : s , i ) * alpha ( i ) end do M ( k : s , k ) = mu ( k : s ) ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz . and . k > 1 ) & H ( ii - k + 1 : ii - 1 , ii ) = alpha ( 1 : k - 1 ) / beta ( 1 : k - 1 ) ! Break down? if ( abs ( M ( k , k )) <= tiny ( tol ) ) then info = 3 exit end if ! Make r orthogonal to p_i, i = 1..k, update solution and residual beta ( k ) = f ( k ) / M ( k , k ) r = r - beta ( k ) * G (:,:, k ) x = x + beta ( k ) * U (:,:, k ) ! New f = P'*r (first k  components are zero) if ( k < s ) then f ( k + 1 : s ) = f ( k + 1 : s ) - beta ( k ) * M ( k + 1 : s , k ) end if ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz ) then H ( ii , ii ) = 1. / beta ( k ) l = max ( 1 , ii - s ) H ( l + 1 : ii + 1 , ii ) = ( H ( l + 1 : ii + 1 , ii ) - H ( l : ii , ii )) H ( l : ii + 1 , ii ) = H ( l : ii + 1 , ii ) / om end if ! Check for convergence normr = FROB_NORM ( r ) iter = iter + 1 if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) iter , normr endif if ( out_resvec ) resvec ( iter + 1 ) = normr / normb if ( normr < tolb ) then info = 0 exit elseif ( iter == maxit ) then info = 1 exit end if end do ! Now we have computed s+1 vectors in G_j if ( info >= 0 ) then exit end if !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Compute first residual in G_j+1 !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Update G-space counter jj = jj + 1 ! Compute first residual in G_j+1 ! Note: r is already perpendicular to P so v = r ! Preconditioning: v = r / M1 t = A * v ! Computation of a new omega if ( user_omega ) then i = mod ( jj , n_omega ) if ( i == 0 ) i = n_omega om = omega ( i ) elseif ( kappa == 0. ) then ! Minimal residual (same as in Bi-CGSTAB): om = TRACE_DOT ( t , r ) / TRACE_DOT ( t , t ) else ! 'Maintaining the convergence': nr = FROB_NORM ( r ) nt = FROB_NORM ( t ) tr = TRACE_DOT ( t , r ) rho = abs ( tr / ( nt * nr )) om = tr / ( nt * nt ) if ( rho < kappa ) then om = om * kappa / rho end if end if if ( abs ( om ) <= epsilon ( tol ) ) then info = 3 exit end if ! Update solution and residual r = r - om * t x = x + om * v ! Check for convergence normr = FROB_NORM ( r ) iter = iter + 1 if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) iter , normr endif if ( out_resvec ) resvec ( iter + 1 ) = normr / normb if ( normr < tolb ) then info = 0 elseif ( iter == maxit ) then info = 1 end if end do ! end of while loop ! Set output parameters r = b - A * x normr = FROB_NORM ( r ) if ( info == 0 . and . normr > tolb ) info = 2 if ( out_iterations ) iterations = iter if ( out_relres ) relres = normr / normb if ( out_flag ) flag = info !------------------------------idrs_body.f90------------------------------------- cidrs = x ! deallocate local arrays: deallocate ( f , mu , alpha , beta , gamma ) deallocate ( x , r , v ) deallocate ( t , M ) deallocate ( G , U ) end function CIDRS function RIDRS ( A , b , M1 , s , & ! required tolerance , maximum_iterations , variant , & ! optional input flag , relres , iterations , & ! optional output x0 , U0 , omega , H , resvec ) ! optional arrays IMPLICIT NONE ! Required input and output parameters: type ( matrix ), intent ( in ) :: A ! system matrix real ( kind = realdp ), allocatable , intent ( in ) :: b (:,:) !real(kind=realdp), intent(in)              :: b(1-LAP:nx+LAP,1-LAP:ny+LAP)         ! system rhs !real(kind=realdp), allocatable,dimension(:,:) :: b type ( preconditioner ), intent ( in ) :: M1 ! preconditioner integer , intent ( in ) :: s ! s parameter ! Solution real ( kind = realdp ) :: RIDRS ( size ( b , 1 ), size ( b , 2 )) ! Optional input parameters: real ( kind = realdp ), optional , intent ( in ) :: tolerance integer , optional , intent ( in ) :: maximum_iterations character ( len = 8 ), optional , intent ( in ) :: variant ! Optional output parameters: integer , optional , intent ( out ) :: flag real ( kind = realdp ), optional , intent ( out ) :: relres integer , optional , intent ( out ) :: iterations ! Optional input arrays: real ( kind = realdp ), optional , intent ( in ) :: x0 (:,:) real ( kind = realdp ), optional , intent ( in ) :: U0 (:,:,:) real ( kind = realdp ), optional , intent ( in ) :: omega (:) ! Optional output arrays real ( kind = realdp ), optional , intent ( out ) :: resvec (:) real ( kind = realdp ), optional , intent ( out ) :: H (:,:) ! Local arrays: real ( kind = realdp ), allocatable :: P (:,:,:) real ( kind = realdp ), allocatable :: R0 (:,:) real ( kind = realdp ) :: om , kappa real ( kind = realdp ) :: nr , nt , tr , rho real ( kind = realdp ), allocatable , dimension (:) :: f , mu , alpha , beta , gamma real ( kind = realdp ), allocatable , dimension (:,:) :: x , r , v , t , M real ( kind = realdp ), allocatable , dimension (:,:,:) :: G , U ! real(kind=realdp)                          :: x(size(b,1),size(b,2)) ! real(kind=realdp)                          :: G(size(b,1),size(b,2),s) ! real(kind=realdp)                          :: U(size(b,1),size(b,2),s) ! real(kind=realdp)                          :: r(size(b,1),size(b,2)) ! real(kind=realdp)                          :: v(size(b,1),size(b,2)) ! real(kind=realdp)                          :: t(size(b,1),size(b,2)) ! real(kind=realdp)                          :: M(s,s), f(s), mu(s) ! real(kind=realdp)                          :: alpha(s), beta(s), gamma(s) !include 'idrs_body.f90' !----------------------------------idrs_body.f90---------------------------------------! ! Declarations: integer :: n ! dimension of the system integer :: nrhs ! Number of RHS-vectors integer :: maxit ! maximum number of iterations integer :: method ! which IDR(s) variant? real ( kind = realdp ) :: tol ! actual tolerance integer :: info ! convergence indicator logical :: out_flag ! store flag logical :: out_relres ! store relres logical :: out_iterations ! store number of iterations logical :: inispace ! initial search space logical :: user_omega ! user defined omega present integer :: n_omega ! number of user defined omega's logical :: out_resvec ! store residual norms logical :: out_H ! store iteration parameters in H integer :: nritz ! Number of wanted ritz values integer :: iter ! number of iterations integer :: ii ! inner iterations index integer :: jj ! G-space index real ( kind = realdp ) :: normb , normr , tolb ! for tolerance check integer :: i , j , k , l ! loop counters ! Problem size: n = size ( b , 1 ) ! Number of right-hand-side vectors: nrhs = size ( b , 2 ) ! allocate local arrays: allocate ( f ( s ), mu ( s ), alpha ( s ), beta ( s ), gamma ( s )) allocate ( x ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , r ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , v ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) ) allocate ( t ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) , M ( s , s )) allocate ( G ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , s ), U ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , s )) ! Check optional input parameters: if ( present ( tolerance ) ) then if ( tolerance < 0 ) stop \"Illegal value for parameter tolerance\" tol = tolerance else tol = 1e-6 endif maxit = min ( 2 * n , 1000 ) if ( present ( maximum_iterations ) ) maxit = maximum_iterations method = 1 ! biortho if ( present ( variant ) ) then if ( variant == 'minsync' ) then method = 2 elseif ( variant == 'bicgstab' ) then method = 3 endif endif ! Initialize the output variables out_flag = present ( flag ) if ( out_flag ) flag = - 1 out_relres = present ( relres ) if ( out_relres ) relres = 1. out_iterations = present ( iterations ) if ( out_iterations ) iterations = 0 ! Check optional input arrays: x = 0. if ( present ( x0 ) ) x = x0 U = 0. inispace = present ( U0 ) if ( inispace ) U = U0 user_omega = present ( omega ) if ( user_omega ) then n_omega = size ( omega ) end if ! Check output arrays out_resvec = present ( resvec ) if ( out_resvec ) then if ( maxit + 1 > size ( resvec ) ) & stop \"Length of vector with residual norms too small, should be maxit+1\" end if out_H = present ( H ) if ( out_H ) then nritz = size ( H , 1 ) - 1 if ( size ( H , 2 ) /= nritz ) & stop \"Second dimension of H incompatible, with first\" H = 0. end if ! compute initial residual, set absolute tolerance normb = FROB_NORM ( b ) tolb = tol * normb r = b - A * x normr = FROB_NORM ( r ) if ( out_resvec ) resvec ( 1 ) = normr / normb ! check if the initial solution is not already a solution within the prescribed ! tolerance if ( normr <= tolb ) then if ( out_iterations ) iterations = 0 if ( out_flag ) flag = 0 if ( out_relres ) relres = normr / normb return end if ! Define P and kappa (depending on the method) if ( method == 1 ) then allocate ( P ( n , nrhs , s ) ) call RANDOM_SEED call RANDOM_NUMBER ( P ) do j = 1 , s do k = 1 , j - 1 alpha ( k ) = TRACE_DOT ( P (:,:, k ), P (:,:, j ) ) P (:,:, j ) = P (:,:, j ) - alpha ( k ) * P (:,:, k ) end do ! P(:,:,j) = P(:,:,j)/FROB_NORM(P(:,:,j)) P (:,:, j ) = P (:,:, j ) / RFROB_NORM ( P (:,:, j )) end do kappa = 0.7 elseif ( method == 2 ) then ! P is piecewise constant, minimum residual for omega kappa = 0. elseif ( method == 3 ) then if ( s /= 1 ) stop \"s=1 is required for variant bicgstab\" allocate ( R0 ( n , nrhs ) ) R0 = r kappa = 0. endif ! Initialize local variables: M = 0. om = 1. iter = 0 info = - 1 jj = 0 ii = 0 ! This concludes the initialisation phase ! Main iteration loop, build G-spaces: do while ( info < 0 ) ! start of iteration loop !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Generate s vectors in G_j !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! New right-hand side for small system: f = P_DOT ( P , R0 , r , s ) do k = 1 , s ! Update inner iteration counter ii = ii + 1 ! Compute new v v = r if ( jj > 0 ) then ! Solve small system (Note: M is lower triangular) and make v orthogonal to P: do i = k , s gamma ( i ) = f ( i ) do j = k , i - 1 gamma ( i ) = gamma ( i ) - M ( i , j ) * gamma ( j ) end do gamma ( i ) = gamma ( i ) / M ( i , i ) v = v - gamma ( i ) * G (:,:, i ) end do ! Compute new U(:,:,k) t = om * ( v / M1 ) do i = k , s t = t + gamma ( i ) * U (:,:, i ) end do U (:,:, k ) = t ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz ) & H ( ii - s : ii - k , ii ) = - gamma ( k : s ) / beta ( k : s ) else if ( . not . inispace ) then ! Updates for the first s iterations (in G_0): U (:,:, k ) = v / M1 end if ! Compute new G(:,:,k), G(:,:,k) is in space G_j G (:,:, k ) = A * U (:,:, k ) ! Bi-Orthogonalise the new basis vectors: mu = P_DOT ( P , R0 , G (:,:, k ), s ) do i = 1 , k - 1 alpha ( i ) = mu ( i ) do j = 1 , i - 1 alpha ( i ) = alpha ( i ) - M ( i , j ) * alpha ( j ) end do alpha ( i ) = alpha ( i ) / M ( i , i ) G (:,:, k ) = G (:,:, k ) - G (:,:, i ) * alpha ( i ) U (:,:, k ) = U (:,:, k ) - U (:,:, i ) * alpha ( i ) mu ( k : s ) = mu ( k : s ) - M ( k : s , i ) * alpha ( i ) end do M ( k : s , k ) = mu ( k : s ) ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz . and . k > 1 ) & H ( ii - k + 1 : ii - 1 , ii ) = alpha ( 1 : k - 1 ) / beta ( 1 : k - 1 ) ! Break down? if ( abs ( M ( k , k )) <= tiny ( tol ) ) then info = 3 exit end if ! Make r orthogonal to p_i, i = 1..k, update solution and residual beta ( k ) = f ( k ) / M ( k , k ) r = r - beta ( k ) * G (:,:, k ) x = x + beta ( k ) * U (:,:, k ) ! New f = P'*r (first k  components are zero) if ( k < s ) then f ( k + 1 : s ) = f ( k + 1 : s ) - beta ( k ) * M ( k + 1 : s , k ) end if ! Compute Hessenberg matrix? if ( out_H . and . ii <= nritz ) then H ( ii , ii ) = 1. / beta ( k ) l = max ( 1 , ii - s ) H ( l + 1 : ii + 1 , ii ) = ( H ( l + 1 : ii + 1 , ii ) - H ( l : ii , ii )) H ( l : ii + 1 , ii ) = H ( l : ii + 1 , ii ) / om end if ! Check for convergence normr = FROB_NORM ( r ) iter = iter + 1 if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) iter , normr endif if ( out_resvec ) resvec ( iter + 1 ) = normr / normb if ( normr < tolb ) then info = 0 exit elseif ( iter == maxit ) then info = 1 exit end if end do ! Now we have computed s+1 vectors in G_j if ( info >= 0 ) then exit end if !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Compute first residual in G_j+1 !!+++++++++++++++++++++++++++++++++++++++++++++++++++++++ ! Update G-space counter jj = jj + 1 ! Compute first residual in G_j+1 ! Note: r is already perpendicular to P so v = r ! Preconditioning: v = r / M1 t = A * v ! Computation of a new omega if ( user_omega ) then i = mod ( jj , n_omega ) if ( i == 0 ) i = n_omega om = omega ( i ) elseif ( kappa == 0. ) then ! Minimal residual (same as in Bi-CGSTAB): om = TRACE_DOT ( t , r ) / TRACE_DOT ( t , t ) else ! 'Maintaining the convergence': nr = FROB_NORM ( r ) nt = FROB_NORM ( t ) tr = TRACE_DOT ( t , r ) rho = abs ( tr / ( nt * nr )) om = tr / ( nt * nt ) if ( rho < kappa ) then om = om * kappa / rho end if end if if ( abs ( om ) <= epsilon ( tol ) ) then info = 3 exit end if ! Update solution and residual r = r - om * t x = x + om * v ! Check for convergence normr = FROB_NORM ( r ) iter = iter + 1 if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) iter , normr endif if ( out_resvec ) resvec ( iter + 1 ) = normr / normb if ( normr < tolb ) then info = 0 elseif ( iter == maxit ) then info = 1 end if end do ! end of while loop ! Set output parameters r = b - A * x normr = FROB_NORM ( r ) if ( info == 0 . and . normr > tolb ) info = 2 if ( out_iterations ) iterations = iter if ( out_relres ) relres = normr / normb if ( out_flag ) flag = info !----------------------------------idrs_body.f90---------------------------------------! RIDRS = x ! deallocate local arrays: deallocate ( f , mu , alpha , beta , gamma ) deallocate ( x , r , v ) deallocate ( t , M ) deallocate ( G , U ) end function RIDRS end module idrs_module","tags":"","loc":"sourcefile/idrs_module.f90.html"},{"title":"read_setup.f90 – ParaMADP","text":"This file depends on sourcefile~~read_setup.f90~~EfferentGraph sourcefile~read_setup.f90 read_setup.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~read_setup.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~read_setup.f90~~AfferentGraph sourcefile~read_setup.f90 read_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~read_setup.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~read_setup.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~solvers.f90->sourcefile~read_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module read_setup !! This is a module to read the input parameters for the solver settings use mpi use comm_variable implicit none integer , parameter :: NparaMax = 50 !! the maximun number of integer input parameter integer , parameter :: RparaMax = 50 !! the maximun number of real input parameter contains subroutine read_parameter () !! read the input parameters for the solver settings implicit none integer , allocatable , dimension (:) :: Nparameters !! Integer input parameter real ( kind = realdp ), allocatable , dimension (:) :: Rparameters !! Real input parameter character ( len = 64 ) :: arg !! Input filename allocate ( Nparameters ( 1 : NparaMax )) allocate ( Rparameters ( 1 : RparaMax )) Nparameters = 0 Rparameters = 0.d0 !! Read by Rank 0 and then broadcast to the other ranks if ( my_id . eq . 0 ) then call get_command_argument ( 1 , arg ) !! Get the input filename if ( LEN_TRIM ( arg ) == 0 ) then !! The Default input filename is Input/Helmholtz.in arg = 'Input/Helmholtz.in' endif open ( 100 , file = trim ( arg )) read ( 100 , * ) read ( 100 , * ) read ( 100 , * ) nx_global , ny_global , LAP read ( 100 , * ) read ( 100 , * ) npx0 , npy0 read ( 100 , * ) read ( 100 , * ) slx , sly read ( 100 , * ) read ( 100 , * ) Iperiodic_X , Iperiodic_Y read ( 100 , * ) read ( 100 , * ) i_case , flag_BCs read ( 100 , * ) read ( 100 , * ) m_iter , Algorithm , Irestart , eps read ( 100 , * ) read ( 100 , * ) k_case , k0 , freq read ( 100 , * ) read ( 100 , * ) M_flag , M2h_flag , beta1 , beta2 read ( 100 , * ) read ( 100 , * ) MG_flag , def_mg_miter , cslp_mg_miter , nx_min read ( 100 , * ) read ( 100 , * ) def_rtol , cslp_mg_tol read ( 100 , * ) read ( 100 , * ) def_nlevel , Sv_L2 , Sv_L3 , Sv_L4 close ( 100 ) endif Nparameters ( 1 ) = nx_global Nparameters ( 2 ) = ny_global Nparameters ( 3 ) = npx0 Nparameters ( 4 ) = npy0 Nparameters ( 5 ) = Iperiodic_X Nparameters ( 6 ) = Iperiodic_Y Nparameters ( 7 ) = m_iter Nparameters ( 8 ) = Irestart Nparameters ( 9 ) = M_flag Nparameters ( 10 ) = MG_flag Nparameters ( 11 ) = def_mg_miter Nparameters ( 12 ) = nx_min Nparameters ( 13 ) = i_case Nparameters ( 14 ) = flag_BCs Nparameters ( 15 ) = Algorithm Nparameters ( 16 ) = k_case Nparameters ( 17 ) = M2h_flag Nparameters ( 18 ) = cslp_mg_miter Nparameters ( 19 ) = LAP Nparameters ( 20 ) = def_nlevel Nparameters ( 21 ) = Sv_L2 Nparameters ( 22 ) = Sv_L3 Nparameters ( 23 ) = Sv_L4 call MPI_BCAST ( Nparameters , NparaMax , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) Rparameters ( 1 ) = slx Rparameters ( 2 ) = sly Rparameters ( 3 ) = eps Rparameters ( 4 ) = k0 Rparameters ( 5 ) = beta1 Rparameters ( 6 ) = beta2 Rparameters ( 7 ) = freq Rparameters ( 8 ) = def_rtol Rparameters ( 9 ) = cslp_mg_tol call MPI_BCAST ( Rparameters , RparaMax , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) nx_global = Nparameters ( 1 ) ny_global = Nparameters ( 2 ) npx0 = Nparameters ( 3 ) npy0 = Nparameters ( 4 ) Iperiodic_X = Nparameters ( 5 ) Iperiodic_Y = Nparameters ( 6 ) m_iter = Nparameters ( 7 ) Irestart = Nparameters ( 8 ) M_flag = Nparameters ( 9 ) MG_flag = Nparameters ( 10 ) def_mg_miter = Nparameters ( 11 ) nx_min = Nparameters ( 12 ) i_case = Nparameters ( 13 ) flag_BCs = Nparameters ( 14 ) Algorithm = Nparameters ( 15 ) k_case = Nparameters ( 16 ) M2h_flag = Nparameters ( 17 ) cslp_mg_miter = Nparameters ( 18 ) LAP = Nparameters ( 19 ) def_nlevel = Nparameters ( 20 ) Sv_L2 = Nparameters ( 21 ) Sv_L3 = Nparameters ( 22 ) Sv_L4 = Nparameters ( 23 ) slx = Rparameters ( 1 ) sly = Rparameters ( 2 ) eps = Rparameters ( 3 ) k0 = Rparameters ( 4 ) beta1 = Rparameters ( 5 ) beta2 = Rparameters ( 6 ) freq = Rparameters ( 7 ) def_rtol = Rparameters ( 8 ) cslp_mg_tol = Rparameters ( 9 ) call MPI_BARRIER ( MPI_COMM_WORLD , ierr ) deallocate ( Nparameters , Rparameters ) end subroutine read_parameter end module read_setup","tags":"","loc":"sourcefile/read_setup.f90.html"},{"title":"main.f90 – ParaMADP","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~analytical_sol.f90 analytical_sol.f90 sourcefile~main.f90->sourcefile~analytical_sol.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~main.f90->sourcefile~comm_variable.f90 sourcefile~definegrid.f90 DefineGrid.f90 sourcefile~main.f90->sourcefile~definegrid.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~main.f90->sourcefile~mpi_setup.f90 sourcefile~read_setup.f90 read_setup.f90 sourcefile~main.f90->sourcefile~read_setup.f90 sourcefile~rhs.f90 RHS.f90 sourcefile~main.f90->sourcefile~rhs.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~main.f90->sourcefile~wavenumber.f90 sourcefile~write_data.f90 Write_data.f90 sourcefile~main.f90->sourcefile~write_data.f90 sourcefile~analytical_sol.f90->sourcefile~comm_variable.f90 sourcefile~definegrid.f90->sourcefile~comm_variable.f90 sourcefile~idrs_module.f90->sourcefile~comm_variable.f90 sourcefile~idrs_module.f90->sourcefile~mpi_setup.f90 sourcefile~idrs_module.f90->sourcefile~read_setup.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~read_setup.f90->sourcefile~comm_variable.f90 sourcefile~rhs.f90->sourcefile~comm_variable.f90 sourcefile~solvers.f90->sourcefile~comm_variable.f90 sourcefile~solvers.f90->sourcefile~read_setup.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~user_module.f90->sourcefile~comm_variable.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~write_data.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program helmholtz_2d !! Parallel proconditioned Krylov slover for 2D Helmholtz equation use mpi use comm_variable use read_setup use mpi_setup use define_grid use define_rhs use analytical_sol use wavenumber use solvers use write_data use user_module use idrs_module implicit none !Arguements type ( matrix ) :: A !! An empty matrix type for calling idrs solver type ( preconditioner ) :: M1 !! a preconditioner type for calling idrs solver. Since the IDR(s) solver part is ported, its input and output parameters are somewhat different from other solvers. complex ( kind = realdp ), allocatable , dimension (:,:) :: u !! arrays for the solution complex ( kind = realdp ), allocatable , dimension (:,:) :: u_ex !! arrays for exact solution complex ( kind = realdp ), allocatable , dimension (:,:) :: u_err !! arrays for the error of solution complex ( kind = realdp ), allocatable , dimension (:,:) :: b !! arrays for the right-hand side real ( kind = realdp ), allocatable , dimension (:,:) :: xx , yy !! coordinates real ( kind = realdp ), allocatable :: resvec (:) !! Residual vector for idrs solver real ( kind = realdp ) :: time_start !! time_start: variable for runtime measurement start real ( kind = realdp ) :: time_end !! time_end: variable for runtime measurement end real ( kind = realdp ) :: u_err_max !! u_err_max: local max|u_err|=max|u-u_ex| real ( kind = realdp ) :: Aerror !! Aerror: global max|u_err|=max|u-u_ex| real ( kind = realdp ) :: Rerror !! Rerror: relative residual ||b-Au||/||b|| real ( kind = realdp ) :: max_k_local !! max_k_local: local maximum wavenumber real ( kind = realdp ) :: max_k_global !! max_k_global: global maximum wavenumber integer :: iter , k , i , j !! number of iterations and loop indexs integer :: flag !! an output flag for idrs solvers ! Initilize MPI call MPI_INIT ( ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , np_size , ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , my_id , ierr ) ! read parameters from Input/Helmtoltz.in call read_parameter () ! Assess if uniform grid size if ( i_case == 3 . or . i_case == 3 ) then if ( dble ( ny_global - 1 ) / dble ( nx_global - 1 ) /= sly / slx ) then if ( my_id == 0 ) then write ( * , * ) 'I cannot handle non-equal gird so far!!!' endif stop endif endif ! compute grid size hy = sly / dble ( ny_global - 1 ) hx = slx / dble ( nx_global - 1 ) hxhy = hx * hy ! 2D domain patition and MPI setting call part2d () ! variables alllocation and initialization allocate ( u ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), b ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), u_ex ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( xx ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), yy ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( u_err ( 1 : nx , 1 : ny )) allocate ( resvec ( m_iter + 1 )) u = czero b = czero u_ex = czero xx = 0.d0 yy = 0.d0 Rerror = 0.d0 u_err = 0.d0 u_err_max = 0.d0 Aerror = 0.d0 iter = 0 M1 % ni = nx M1 % nj = ny M1 % hx_c = hx M1 % hy_c = hy ! define 2D coordinates for different model problems if ( i_case == 1 ) then call define_uniform_grid ( xx , yy ) elseif ( i_case == 2 ) then call define_uniform_grid ( xx , yy ) elseif ( i_case == 3 ) then call define_wedge_grid ( xx , yy ) elseif ( i_case == 4 ) then call define_marmousi_grid ( xx , yy ) else write ( * , * ) \"No such a case so far!\" stop endif ! Analytical Solutions for two model problems if ( i_case == 1 ) then call exact_2DCloseOff ( u_ex , xx , yy ) elseif ( i_case == 2 ) then if ( flag_BCs == 1 ) then ! Be careful that it will take too much time for large grid size call exact_2DPointSource_Dirichlet ( u_ex , xx , yy ) elseif ( flag_BCs == 2 ) then call exact_2DPointSource_1stSomer ( u_ex , xx , yy ) else write ( * , * ) \"No such a BC!\" stop endif endif ! Define right-hand side if ( i_case == 1 ) then call RHS_2DCloseOff ( b , xx , yy ) elseif ( i_case == 2 ) then call RHS_CenterSource2D ( b , xx , yy ) elseif ( i_case == 3 ) then call RHS_2DWedge ( b , xx , yy ) elseif ( i_case == 4 ) then call RHS_marmousi ( b , xx , yy ) else write ( * , * ) \"No such a case so far!\" stop endif ! Determine constant-wavenumber or non-constant wavenumber problems if ( k_case == 0 ) then call Const_K () else if ( i_case == 3 ) then call wavenumber_k_Wedge ( xx , yy ) elseif ( i_case == 4 ) then call read_wavenumber_k_marmousi () endif endif ! Determine maximum wavenumber max_k_local = maxval ( wavenumber_k ( 1 : nx , 1 : ny )) indf_level = 2 call MPI_ALLREDUCE ( max_k_local , max_k_global , 1 , MPI_DOUBLE_PRECISION , MPI_MAX , MPI_COMM_WORLD , ierr ) ! Calculate the indefinite coarse level approxiamtely indf_level = int ( LOG2 ( 1.5d0 / ( max_k_global * hx ))) + 1 if ( my_id == 0 ) then write ( * , * ) \"kh = \" , max_k_global * hx , \"indf_level = \" , indf_level end if ! Assess the input number of levels for multilevel defiation if ( M_flag == 5 ) then !Samller shift based on dimensionless wavenumber. Uncomment if only Krylov iterations are used for CSLP approxiamtion !beta2 = -1.d0/sqrt(max_k_global*max_k_global*slx*sly) if ( mod ( nx_global - 1 , 2 ** ( def_nlevel - 1 )) /= 0 . or . mod ( ny_global - 1 , 2 ** ( def_nlevel - 1 )) /= 0 ) then write ( * , * ) \"Cannot go to such a deep level!\" endif endif call MPI_BARRIER ( MPI_COMM_WORLD , ierr ) ! Creat an output file ended with iters.plt to record the residual and iterations if ( my_id == 0 ) then call system ( 'mkdir -p Output' ) write ( logname , \"('Output/MP',I1,'BC',I1,'nx',I5.5,'k',I5.5,     & & 'thm',I2.2,'pre',I1,'nldef',I1, & & 'cslptol',I2.2,'deftol',I2.2,'np',I3.3,'iters.plt')\" ) & & i_case , flag_BCs , nx_global , int ( k0 ), & & Algorithm , M_flag , def_nlevel , & & int ( - LOG10 ( cslp_mg_tol )), int ( - LOG10 ( def_rtol )), npx0 * npy0 open ( 1234 , file = trim ( logname ), status = 'REPLACE' ) write ( 1234 , * ) 'variables=iter, res' close ( 1234 ) end if ! Start to call Krylov subspace solvers time_start = MPI_WTIME () ! GMRES if ( Algorithm == 1 ) then if ( M_flag == 0 ) then ! no precondition if ( Irestart == 1 ) then call restartgmres ( b , u , Rerror , iter ) else call fullgmres ( b , u , Rerror , iter ) endif else !left precondition GMRES if ( Irestart == 1 ) then call Pre_restartgmres ( b , u , Rerror , iter ) else call Pre_fullgmres ( b , u , Rerror , iter ) endif endif ! right preconditioned GMRES elseif ( Algorithm == 2 ) then call full_pgmres ( b , u , Rerror , iter ) ! preconditioned fgmres elseif ( Algorithm == 3 ) then call pfgmres ( b , u , Rerror , iter ) ! preconditioned GCR elseif ( Algorithm == 4 ) then call full_pgcr ( b , u , Rerror , iter ) ! IDR(s) elseif ( Algorithm == 21 ) then u = idrs ( A , b , M1 , 1 , eps , m_iter , 'biortho ' , flag , Rerror , iter , resvec = resvec ) elseif ( Algorithm == 24 ) then u = idrs ( A , b , M1 , 4 , eps , m_iter , 'biortho ' , flag , Rerror , iter , resvec = resvec ) elseif ( Algorithm == 28 ) then u = idrs ( A , b , M1 , 8 , eps , m_iter , 'biortho ' , flag , Rerror , iter , resvec = resvec ) elseif ( Algorithm == 31 ) then u = idrs ( A , b , M1 , 1 , eps , m_iter , 'bicgstab' , flag , Rerror , iter , resvec = resvec ) endif time_end = MPI_WTIME () ! Exit from solver ! write the number of iterations, relative residual and runtime if ( my_id == 0 ) then write ( * , \"('Iterations  ', I6, '[Exit!!!]')\" ) iter write ( * , \"('Relative residual=',E16.9)\" ) Rerror write ( * , \"('Time=',E16.9)\" ) time_end - time_start end if ! If idrs, write the residual verus iterations. if ( Algorithm == 21 . or . Algorithm == 24 . or . Algorithm == 28 . or . Algorithm == 31 ) then if ( my_id == 0 ) then open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) do k = 1 , iter write ( 1234 , \"(I9,E17.9)\" ) k , resvec ( k ) enddo close ( 1234 ) end if endif ! Calculate the absolute error max|u-u_ex| ! (if there is no analytical solutions, u_ex=0) u_err = u_ex ( 1 : nx , 1 : ny ) - u ( 1 : nx , 1 : ny ) u_err_max = maxval ( abs ( u_err )) call MPI_Reduce ( u_err_max , & Aerror , & 1 , & MPI_DOUBLE_PRECISION ,& MPI_MAX , & 0 , & mpi_comm_world , & ierr ) ! Output a .dat file, including the number of iterations, runtime, absolute error and relative residual if ( my_id == 0 ) then write ( output_name , \"('Output/MP',I1,'BC',I1,'nx',I5.5,'k',I5.5,     & & 'thm',I2.2,'pre',I1,'nldef',I1, & & 'cslptol',I2.2,'deftol',I2.2,'np',I3.3,'.dat')\" )& & i_case , flag_BCs , nx_global , int ( k0 ), & & Algorithm , M_flag , def_nlevel , & & int ( - LOG10 ( cslp_mg_tol )), int ( - LOG10 ( def_rtol )), npx0 * npy0 open ( 12 , file = trim ( output_name ), status = 'unknown' ) write ( 12 , \"('Total Iterations=',I6)\" ) iter write ( 12 , \"('Time=',E16.9)\" ) time_end - time_start write ( 12 , \"('Absolute Error=',E16.9)\" ) Aerror write ( 12 , \"('Relative Error=',E16.9)\" ) Rerror close ( 12 ) endif ! Write the solution call write_data_whole ( xx , yy , u ) !The field of wavenumber can be obtained as follow ! call write_real_data_whole(xx,yy,wavenumber_k) ! Deallocate wavenumber call wavenumber_k_destroy () ! Deallocate the variables deallocate ( u , b , u_ex , xx , yy , u_err ) ! Finalize MPI call mpi_finalize ( ierr ) end program helmholtz_2d","tags":"","loc":"sourcefile/main.f90.html"},{"title":"boundaries.f90 – ParaMADP","text":"This file depends on sourcefile~~boundaries.f90~~EfferentGraph sourcefile~boundaries.f90 boundaries.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~boundaries.f90~~AfferentGraph sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90 Operators.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module define_BC !! This is a module to deal with the computational stencils for the Dirichlet of Sommerfeld boundary conditions use comm_variable use wavenumber implicit none contains subroutine if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ) !! Determine which BC, for specified coarse grid system implicit none complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as integer , intent ( in ) :: i , j , ni , nj real ( kind = realdp ), intent ( in ) :: hx_c , hy_c , kxy if ( flag_BCs == 1 ) then call Dirichlet ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c ) elseif ( flag_BCs == 2 ) then call first_order_Neum ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ) else write ( * , * ) \"There is no such a boundary conditions yet! Use first_order_Neum instead!!\" call first_order_Neum ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ) endif end subroutine if_BCs subroutine Dirichlet ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c ) !! Dirichlet, ap=h&#94;2, which will devided by h&#94;2 in the rountine of the operator !! When use this Dirichlet, you have to be carefull with the RHS respectively implicit none complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as integer , intent ( in ) :: i , j , ni , nj real ( kind = realdp ), intent ( in ) :: hx_c , hy_c if ( npx == 0 . and . i == 1 ) then ap = hx_c * hy_c + czero ae = 0.d0 aw = 0.d0 an = 0.d0 as = 0.d0 endif if ( npx == npx0 - 1 . and . i == ni ) then ap = hx_c * hy_c + czero ae = 0.d0 aw = 0.d0 an = 0.d0 as = 0.d0 endif if ( npy == 0 . and . j == 1 ) then ap = hx_c * hy_c + czero ae = 0.d0 aw = 0.d0 an = 0.d0 as = 0.d0 endif if ( npy == npy0 - 1 . and . j == nj ) then ap = hx_c * hy_c + czero ae = 0.d0 aw = 0.d0 an = 0.d0 as = 0.d0 endif end subroutine Dirichlet subroutine first_order_Neum ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ) !! Sommerfeld boundary conditions. Eliminate the ghost grid points by second-order discretization implicit none complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as integer , intent ( in ) :: i , j , ni , nj real ( kind = realdp ), intent ( in ) :: hx_c , hy_c , kxy !================================================ if ( npx == 0 . and . i == 1 ) then aw = 0.d0 ae = - 2.d0 ap = ap - 2.d0 * kxy * hx_c * cone !Second-order discretization endif if ( npx == npx0 - 1 . and . i == ni ) then ae = 0.d0 aw = - 2.d0 ap = ap - 2.d0 * kxy * hx_c * cone !Second-order discretization endif if ( npy == 0 . and . j == 1 ) then as = 0.d0 an = - 2.d0 ap = ap - 2.d0 * kxy * hy_c * cone !Second-order discretization endif if ( npy == npy0 - 1 . and . j == nj ) then an = 0.d0 as = - 2.d0 ap = ap - 2.d0 * kxy * hy_c * cone !Second-order discretization endif end subroutine first_order_Neum end module define_BC !=====================================","tags":"","loc":"sourcefile/boundaries.f90.html"},{"title":"deflation_setup.f90 – ParaMADP","text":"This file depends on sourcefile~~deflation_setup.f90~~EfferentGraph sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~deflation_setup.f90~~AfferentGraph sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module deflaion_setup !! This is an integrated module for deflation preconditioning use mpi use comm_variable use mpi_setup use wavenumber , only : wavenumber_k , kh_pow_2 use operators use CSLP_Solver implicit none type , public :: TwoGrids !! Type definition for a two-grid system. \"f\" in variable names stands for fine grid, \"c\" in variable names stands for coarse grid integer ( kind = 4 ) :: nxf_global , nyf_global integer ( kind = 4 ) :: nxf , nyf integer ( kind = 4 ) :: nxc_global , nyc_global integer ( kind = 4 ) :: nxc , nyc real ( kind = realdp ) :: hxf , hyf , hxhyf real ( kind = realdp ) :: hxc , hyc , hxhyc integer , dimension ( 0 : npMax - 1 ) :: if_offset , jf_offset , if_nn , jf_nn integer , dimension ( 0 : npMax - 1 ) :: ic_offset , jc_offset , ic_nn , jc_nn real ( kind = realdp ), allocatable , dimension (:,:) :: kxy_f , kxy_c , kh2_f , kh2_c end type TwoGrids interface TwoGrids procedure :: FromFine2Coarse end interface TwoGrids contains function DEF_Px ( x ) !! Identifier for different deflation methods, ONLY for an input array from the default (finest) grid system implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: x complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: DEF_Px type ( Gridpara ) :: finestgrid type ( TwoGrids ) :: f2c call default_gridpara ( finestgrid ) f2c = TwoGrids ( finestgrid ) select case ( M_flag ) case ( 2 ) DEF_Px = P_DEFx ( x , f2c ) !! A basic deflation method case ( 3 ) DEF_Px = P_ADEF1x ( x , f2c ) !! Adapted deflation method, including higher-order deflation vectors case ( 4 ) DEF_Px = P_TLKMx ( x , f2c ) !! Two-level Krylov Method case ( 5 ) DEF_Px = MultiLevelADP_Px ( x , finestgrid ) !! Multilevel deflation method case default DEF_Px = P_ADEF1x ( x , f2c ) end select deallocate ( f2c % kxy_f , f2c % kh2_f , f2c % kxy_c , f2c % kh2_c ) deallocate ( finestgrid % wavenumber_k , finestgrid % wavenumber_kh_pow_2 ) end function DEF_Px subroutine default_gridpara ( finestgrid ) !! This is a rountine to define the default finest Gridpara from the common grid parameters of the whole project implicit none type ( Gridpara ), intent ( inout ) :: finestgrid finestgrid % nx_global = nx_global finestgrid % ny_global = ny_global finestgrid % hx = hx finestgrid % hy = hy finestgrid % hxhy = hx * hy finestgrid % nx = nx finestgrid % ny = ny finestgrid % i_offset = i_offset finestgrid % j_offset = j_offset finestgrid % i_nn = i_nn finestgrid % j_nn = j_nn allocate ( finestgrid % wavenumber_k ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( finestgrid % wavenumber_kh_pow_2 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) finestgrid % wavenumber_k = wavenumber_k finestgrid % wavenumber_kh_pow_2 = kh_pow_2 end subroutine default_gridpara type ( TwoGrids ) function FromFine2Coarse ( OneGrid ) !! A procedure to create a two-grid system from a given fine Gridpara type implicit none type ( Gridpara ), intent ( inout ) :: OneGrid integer ( kind = 4 ) :: k FromFine2Coarse % nxf_global = OneGrid % nx_global FromFine2Coarse % nyf_global = OneGrid % ny_global FromFine2Coarse % hxf = OneGrid % hx FromFine2Coarse % hyf = OneGrid % hy FromFine2Coarse % hxhyf = OneGrid % hxhy FromFine2Coarse % nxf = OneGrid % nx FromFine2Coarse % nyf = OneGrid % ny FromFine2Coarse % if_offset = OneGrid % i_offset FromFine2Coarse % jf_offset = OneGrid % j_offset FromFine2Coarse % if_nn = OneGrid % i_nn FromFine2Coarse % jf_nn = OneGrid % j_nn allocate ( FromFine2Coarse % kxy_f ( 1 - LAP : FromFine2Coarse % nxf + LAP , 1 - LAP : FromFine2Coarse % nyf + LAP )) FromFine2Coarse % kxy_f = OneGrid % wavenumber_k allocate ( FromFine2Coarse % kh2_f ( 1 - LAP : FromFine2Coarse % nxf + LAP , 1 - LAP : FromFine2Coarse % nyf + LAP )) FromFine2Coarse % kh2_f = OneGrid % wavenumber_kh_pow_2 FromFine2Coarse % nxc_global = ( OneGrid % nx_global - 1 ) / 2 + 1 FromFine2Coarse % nyc_global = ( OneGrid % ny_global - 1 ) / 2 + 1 FromFine2Coarse % hxc = slx / ( FromFine2Coarse % nxc_global - 1 ) FromFine2Coarse % hyc = sly / ( FromFine2Coarse % nyc_global - 1 ) FromFine2Coarse % hxhyc = FromFine2Coarse % hxc * FromFine2Coarse % hyc if ( mod ( OneGrid % i_offset ( npx ), 2 ) == 0 ) then if ( mod ( OneGrid % nx , 2 ) == 0 ) then FromFine2Coarse % nxc = OneGrid % nx / 2 else FromFine2Coarse % nxc = ( OneGrid % nx - 1 ) / 2 endif else if ( mod ( OneGrid % nx , 2 ) == 0 ) then FromFine2Coarse % nxc = OneGrid % nx / 2 else FromFine2Coarse % nxc = ( OneGrid % nx + 1 ) / 2 endif endif if ( mod ( OneGrid % j_offset ( npy ), 2 ) == 0 ) then if ( mod ( OneGrid % ny , 2 ) == 0 ) then FromFine2Coarse % nyc = OneGrid % ny / 2 else FromFine2Coarse % nyc = ( OneGrid % ny - 1 ) / 2 endif else if ( mod ( OneGrid % ny , 2 ) == 0 ) then FromFine2Coarse % nyc = OneGrid % ny / 2 else FromFine2Coarse % nyc = ( OneGrid % ny + 1 ) / 2 endif endif do k = 0 , npx0 - 1 if ( mod ( OneGrid % i_offset ( k ), 2 ) == 0 ) then FromFine2Coarse % ic_offset ( k ) = ( OneGrid % i_offset ( k ) + 1 + 1 ) / 2 if ( mod ( OneGrid % i_nn ( k ), 2 ) == 0 ) then FromFine2Coarse % ic_nn ( k ) = OneGrid % i_nn ( k ) / 2 else FromFine2Coarse % ic_nn ( k ) = ( OneGrid % i_nn ( k ) - 1 ) / 2 endif else FromFine2Coarse % ic_offset ( k ) = ( OneGrid % i_offset ( k ) + 1 ) / 2 if ( mod ( OneGrid % i_nn ( k ), 2 ) == 0 ) then FromFine2Coarse % ic_nn ( k ) = OneGrid % i_nn ( k ) / 2 else FromFine2Coarse % ic_nn ( k ) = ( OneGrid % i_nn ( k ) + 1 ) / 2 endif endif enddo do k = 0 , npy0 - 1 if ( mod ( OneGrid % j_offset ( k ), 2 ) == 0 ) then FromFine2Coarse % jc_offset ( k ) = ( OneGrid % j_offset ( k ) + 1 + 1 ) / 2 if ( mod ( OneGrid % j_nn ( k ), 2 ) == 0 ) then FromFine2Coarse % jc_nn ( k ) = OneGrid % j_nn ( k ) / 2 else FromFine2Coarse % jc_nn ( k ) = ( OneGrid % j_nn ( k ) - 1 ) / 2 endif else FromFine2Coarse % jc_offset ( k ) = ( OneGrid % j_offset ( k ) + 1 ) / 2 if ( mod ( OneGrid % j_nn ( k ), 2 ) == 0 ) then FromFine2Coarse % jc_nn ( k ) = OneGrid % j_nn ( k ) / 2 else FromFine2Coarse % jc_nn ( k ) = ( OneGrid % j_nn ( k ) + 1 ) / 2 endif endif enddo allocate ( FromFine2Coarse % kxy_c ( 1 - LAP : FromFine2Coarse % nxc + LAP , 1 - LAP : FromFine2Coarse % nyc + LAP )) call wavenumber_FWrestriction ( FromFine2Coarse ) !! The wavenumber of the coarse level is restricted from the fine level allocate ( FromFine2Coarse % kh2_c ( 1 - LAP : FromFine2Coarse % nxc + LAP , 1 - LAP : FromFine2Coarse % nyc + LAP )) FromFine2Coarse % kh2_c = 0.d0 !This is for safe FromFine2Coarse % kh2_c = FromFine2Coarse % kxy_c * FromFine2Coarse % kxy_c * FromFine2Coarse % hxhyc return end function FromFine2Coarse subroutine wavenumber_FWrestriction ( f2c ) !! This routine obtains the wavenumber of the coarse level by full-weight restriction from the fine level implicit none type ( TwoGrids ), intent ( inout ) :: f2c integer :: ii , jj , iif , jjf , icH_global , jcH_global , ifh_global , jfh_global call mg_checkreal_xy2d ( f2c % kxy_f , f2c % nxf , f2c % nyf ) call mg_checkreal_xy2d ( f2c % kh2_f , f2c % nxf , f2c % nyf ) ! Before adding the next line, MP2BC1_nx65k40_pre3_ReD-Glk_DirAveGhost_np4 is not consistent even diverge. f2c % kxy_c = 0.d0 !This is the most significant line do jj = 1 , f2c % nyc do ii = 1 , f2c % nxc icH_global = f2c % ic_offset ( npx ) - 1 + ii jcH_global = f2c % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( f2c % if_offset ( npx ) - 1 ) jjf = jfh_global - ( f2c % jf_offset ( npy ) - 1 ) f2c % kxy_c ( ii , jj ) = ( 4.d0 * f2c % kxy_f ( iif , jjf ) & + 2.d0 * f2c % kxy_f ( iif - 1 , jjf ) + 2.d0 * f2c % kxy_f ( iif + 1 , jjf ) & + 2.d0 * f2c % kxy_f ( iif , jjf - 1 ) + 2.d0 * f2c % kxy_f ( iif , jjf + 1 ) & + 1.d0 * f2c % kxy_f ( iif - 1 , jjf - 1 ) + 1.d0 * f2c % kxy_f ( iif - 1 , jjf + 1 ) & + 1.d0 * f2c % kxy_f ( iif + 1 , jjf - 1 ) + 1.d0 * f2c % kxy_f ( iif + 1 , jjf + 1 )) / 1 6.d0 if ( npx == 0 . and . ii == 1 ) then f2c % kxy_c ( ii , jj ) = f2c % kxy_f ( iif , jjf ) endif if ( npx == npx0 - 1 . and . ii == f2c % nxc ) then f2c % kxy_c ( ii , jj ) = f2c % kxy_f ( iif , jjf ) endif if ( npy == 0 . and . jj == 1 ) then f2c % kxy_c ( ii , jj ) = f2c % kxy_f ( iif , jjf ) endif if ( npy == npy0 - 1 . and . jj == f2c % nyc ) then f2c % kxy_c ( ii , jj ) = f2c % kxy_f ( iif , jjf ) endif enddo enddo if ( npx == 0 . and . npy == 0 ) then f2c % kxy_c ( 1 , 1 ) = f2c % kxy_f ( 1 , 1 ) endif if ( npx == npx0 - 1 . and . npy == 0 ) then f2c % kxy_c ( f2c % nxc , 1 ) = f2c % kxy_f ( f2c % nxf , 1 ) endif if ( npx == 0 . and . npy == npy0 - 1 ) then f2c % kxy_c ( 1 , f2c % nyc ) = f2c % kxy_f ( 1 , f2c % nyf ) endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then f2c % kxy_c ( f2c % nxc , f2c % nyc ) = f2c % kxy_f ( f2c % nxf , f2c % nyf ) endif call mg_checkreal_xy2d ( f2c % kxy_c , f2c % nxc , f2c % nyc ) end subroutine wavenumber_FWrestriction type ( Gridpara ) function CoarseGridpara ( f2c ) !! A procedure to create a Gridpara type of the coarse grid system from a given a two-grid system implicit none type ( TwoGrids ), intent ( inout ) :: f2c CoarseGridpara % nx_global = f2c % nxc_global CoarseGridpara % ny_global = f2c % nyc_global CoarseGridpara % hx = f2c % hxc CoarseGridpara % hy = f2c % hyc CoarseGridpara % hxhy = f2c % hxhyc CoarseGridpara % nx = f2c % nxc CoarseGridpara % ny = f2c % nyc CoarseGridpara % i_offset = f2c % ic_offset CoarseGridpara % j_offset = f2c % jc_offset CoarseGridpara % i_nn = f2c % ic_nn CoarseGridpara % j_nn = f2c % jc_nn allocate ( CoarseGridpara % wavenumber_k ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) CoarseGridpara % wavenumber_k = f2c % kxy_c allocate ( CoarseGridpara % wavenumber_kh_pow_2 ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) CoarseGridpara % wavenumber_kh_pow_2 = f2c % kh2_c end function CoarseGridpara function ZTx ( x , f2c ) !! Restriction of a variable, by full-weight restriction or higher-order restriction depending on the laylers of overlapping grid points used. implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: ZTx ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) integer :: ii , jj , iif , jjf , icH_global , jcH_global , ifh_global , jfh_global x ( 1 - LAP : 0 ,:) = czero x (:, 1 - LAP : 0 ) = czero x ( f2c % nxf + 1 : f2c % nxf + LAP ,:) = czero x (:, f2c % nyf + 1 : f2c % nyf + LAP ) = czero call mg_check_xy2d ( x , f2c % nxf , f2c % nyf ) ZTx = czero if ( LAP == 1 ) then do jj = 1 , f2c % nyc do ii = 1 , f2c % nxc icH_global = f2c % ic_offset ( npx ) - 1 + ii jcH_global = f2c % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( f2c % if_offset ( npx ) - 1 ) jjf = jfh_global - ( f2c % jf_offset ( npy ) - 1 ) ZTx ( ii , jj ) = ( 4.d0 * x ( iif , jjf ) & + 2.d0 * x ( iif - 1 , jjf ) + 2.d0 * x ( iif + 1 , jjf ) & + 2.d0 * x ( iif , jjf - 1 ) + 2.d0 * x ( iif , jjf + 1 ) & + 1.d0 * x ( iif - 1 , jjf - 1 ) + 1.d0 * x ( iif - 1 , jjf + 1 ) & + 1.d0 * x ( iif + 1 , jjf - 1 ) + 1.d0 * x ( iif + 1 , jjf + 1 )) / 4.d0 if ( npx == 0 . and . ii == 1 ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npx == npx0 - 1 . and . ii == f2c % nxc ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npy == 0 . and . jj == 1 ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npy == npy0 - 1 . and . jj == f2c % nyc ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif enddo enddo else do jj = 1 , f2c % nyc do ii = 1 , f2c % nxc icH_global = f2c % ic_offset ( npx ) - 1 + ii jcH_global = f2c % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( f2c % if_offset ( npx ) - 1 ) jjf = jfh_global - ( f2c % jf_offset ( npy ) - 1 ) ZTx ( ii , jj ) = ( 1.d0 * x ( iif - 2 , jjf + 2 ) + 4.d0 * x ( iif - 1 , jjf + 2 ) + 6.d0 * x ( iif , jjf + 2 ) & + 4.d0 * x ( iif + 1 , jjf + 2 ) + 1.d0 * x ( iif + 2 , jjf + 2 ) & + 4.d0 * x ( iif - 2 , jjf + 1 ) + 1 6.d0 * x ( iif - 1 , jjf + 1 ) + 2 4.d0 * x ( iif , jjf + 1 ) & + 1 6.d0 * x ( iif + 1 , jjf + 1 ) + 4.d0 * x ( iif + 2 , jjf + 1 ) & + 6.d0 * x ( iif - 2 , jjf ) + 2 4.d0 * x ( iif - 1 , jjf ) + 3 6.d0 * x ( iif , jjf ) & + 2 4.d0 * x ( iif + 1 , jjf ) + 6.d0 * x ( iif + 2 , jjf ) & + 4.d0 * x ( iif - 2 , jjf - 1 ) + 1 6.d0 * x ( iif - 1 , jjf - 1 ) + 2 4.d0 * x ( iif , jjf - 1 ) & + 1 6.d0 * x ( iif + 1 , jjf - 1 ) + 4.d0 * x ( iif + 2 , jjf - 1 ) & + 1.d0 * x ( iif - 2 , jjf - 2 ) + 4.d0 * x ( iif - 1 , jjf - 2 ) + 6.d0 * x ( iif , jjf - 2 ) & + 4.d0 * x ( iif + 1 , jjf - 2 ) + 1.d0 * x ( iif + 2 , jjf - 2 )) / 6 4.d0 if ( npx == 0 . and . ii == 1 ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npx == npx0 - 1 . and . ii == f2c % nxc ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npy == 0 . and . jj == 1 ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif if ( npy == npy0 - 1 . and . jj == f2c % nyc ) then ZTx ( ii , jj ) = x ( iif , jjf ) endif enddo enddo endif if ( npx == 0 . and . npy == 0 ) then ZTx ( 1 , 1 ) = x ( 1 , 1 ) endif if ( npx == npx0 - 1 . and . npy == 0 ) then ZTx ( f2c % nxc , 1 ) = x ( f2c % nxf , 1 ) endif if ( npx == 0 . and . npy == npy0 - 1 ) then ZTx ( 1 , f2c % nyc ) = x ( 1 , f2c % nyf ) endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then ZTx ( f2c % nxc , f2c % nyc ) = x ( f2c % nxf , f2c % nyf ) endif end function ZTx function Zx ( x , f2c ) !! Interpolation of a variable from coarse to fine, by bilinear or higher-order interpolation depending on the laylers of overlapping grid points used. implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ) :: Zx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) integer :: ii , jj , iif , jjf , icH_global , jcH_global , ifh_global , jfh_global Zx = czero x ( 1 - LAP : 0 ,:) = czero x (:, 1 - LAP : 0 ) = czero x ( f2c % nxc + 1 : f2c % nxc + LAP ,:) = czero x (:, f2c % nyc + 1 : f2c % nyc + LAP ) = czero call mg_check_xy2d ( x , f2c % nxc , f2c % nyc ) if ( LAP == 1 ) then do jj = 1 , f2c % nyc do ii = 1 , f2c % nxc icH_global = f2c % ic_offset ( npx ) - 1 + ii jcH_global = f2c % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( f2c % if_offset ( npx ) - 1 ) jjf = jfh_global - ( f2c % jf_offset ( npy ) - 1 ) Zx ( iif , jjf ) = x ( ii , jj ) Zx ( iif , jjf + 1 ) = ( x ( ii , jj ) + x ( ii , jj + 1 )) / 2.d0 Zx ( iif , jjf - 1 ) = ( x ( ii , jj ) + x ( ii , jj - 1 )) / 2.d0 Zx ( iif + 1 , jjf ) = ( x ( ii , jj ) + x ( ii + 1 , jj )) / 2.d0 Zx ( iif - 1 , jjf ) = ( x ( ii , jj ) + x ( ii - 1 , jj )) / 2.d0 Zx ( iif + 1 , jjf + 1 ) = ( x ( ii + 1 , jj ) + x ( ii , jj + 1 ) & + x ( ii + 1 , jj + 1 ) + x ( ii , jj )) / 4.d0 Zx ( iif + 1 , jjf - 1 ) = ( x ( ii + 1 , jj ) + x ( ii , jj - 1 ) & + x ( ii + 1 , jj - 1 ) + x ( ii , jj )) / 4.d0 Zx ( iif - 1 , jjf + 1 ) = ( x ( ii - 1 , jj ) + x ( ii , jj + 1 ) & + x ( ii - 1 , jj + 1 ) + x ( ii , jj )) / 4.d0 Zx ( iif - 1 , jjf - 1 ) = ( x ( ii - 1 , jj ) + x ( ii , jj - 1 ) & + x ( ii - 1 , jj - 1 ) + x ( ii , jj )) / 4.d0 enddo enddo else do jj = 1 , f2c % nyc do ii = 1 , f2c % nxc icH_global = f2c % ic_offset ( npx ) - 1 + ii jcH_global = f2c % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( f2c % if_offset ( npx ) - 1 ) jjf = jfh_global - ( f2c % jf_offset ( npy ) - 1 ) Zx ( iif , jjf ) = ( 1.d0 * x ( ii - 1 , jj - 1 ) + 6.d0 * x ( ii , jj - 1 ) + 1.d0 * x ( ii + 1 , jj - 1 ) & + 6.d0 * x ( ii - 1 , jj ) + 3 6.d0 * x ( ii , jj ) + 6.d0 * x ( ii + 1 , jj ) & + 1.d0 * x ( ii - 1 , jj + 1 ) + 6.d0 * x ( ii , jj + 1 ) + 1.d0 * x ( ii + 1 , jj + 1 )) * 0.015625d0 Zx ( iif , jjf + 1 ) = ( 1.d0 * x ( ii - 1 , jj ) + 6.d0 * x ( ii , jj ) + 1.d0 * x ( ii + 1 , jj ) & + 1.d0 * x ( ii - 1 , jj + 1 ) + 6.d0 * x ( ii , jj + 1 ) + 1.d0 * x ( ii + 1 , jj + 1 )) * 0.0625d0 Zx ( iif , jjf - 1 ) = ( 1.d0 * x ( ii - 1 , jj ) + 6.d0 * x ( ii , jj ) + 1.d0 * x ( ii + 1 , jj ) & + 1.d0 * x ( ii - 1 , jj - 1 ) + 6.d0 * x ( ii , jj - 1 ) + 1.d0 * x ( ii + 1 , jj - 1 )) * 0.0625d0 Zx ( iif + 1 , jjf ) = ( 1.d0 * x ( ii , jj - 1 ) + 6.d0 * x ( ii , jj ) + 1.d0 * x ( ii , jj + 1 ) & + 1.d0 * x ( ii + 1 , jj - 1 ) + 6.d0 * x ( ii + 1 , jj ) + 1.d0 * x ( ii + 1 , jj + 1 )) * 0.0625d0 Zx ( iif - 1 , jjf ) = ( 1.d0 * x ( ii , jj - 1 ) + 6.d0 * x ( ii , jj ) + 1.d0 * x ( ii , jj + 1 ) & + 1.d0 * x ( ii - 1 , jj - 1 ) + 6.d0 * x ( ii - 1 , jj ) + 1.d0 * x ( ii - 1 , jj + 1 )) * 0.0625d0 Zx ( iif + 1 , jjf + 1 ) = ( x ( ii + 1 , jj ) + x ( ii , jj + 1 ) & + x ( ii + 1 , jj + 1 ) + x ( ii , jj )) * 0.25d0 Zx ( iif + 1 , jjf - 1 ) = ( x ( ii + 1 , jj ) + x ( ii , jj - 1 ) & + x ( ii + 1 , jj - 1 ) + x ( ii , jj )) * 0.25d0 Zx ( iif - 1 , jjf + 1 ) = ( x ( ii - 1 , jj ) + x ( ii , jj + 1 ) & + x ( ii - 1 , jj + 1 ) + x ( ii , jj )) * 0.25d0 Zx ( iif - 1 , jjf - 1 ) = ( x ( ii - 1 , jj ) + x ( ii , jj - 1 ) & + x ( ii - 1 , jj - 1 ) + x ( ii , jj )) * 0.25d0 if ( npx == 0 . and . ii == 1 ) then Zx ( iif , jjf ) = ( x ( ii , jj - 1 ) + 6.d0 * x ( ii , jj ) + x ( ii , jj + 1 )) * 0.125d0 Zx ( iif , jjf + 1 ) = ( x ( ii , jj ) + x ( ii , jj + 1 )) * 0.5d0 Zx ( iif , jjf - 1 ) = ( x ( ii , jj ) + x ( ii , jj - 1 )) * 0.5d0 endif if ( npx == npx0 - 1 . and . ii == f2c % nxc ) then Zx ( iif , jjf ) = ( x ( ii , jj - 1 ) + 6.d0 * x ( ii , jj ) + x ( ii , jj + 1 )) * 0.125d0 Zx ( iif , jjf + 1 ) = ( x ( ii , jj ) + x ( ii , jj + 1 )) * 0.5d0 Zx ( iif , jjf - 1 ) = ( x ( ii , jj ) + x ( ii , jj - 1 )) * 0.5d0 endif if ( npy == 0 . and . jj == 1 ) then Zx ( iif , jjf ) = ( x ( ii - 1 , jj ) + 6.d0 * x ( ii , jj ) + x ( ii + 1 , jj )) * 0.125d0 Zx ( iif + 1 , jjf ) = ( x ( ii + 1 , jj ) + x ( ii , jj )) * 0.5d0 Zx ( iif - 1 , jjf ) = ( x ( ii - 1 , jj ) + x ( ii , jj )) * 0.5d0 endif if ( npy == npy0 - 1 . and . jj == f2c % nyc ) then Zx ( iif , jjf ) = ( x ( ii - 1 , jj ) + 6.d0 * x ( ii , jj ) + x ( ii + 1 , jj )) * 0.125d0 Zx ( iif + 1 , jjf ) = ( x ( ii + 1 , jj ) + x ( ii , jj )) * 0.5d0 Zx ( iif - 1 , jjf ) = ( x ( ii - 1 , jj ) + x ( ii , jj )) * 0.5d0 endif enddo enddo if ( npx == 0 . and . npy == 0 ) then Zx ( 1 , 1 ) = x ( 1 , 1 ) endif if ( npx == npx0 - 1 . and . npy == 0 ) then Zx ( f2c % nxf , 1 ) = x ( f2c % nxc , 1 ) endif if ( npx == 0 . and . npy == npy0 - 1 ) then Zx ( 1 , f2c % nyf ) = x ( 1 , f2c % nyc ) endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then Zx ( f2c % nxf , f2c % nyf ) = x ( f2c % nxc , f2c % nyc ) endif endif end function Zx function ZTZx ( x , f2c ) !! A routine that first perform restriction and then interpolation implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ) :: ZTZx ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: temp allocate ( temp ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) temp = czero ZTZx = czero temp = Zx ( x , f2c ) ZTZx = ZTx ( temp , f2c ) deallocate ( temp ) end function ZTZx function Helm_Ahx ( x , f2c ) !! A function that performs the Helmholtz operator on the fine grid of the two-grid system, by ReD-O2 method implicit none !input type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) !output complex ( kind = realdp ) :: Helm_Ahx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) Helm_Ahx = czero call Helmholtz2d_BC_mg ( x , Helm_Ahx , f2c % nxf , f2c % nyf , f2c % hxf , f2c % hyf , f2c % kxy_f , f2c % kh2_f ) end function function Helm_A2hx ( x , f2c ) !! A function that performs the Helmholtz operator on the coarse grid of the two-grid system, by different methods implicit none !input type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) !output complex ( kind = realdp ) :: Helm_A2hx ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) Helm_A2hx = czero A2h_flag = 2 select case ( A2h_flag ) case ( 1 ) !! ReD-O2 call Helmholtz2d_BC_mg ( x , Helm_A2hx , f2c % nxc , f2c % nyc , f2c % hxc , f2c % hyc , f2c % kxy_c , f2c % kh2_c ) case ( 2 ) !! ReD-Glk call Helmholtz2d_ReD_Glk ( x , Helm_A2hx , f2c ) case ( 3 ) !! ReD-cmpO4 call Helmholtz2d_O4cmpct ( x , Helm_A2hx , f2c ) case default call Helmholtz2d_BC_mg ( x , Helm_A2hx , f2c % nxc , f2c % nyc , f2c % hxc , f2c % hyc , f2c % kxy_c , f2c % kh2_c ) end select end function Helm_A2hx function Ex ( x , f2c ) !! Coarse-grid operation for two-level deflation implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ) :: Ex ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) type ( Gridpara ) :: CurrentGrid complex ( kind = realdp ), allocatable , dimension (:,:) :: temp integer ( kind = 4 ) :: re_A2h !! Flag for using Re-descretization approach (1) or not (0) CurrentGrid = CoarseGridpara ( f2c ) Ex = czero re_A2h = 1 if ( re_A2h == 0 ) then !! Straight-forward Galerkin coarsening approach allocate ( temp ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) temp = czero temp = Zx ( x , f2c ) !temp = Z x temp = Helm_Ahx ( temp , f2c ) !temp = A_h Z x Ex = ZTx ( temp , f2c ) !Ex = (Z&#94;T A_h Z) x deallocate ( temp ) else if ( M_flag == 4 ) then Ex = Helm_A2hx ( x , f2c ) Ex = MGCSLP_invMHx ( Ex , CurrentGrid ) Ex = ZTZx ( Ex , f2c ) else Ex = Helm_A2hx ( x , f2c ) endif endif deallocate ( CurrentGrid % wavenumber_k , CurrentGrid % wavenumber_kh_pow_2 ) end function Ex function invEy ( y , f2c ) !! Invert the coarse-grid operator for two-level delfation method, by using GMRES or Bi-CGSTAB implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: y ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ) :: invEy ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) invEy = czero if ( def_mg_miter > 1 ) then !! determined by the specified maximum number of iterations on the coarse grid call DEF_fullgmres ( y , invEy , f2c ) else call DEF_bicgstab ( y , invEy , f2c ) endif end function recursive function MultiLevel_invEy ( y , f2c ) !! A recursive function to invert the coarse-level operators for multilevel delfation methods, by using preconditioned FGMRES implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: y ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ) :: MultiLevel_invEy ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) integer ( kind = 4 ) :: level_i level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( f2c % nxc_global - 1 )))) + 1 MultiLevel_invEy = czero if ( level_i == 2 . and . Sv_L2 < 9.9d0 ) then if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[START]\" endif call DEF_prefgmres ( y , MultiLevel_invEy , f2c , level = level_i , rtol = dble ( Sv_L2 ) * 1.d-1 ) if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[FINISH]\" endif elseif ( level_i == 3 . and . Sv_L3 < 9.9d0 ) then if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[START]\" endif call DEF_prefgmres ( y , MultiLevel_invEy , f2c , level = level_i , rtol = dble ( Sv_L3 ) * 1.d-1 ) if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[FINISH]\" endif elseif ( level_i == 4 . and . Sv_L4 < 9.9d0 ) then if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[START]\" endif call DEF_prefgmres ( y , MultiLevel_invEy , f2c , level = level_i , rtol = dble ( Sv_L4 ) * 1.d-1 ) if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[FINISH]\" endif else if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[START]\" endif call DEF_prefgmres ( y , MultiLevel_invEy , f2c , maximum_iterations = 1 , level = level_i ) if ( my_id == 0 ) then write ( * , * ) \"Smoothing the coarser level\" , level_i , \"........................[FINISH]\" endif endif end function function Qx ( x , f2c ) !! Perform y=Qx in deflation definition, where Q=ZE&#94;(-1)Z&#94;T implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: Qx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: temp allocate ( temp ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) temp = czero Qx = czero temp = ZTx ( x , f2c ) !temp = Z&#94;T x temp = invEy ( temp , f2c ) ! temp = E&#94;{-1} Z&#94;T x Qx = Zx ( temp , f2c ) ! Qx = (Z E&#94;{-1} Z&#94;T) x deallocate ( temp ) end function Qx function Px ( x , f2c ) !! Perform y=Px in deflation definition, where P=I-AQ implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: Px ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: temp allocate ( temp ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) temp = czero Px = czero temp = Qx ( x , f2c ) Px = x - Helm_Ahx ( temp , f2c ) deallocate ( temp ) end function Px function P_DEFx ( x , f2c ) !! Deflation preconditioning, P = (I-AQ)+Q implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: P_DEFx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: temp allocate ( temp ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) temp = czero P_DEFx = czero temp = Qx ( x , f2c ) P_DEFx = x - Helm_Ahx ( temp , f2c ) + temp deallocate ( temp ) end function P_DEFx function P_ADEF1x ( x , f2c ) !! Adapted Deflation Preconditioning, P = M&#94;(-1)(I-AQ)+Q, including higher-order deflation (ADP) if LAP > 1 implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: P_ADEF1x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: temp allocate ( temp ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) temp = czero P_ADEF1x = czero temp = Qx ( x , f2c ) P_ADEF1x = x - Helm_Ahx ( temp , f2c ) P_ADEF1x = MGCSLP_invMx ( P_ADEF1x ) P_ADEF1x = P_ADEF1x + temp deallocate ( temp ) end function P_ADEF1x recursive function MultiLevelADP_Px ( x , grid ) !! Multilevel deflation preconditioning (MADP) implicit none type ( Gridpara ), intent ( inout ) :: grid complex ( kind = realdp ) :: x ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) complex ( kind = realdp ) :: MultiLevelADP_Px ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) type ( TwoGrids ) :: present_f2c complex ( kind = realdp ), allocatable , dimension (:,:) :: tmp_Qx complex ( kind = realdp ), allocatable , dimension (:,:) :: tmp_OnCoarse integer ( kind = 4 ) :: level_i level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 if ( level_i > def_nlevel - 1 ) then write ( * , * ) \"The coarsening goes too far!!\" stop else !coarsen if ( mod ( grid % nx_global - 1 , 2 ) /= 0 . or . mod ( grid % ny_global - 1 , 2 ) /= 0 ) then write ( * , * ) \"Coarsen exceed!\" stop endif present_f2c = TwoGrids ( grid ) allocate ( tmp_Qx ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP )) allocate ( tmp_OnCoarse ( 1 - LAP : present_f2c % nxc + LAP , 1 - LAP : present_f2c % nyc + LAP )) tmp_Qx = czero tmp_OnCoarse = czero MultiLevelADP_Px = czero tmp_OnCoarse = ZTx ( x , present_f2c ) !Z&#94;T x tmp_OnCoarse = MultiLevel_invEy ( tmp_OnCoarse , present_f2c ) ! solve y = E&#94;{-1} (Z&#94;T x) tmp_Qx = Zx ( tmp_OnCoarse , present_f2c ) ! Z E&#94;{-1} Z&#94;T x MultiLevelADP_Px = x - Helm_Ax_nth ( tmp_Qx , grid ) if ( level_i < 3 ) then !! Multigrid-based CSLP on the finest and second level MultiLevelADP_Px = MGCSLP_invMHx ( MultiLevelADP_Px , grid ) else !! Krylov-based CSLP on the finest and second level MultiLevelADP_Px = KrylovCSLP_invMHx ( MultiLevelADP_Px , grid ) endif MultiLevelADP_Px = MultiLevelADP_Px + tmp_Qx deallocate ( tmp_Qx , tmp_OnCoarse ) deallocate ( present_f2c % kxy_f , present_f2c % kh2_f , present_f2c % kxy_c , present_f2c % kh2_c ) endif end function MultiLevelADP_Px function P_TLKMx ( x , f2c ) !! Two-Level Krylov Method, P = [(I-M&#94;(-1)AQ`)+Q`]M&#94;(-1), where Q' is defined based on M&#94;(-1)A implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ) :: P_TLKMx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP ) complex ( kind = realdp ), allocatable , dimension (:,:) :: invMx , Q_invMx , invMA_Q_invMx allocate ( invMx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) allocate ( Q_invMx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) allocate ( invMA_Q_invMx ( 1 - LAP : f2c % nxf + LAP , 1 - LAP : f2c % nyf + LAP )) invMx = czero Q_invMx = czero invMA_Q_invMx = czero P_TLKMx = czero invMx = MGCSLP_invMx ( x ) !! M&#94;(-1)x Q_invMx = Qx ( invMx , f2c ) !! QM&#94;(-1)x invMA_Q_invMx = Helm_Ahx ( Q_invMx , f2c ) !! AQM&#94;(-1)x invMA_Q_invMx = MGCSLP_invMx ( invMA_Q_invMx ) !! M&#94;(-1)AQM&#94;(-1)x P_TLKMx = invMx - invMA_Q_invMx + Q_invMx !! [(I-M&#94;(-1)AQ)+Q]M&#94;(-1) deallocate ( invMx , Q_invMx , invMA_Q_invMx ) end function P_TLKMx !================================================================================================ subroutine DEF_fullgmres ( y , x , f2c ) !! A (CSLP preconditioned) GMRES solver for the coarse-grid problem in two-level deflation method implicit none ! Subroutine arguments ------------------------------------------------------- type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: y ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) ! Local arguments ------------------------------------------------------------ type ( Gridpara ) :: CurrentGrid real ( kind = realdp ) :: Rerror integer :: iter integer :: k , ki , j real ( kind = realdp ) :: b_norm , res_norm , Mres_norm , Mb_norm , MRerror complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , Mres , Mb , H !, u0 complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V ! Subroutine content --------------------------------------------------------- allocate ( sn ( def_mg_miter + 1 ), cs ( def_mg_miter + 1 ), beta ( def_mg_miter + 1 )) allocate ( res ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ), Mres ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( Mb ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( H ( def_mg_miter + 1 , def_mg_miter )) allocate ( V ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP , def_mg_miter + 1 )) CurrentGrid = CoarseGridpara ( f2c ) b_norm = mg_norm ( y , f2c % nxc , f2c % nyc ) if ( M2h_flag == 1 ) then Mb = MGCSLP_invMHx ( y , CurrentGrid ) else Mb = y endif Mb_norm = mg_norm ( Mb , f2c % nxc , f2c % nyc ) res = czero Mres = czero sn = czero cs = czero V = czero H = czero beta = czero res = y - Ex ( x , f2c ) !r=b-Ax if ( M2h_flag == 1 ) then Mres = MGCSLP_invMHx ( res , CurrentGrid ) else Mres = res endif Mres_norm = mg_norm ( Mres , f2c % nxc , f2c % nyc ) ! ||r|| MRerror = Mres_norm / Mb_norm ! scaled error? beta ( 1 ) = Mres_norm ! beta(1)=||r0|| V (:,:, 1 ) = Mres / Mres_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , def_mg_miter k = k + 1 !!Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"def_mg_miter+1\".So we need a k. call def_arnoldi ( V , H , k , f2c , CurrentGrid ) call def_apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) MRerror = CDABS ( beta ( k + 1 )) / Mb_norm if ( MRerror < def_rtol ) then exit end if enddo call def_back_substitute ( H , beta , k ) do ki = 1 , k x = x + beta ( ki ) * V (:,:, ki ) enddo res = y - Ex ( x , f2c ) res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) Rerror = res_norm / b_norm if ( my_id . eq . 0 ) then write ( * , \"(A,I9,A,E16.9)\" ) \"   Final DEF coarse solve GMRES Iter.    \" , k , \"    Error    \" , Rerror endif deallocate ( sn , cs , beta ) deallocate ( res , Mres ) deallocate ( Mb ) deallocate ( H ) deallocate ( V ) deallocate ( CurrentGrid % wavenumber_k , CurrentGrid % wavenumber_kh_pow_2 ) iter = k end subroutine DEF_fullgmres !==================================================================================== subroutine def_arnoldi ( V , H , k , f2c , CurrentGrid ) !! Arnoldi prosess of DEF_fullgmres implicit none ! Subroutine arguments ------------------------------------------------------- type ( TwoGrids ), intent ( inout ) :: f2c type ( Gridpara ) :: CurrentGrid complex ( kind = realdp ), dimension ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP , def_mg_miter + 1 ), intent ( inout ) :: V complex ( kind = realdp ), dimension ( def_mg_miter + 1 , def_mg_miter ), intent ( inout ) :: H integer , intent ( in ) :: k ! Local arguments ------------------------------------------------------------ integer :: i ! Subroutine content --------------------------------------------------------- V (:,:, k + 1 ) = Ex ( V (:,:, k ), f2c ) if ( M2h_flag == 1 ) then V (:,:, k + 1 ) = MGCSLP_invMHx ( V (:,:, k + 1 ), CurrentGrid ) endif do i = 1 , k H ( i , k ) = mg_dot_prod ( V (:,:, i ), V (:,:, k + 1 ), f2c % nxc , f2c % nyc ) !! Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = mg_norm ( V (:,:, k + 1 ), f2c % nxc , f2c % nyc ) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) end subroutine def_arnoldi ! SUBROUTINE APPLY_GIVENS_ROTATION ==================================================== subroutine def_apply_givens_rotation ( H , cs , sn , k ) !! Apply givens rotation of DEF_fullgmres implicit none ! Subroutine arguments ------------------------------------------------------- integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( def_mg_miter + 1 , def_mg_miter ), intent ( inout ) :: H complex ( kind = realdp ), dimension ( def_mg_miter + 1 ), intent ( inout ) :: cs , sn ! Local arguments ------------------------------------------------------------ complex ( kind = realdp ) :: temp integer :: i ! Subroutine content --------------------------------------------------------- do i = 1 , k - 1 temp = conjg ( cs ( i )) * H ( i , k ) + conjg ( sn ( i )) * H ( i + 1 , k ) H ( i + 1 , k ) = - sn ( i ) * H ( i , k ) + cs ( i ) * H ( i + 1 , k ) H ( i , k ) = temp end do if ( H ( k , k ) == czero ) then cs ( k ) = 0.0d0 sn ( k ) = 1.0d0 else temp = CDSQRT (( CDABS ( H ( k , k ))) ** 2 + ( H ( k + 1 , k )) ** 2 ) cs ( k ) = H ( k , k ) / temp sn ( k ) = H ( k + 1 , k ) / temp end if H ( k , k ) = conjg ( cs ( k )) * H ( k , k ) + conjg ( sn ( k )) * H ( k + 1 , k ) H ( k + 1 , k ) = ( 0.0d0 , 0.0d0 ) end subroutine def_apply_givens_rotation ! SUBROUTINE BACK_SUBSTITUTION ========================================================= subroutine def_back_substitute ( H , beta , k ) !! Perform back substitute in of DEF_fullgmres implicit none integer :: i integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( def_mg_miter + 1 , def_mg_miter ), intent ( in ) :: H complex ( kind = realdp ), dimension ( def_mg_miter + 1 ), intent ( inout ) :: beta beta ( k ) = beta ( k ) / H ( k , k ) do i = k - 1 , 1 , - 1 beta ( i ) = ( beta ( i ) - sum ( H ( i , i + 1 : k ) * beta ( i + 1 : k ))) / H ( i , i ) end do end subroutine def_back_substitute !Algorithm Bi-CSGTAB========================================================================= subroutine DEF_bicgstab ( y , x , f2c ) !! A (CSLP preconditioned) Bi-CGSTAB solver for the coarse-grid problem in two-level deflation method implicit none ! Subroutine arguments ------------------------------------------------------- type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: y ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) integer :: iter type ( Gridpara ) :: CurrentGrid complex ( kind = realdp ), allocatable , dimension (:,:) :: res_hat , res , vi , p , invMp , s , invMs , t complex ( kind = realdp ) :: rho_cg , rho0_cg complex ( kind = realdp ) :: alpha_cg , omega_cg , beta_cg real ( kind = realdp ) :: res_norm , b_norm !------------------------END PARAMETER AND VARIABLE-----------------------------! allocate ( res ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( res_hat ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( vi ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( p ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( invMp ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( s ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( invMs ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( t ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) rho_cg = ( 1.d0 , 0.d0 ) alpha_cg = ( 1.d0 , 0.d0 ) omega_cg = ( 1.d0 , 0.d0 ) res = czero vi = czero p = czero invMp = czero s = czero invMs = czero t = czero CurrentGrid = CoarseGridpara ( f2c ) res = y - Ex ( x , f2c ) res_hat = res res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) b_norm = mg_norm ( y , f2c % nxc , f2c % nyc ) iter = 0 do while ( res_norm /= 0.d0 . and . res_norm > def_rtol * b_norm . and . iter < 3000 ) rho0_cg = rho_cg rho_cg = mg_dot_prod ( res_hat , res , f2c % nxc , f2c % nyc ) if ( rho_cg == czero ) then write ( * , * ) \"OMG, rho=0!\" stop endif beta_cg = ( rho_cg / rho0_cg ) * ( alpha_cg / omega_cg ) p = res + beta_cg * ( p - omega_cg * vi ) if ( M2h_flag == 1 ) then invMp = MGCSLP_invMHx ( p , CurrentGrid ) else invMp = p endif vi = Ex ( invMp , f2c ) alpha_cg = rho_cg / mg_dot_prod ( res_hat , vi , f2c % nxc , f2c % nyc ) if ( alpha_cg == czero ) then write ( * , * ) \"OMG, alpha_cg=0!\" stop endif s = res - alpha_cg * vi if ( mg_norm ( s , f2c % nxc , f2c % nyc ) < def_rtol * b_norm ) then x = x + alpha_cg * invMp res = y - Ex ( x , f2c ) res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) Exit endif if ( M2h_flag == 1 ) then invMs = MGCSLP_invMHx ( s , CurrentGrid ) else invMs = s endif t = Ex ( invMs , f2c ) omega_cg = mg_dot_prod ( t , s , f2c % nxc , f2c % nyc ) & / mg_dot_prod ( t , t , f2c % nxc , f2c % nyc ) if ( omega_cg == czero ) then write ( * , * ) \"OMG, omega_cg=0!\" stop endif x = x + alpha_cg * invMp + omega_cg * invMs res = s - omega_cg * t res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) iter = iter + 1 end do !-------> END OF While LOOP if ( my_id . eq . 0 ) then write ( * , \"(A,I9,A,E16.9)\" ) \"   Final DEF coarse solve BiCGSTAB Iter.    \" , iter , \"     Rel. res.=\" , res_norm / b_norm end if deallocate ( res , vi , p , invMp , s , invMs , t , res_hat ) deallocate ( CurrentGrid % wavenumber_k , CurrentGrid % wavenumber_kh_pow_2 ) end subroutine DEF_bicgstab ! SUBROUTINE Flexible GMRES with right Deflated precondition ================================================================== recursive subroutine DEF_prefgmres ( y , x , f2c , maximum_iterations , level , rtol ) !! A recursive flexible GMRES with right deflation preconditioning implicit none ! Subroutine arguments ------------------------------------------------------- type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: y ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), intent ( inout ) :: x ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) ! optional arguments integer , optional , intent ( in ) :: maximum_iterations integer , optional , intent ( in ) :: level real ( kind = realdp ), optional , intent ( in ) :: rtol ! Local arguments ------------------------------------------------------------ type ( Gridpara ) :: CurrentGrid integer :: k , ki , i , j , iter , maxit , li real ( kind = realdp ) :: Rerror , res_tol real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ) :: temp complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V , Z ! Subroutine content --------------------------------------------------------- maxit = 55 if ( present ( maximum_iterations ) ) maxit = maximum_iterations li = 2 if ( present ( level ) ) li = level res_tol = 1.d-1 if ( present ( rtol ) ) res_tol = rtol allocate ( sn ( maxit + 1 ), cs ( maxit + 1 ), beta ( maxit + 1 )) allocate ( res ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP )) allocate ( H ( maxit + 1 , maxit )) allocate ( V ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP , maxit + 1 )) allocate ( Z ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP , maxit + 1 )) CurrentGrid = CoarseGridpara ( f2c ) b_norm = mg_norm ( y , f2c % nxc , f2c % nyc ) res = czero sn = czero cs = czero V = czero H = czero beta = czero res = y - Helm_Ax_nth ( x , CurrentGrid ) !r=y-Ax res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) ! ||r|| Rerror = res_norm / b_norm beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = res / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , maxit k = k + 1 !!Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"maxit+1\".So we need a k. !call Prearnoldi(V, H, k)---------------------------------------- if ( li < def_nlevel ) then Z (:,:, k ) = MultiLevelADP_Px ( V (:,:, k ), CurrentGrid ) elseif ( li == def_nlevel ) then Z (:,:, k ) = KrylovCSLP_invMHx ( V (:,:, k ), CurrentGrid ) else write ( * , * ) \"Warning!! Level exceeds!!!\" stop endif V (:,:, k + 1 ) = Helm_Ax_nth ( Z (:,:, k ), CurrentGrid ) do i = 1 , k H ( i , k ) = mg_dot_prod ( V (:,:, i ), V (:,:, k + 1 ), f2c % nxc , f2c % nyc ) !! Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = mg_norm ( V (:,:, k + 1 ), f2c % nxc , f2c % nyc ) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) !----------------------------------------------------------------- !call apply_givens_rotation(H, cs, sn, k)----------------------- do i = 1 , k - 1 temp = conjg ( cs ( i )) * H ( i , k ) + conjg ( sn ( i )) * H ( i + 1 , k ) H ( i + 1 , k ) = - sn ( i ) * H ( i , k ) + cs ( i ) * H ( i + 1 , k ) H ( i , k ) = temp end do if ( H ( k , k ) == 0 ) then cs ( k ) = 0.0d0 sn ( k ) = 1.0d0 else temp = CDSQRT (( CDABS ( H ( k , k ))) ** 2 + ( H ( k + 1 , k )) ** 2 ) cs ( k ) = H ( k , k ) / temp sn ( k ) = H ( k + 1 , k ) / temp end if H ( k , k ) = conjg ( cs ( k )) * H ( k , k ) + conjg ( sn ( k )) * H ( k + 1 , k ) H ( k + 1 , k ) = ( 0.0d0 , 0.0d0 ) !----------------------------------------------------------------- beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( Rerror < res_tol ) then exit end if end do !----call back_substitute(H,beta,k)--------------------------------- beta ( k ) = beta ( k ) / H ( k , k ) do i = k - 1 , 1 , - 1 beta ( i ) = ( beta ( i ) - sum ( H ( i , i + 1 : k ) * beta ( i + 1 : k ))) / H ( i , i ) end do !------------------------------------------------------------------ do ki = 1 , k x = x + beta ( ki ) * Z (:,:, ki ) enddo !calculate the final Res res = y - Helm_Ax_nth ( x , CurrentGrid ) !r=y-Ax res_norm = mg_norm ( res , f2c % nxc , f2c % nyc ) Rerror = res_norm / b_norm if ( my_id . eq . 0 ) then write ( * , \"(A,I2,A,I5,A,E14.9)\" ) \"       Level\" , li , \": Final DEF coarse solve FGMRES Iter. \" , k , \"    Rres \" , Rerror endif deallocate ( sn , cs , beta ) deallocate ( res ) deallocate ( H ) deallocate ( V ) deallocate ( Z ) deallocate ( CurrentGrid % wavenumber_k , CurrentGrid % wavenumber_kh_pow_2 ) iter = k end subroutine DEF_prefgmres subroutine Helmholtz2d_O4cmpct ( v_in , v_out , f2c ) !! A coarse-grid Helmholtz operator for two-level deflation, descretized by a classic compact fourth-order FD scheme implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), intent ( inout ) :: v_out ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) real ( kind = realdp ) :: cmpctAs , cmpctAc integer :: i , j complex ( kind = realdp ) :: cmpctA0 if ( f2c % hxc /= f2c % hyc ) then write ( * , * ) \"careful, hx not equals to hy, in helmholtzOP\" endif v_out = czero v_in ( 1 - LAP : 0 ,:) = czero v_in (:, 1 - LAP : 0 ) = czero v_in ( f2c % nxc + 1 : f2c % nxc + LAP ,:) = czero v_in (:, f2c % nyc + 1 : f2c % nyc + LAP ) = czero if ( flag_BCs == 1 ) then if ( npy == 0 ) then do i = 1 , f2c % nxc v_in ( i , 0 ) = v_in ( i , 1 ) enddo endif if ( npy == npy0 - 1 ) then do i = 1 , f2c % nxc v_in ( i , f2c % nyc + 1 ) = v_in ( i , f2c % nyc ) enddo endif if ( npx == 0 ) then do j = 1 , f2c % nyc v_in ( 0 , j ) = v_in ( 1 , j ) enddo endif if ( npx == npx0 - 1 ) then do j = 1 , f2c % nyc v_in ( f2c % nxc + 1 , j ) = v_in ( f2c % nxc , j ) enddo endif if ( npx == 0 . and . npy == 0 ) then v_in ( 0 , 0 ) = ( v_in ( 0 , 1 ) + v_in ( 1 , 0 )) / 2.d0 endif if ( npx == 0 . and . npy == npy0 - 1 ) then v_in ( 0 , f2c % nyc + 1 ) = ( v_in ( 0 , f2c % nyc ) + v_in ( 1 , f2c % nyc + 1 )) / 2.d0 endif if ( npx == npx0 - 1 . and . npy == 0 ) then v_in ( f2c % nxc + 1 , 0 ) = ( v_in ( f2c % nxc , 0 ) + v_in ( f2c % nxc + 1 , 1 )) / 2.d0 endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then v_in ( f2c % nxc + 1 , f2c % nyc + 1 ) = ( v_in ( f2c % nxc , f2c % nyc + 1 ) + v_in ( f2c % nxc + 1 , f2c % nyc )) / 2.d0 endif elseif ( flag_BCs == 2 ) then if ( npy == 0 ) then do i = 1 , f2c % nxc v_in ( i , 0 ) = 2.d0 * cone * f2c % kxy_c ( i , 1 ) * f2c % hyc * ( 1.d0 - f2c % kh2_c ( i , 1 ) / 6.d0 ) * v_in ( i , 1 ) + v_in ( i , 2 ) enddo endif if ( npy == npy0 - 1 ) then do i = 1 , f2c % nxc v_in ( i , f2c % nyc + 1 ) = 2.d0 * cone * f2c % kxy_c ( i , f2c % nyc ) * f2c % hyc * & ( 1.d0 - f2c % kh2_c ( i , f2c % nyc ) / 6.d0 ) * v_in ( i , f2c % nyc ) + v_in ( i , f2c % nyc - 1 ) enddo endif if ( npx == 0 ) then do j = 1 , f2c % nyc v_in ( 0 , j ) = 2.d0 * cone * f2c % kxy_c ( 1 , j ) * f2c % hxc * ( 1.d0 - f2c % kh2_c ( 1 , j ) / 6.d0 ) * v_in ( 1 , j ) + v_in ( 2 , j ) enddo endif if ( npx == npx0 - 1 ) then do j = 1 , f2c % nyc v_in ( f2c % nxc + 1 , j ) = 2.d0 * cone * f2c % kxy_c ( f2c % nxc , j ) * f2c % hxc * & ( 1.d0 - f2c % kh2_c ( f2c % nxc , j ) / 6.d0 ) * v_in ( f2c % nxc , j ) + v_in ( f2c % nxc - 1 , j ) enddo endif if ( npx == 0 . and . npy == 0 ) then v_in ( 0 , 0 ) = ( v_in ( 0 , 1 ) + v_in ( 1 , 0 )) / 2.d0 endif if ( npx == 0 . and . npy == npy0 - 1 ) then v_in ( 0 , f2c % nyc + 1 ) = ( v_in ( 0 , f2c % nyc ) + v_in ( 1 , f2c % nyc + 1 )) / 2.d0 endif if ( npx == npx0 - 1 . and . npy == 0 ) then v_in ( f2c % nxc + 1 , 0 ) = ( v_in ( f2c % nxc , 0 ) + v_in ( f2c % nxc + 1 , 1 )) / 2.d0 endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then v_in ( f2c % nxc + 1 , f2c % nyc + 1 ) = ( v_in ( f2c % nxc , f2c % nyc + 1 ) + v_in ( f2c % nxc + 1 , f2c % nyc )) / 2.d0 endif else write ( * , * ) \"There is no such a boundary conditions yet!!!\" stop endif !------------------------------------------------------------------------------------------------< call mg_check_xy2d ( v_in , f2c % nxc , f2c % nyc ) do j = 1 , f2c % nyc do i = 1 , f2c % nxc cmpctA0 = 1 0.d0 / 3.d0 - f2c % kh2_c ( i , j ) * ( 2.d0 / 3.d0 + 1.d0 / 3 6.d0 ) cmpctAs = - 2.d0 / 3.d0 - f2c % kh2_c ( i , j ) * ( 1.d0 / 1 2.d0 - 1.d0 / 7 2.d0 ) cmpctAc = - 1.d0 / 6.d0 - f2c % kh2_c ( i , j ) * ( 1.d0 / 14 4.d0 ) v_out ( i , j ) = cmpctA0 * v_in ( i , j ) + cmpctAs * ( v_in ( i , j + 1 ) + v_in ( i + 1 , j ) + v_in ( i , j - 1 ) + v_in ( i - 1 , j )) & + cmpctAc * ( v_in ( i + 1 , j + 1 ) + v_in ( i + 1 , j - 1 ) + v_in ( i - 1 , j - 1 ) + v_in ( i - 1 , j + 1 )) enddo enddo v_out = v_out / f2c % hxhyc if ( flag_BCs == 1 ) then if ( npy == 0 ) then v_out (:, 1 ) = v_in (:, 1 ) endif if ( npy == npy0 - 1 ) then v_out (:, f2c % nyc ) = v_in (:, f2c % nyc ) endif if ( npx == 0 ) then v_out ( 1 ,:) = v_in ( 1 ,:) endif if ( npx == npx0 - 1 ) then v_out ( f2c % nxc ,:) = v_in ( f2c % nxc ,:) endif endif end subroutine Helmholtz2d_O4cmpct subroutine Helmholtz2d_ReD_Glk ( v_in , v_out , f2c ) !! A coarse-grid Helmholtz operator for two-level deflation, descretized by ReD-GLK FD scheme implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) complex ( kind = realdp ), intent ( inout ) :: v_out ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) real ( kind = realdp ) :: ae , aw , an , as integer :: i , j , ia , ja complex ( kind = realdp ) :: ap , a ( - 2 : 2 , - 2 : 2 ), b ( - 2 : 2 , - 2 : 2 ) if ( f2c % hxc /= f2c % hyc ) then write ( * , * ) \"careful, hx not equals to hy, in helmholtzOP\" endif v_out = czero v_in ( 1 - LAP : 0 ,:) = czero v_in (:, 1 - LAP : 0 ) = czero v_in ( f2c % nxc + 1 : f2c % nxc + LAP ,:) = czero v_in (:, f2c % nyc + 1 : f2c % nyc + LAP ) = czero call mg_check_xy2d ( v_in , f2c % nxc , f2c % nyc ) call ExtrpltGhostBCs ( v_in , f2c ) !! fill in a layer of ghost grid points by boundary conditions do j = 1 , f2c % nyc do i = 1 , f2c % nxc call ReD_Glk_stencils ( a , b , f2c , i , j ) !============================== do ja =- 2 , 2 do ia =- 2 , 2 v_out ( i , j ) = v_out ( i , j ) + a ( ia , ja ) * v_in ( i + ia , j + ja ) enddo enddo enddo enddo if ( flag_BCs == 1 ) then if ( npy == 0 ) then v_out (:, 1 ) = v_in (:, 1 ) * f2c % hxhyc endif if ( npy == npy0 - 1 ) then v_out (:, f2c % nyc ) = v_in (:, f2c % nyc ) * f2c % hxhyc endif if ( npx == 0 ) then v_out ( 1 ,:) = v_in ( 1 ,:) * f2c % hxhyc endif if ( npx == npx0 - 1 ) then v_out ( f2c % nxc ,:) = v_in ( f2c % nxc ,:) * f2c % hxhyc endif elseif ( flag_BCs == 2 ) then !! The boundary keeps 2nd-order finite difference scheme using five points stencils if ( npy == 0 ) then j = 1 do i = 1 , f2c % nxc call Helmholtz2d_stencils ( ap , an , as , aw , ae , f2c % kh2_c ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npy == npy0 - 1 ) then j = f2c % nyc do i = 1 , f2c % nxc call Helmholtz2d_stencils ( ap , an , as , aw , ae , f2c % kh2_c ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == 0 ) then i = 1 do j = 1 , f2c % nyc call Helmholtz2d_stencils ( ap , an , as , aw , ae , f2c % kh2_c ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif if ( npx == npx0 - 1 ) then i = f2c % nxc do j = 1 , f2c % nyc call Helmholtz2d_stencils ( ap , an , as , aw , ae , f2c % kh2_c ( i , j )) !============================== v_out ( i , j ) = ap * v_in ( i , j ) + ae * v_in ( i + 1 , j ) + aw * v_in ( i - 1 , j ) & + an * v_in ( i , j + 1 ) + as * v_in ( i , j - 1 ) enddo endif endif v_out = v_out / f2c % hxhyc end subroutine Helmholtz2d_ReD_Glk subroutine ReD_Glk_stencils ( a , b , f2c , ic , jc ) !! *ReD-Glk* computational stencils of the Helmholtz operator for coarse-grid level in two-deflation method implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ) :: a ( - 2 : 2 , - 2 : 2 ) !! a: Laplace operator complex ( kind = realdp ) :: b ( - 2 : 2 , - 2 : 2 ) !! b: wavenumber operator integer :: ic , jc , ib , jb a (:, - 2 ) = [ complex ( realdp ) :: - 0.0117187500d0 , - 0.17187500d0 , - 0.382812500d0 , - 0.17187500d0 , - 0.0117187500d0 ] a (:, - 1 ) = [ complex ( realdp ) :: - 0.1718750000d0 , - 0.43750000d0 , 0.218750000d0 , - 0.43750000d0 , - 0.1718750000d0 ] a (:, 0 ) = [ complex ( realdp ) :: - 0.3828125000d0 , 0.21875000d0 , 3.828125000d0 , 0.21875000d0 , - 0.3828125000d0 ] a (:, 1 ) = [ complex ( realdp ) :: - 0.1718750000d0 , - 0.43750000d0 , 0.218750000d0 , - 0.43750000d0 , - 0.1718750000d0 ] a (:, 2 ) = [ complex ( realdp ) :: - 0.0117187500d0 , - 0.17187500d0 , - 0.382812500d0 , - 0.17187500d0 , - 0.0117187500d0 ] b (:, - 2 ) = [ complex ( realdp ) :: 0.000244140625d0 , 0.006835937500d0 , 0.017089843750d0 , 0.006835937500d0 , 0.000244140625d0 ] b (:, - 1 ) = [ complex ( realdp ) :: 0.006835937500d0 , 0.191406250000d0 , 0.478515625000d0 , 0.191406250000d0 , 0.006835937500d0 ] b (:, 0 ) = [ complex ( realdp ) :: 0.017089843750d0 , 0.478515625000d0 , 1.196289062500d0 , 0.478515625000d0 , 0.017089843750d0 ] b (:, 1 ) = [ complex ( realdp ) :: 0.006835937500d0 , 0.191406250000d0 , 0.478515625000d0 , 0.191406250000d0 , 0.006835937500d0 ] b (:, 2 ) = [ complex ( realdp ) :: 0.000244140625d0 , 0.006835937500d0 , 0.017089843750d0 , 0.006835937500d0 , 0.000244140625d0 ] do jb =- 2 , 2 do ib =- 2 , 2 b ( ib , jb ) = b ( ib , jb ) * f2c % kh2_c ( ic + ib , jc + jb ) enddo enddo a = a - b end subroutine ReD_Glk_stencils subroutine ExtrpltGhostBCs ( v_in , f2c ) !! Extrapolate a layer of ghost grid points based on the boundary conditions implicit none type ( TwoGrids ), intent ( inout ) :: f2c complex ( kind = realdp ), intent ( inout ) :: v_in ( 1 - LAP : f2c % nxc + LAP , 1 - LAP : f2c % nyc + LAP ) integer :: i , j if ( flag_BCs == 1 ) then if ( npx == 0 ) then do j = 1 - LAP , f2c % nyc + LAP v_in ( 0 , j ) = 2.d0 * v_in ( 1 , j ) - v_in ( 2 , j ) f2c % kxy_c ( 0 , j ) = 0.d0 !! The zero padding of wavenumber is ok in practical f2c % kh2_c ( 0 , j ) = f2c % kxy_c ( 0 , j ) * f2c % hxhyc enddo endif if ( npx == npx0 - 1 ) then do j = 1 - LAP , f2c % nyc + LAP v_in ( f2c % nxc + 1 , j ) = 2.d0 * v_in ( f2c % nxc , j ) - v_in ( f2c % nxc - 1 , j ) f2c % kxy_c ( f2c % nxc + 1 , j ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , j ) = f2c % kxy_c ( f2c % nxc + 1 , j ) * f2c % hxhyc enddo endif if ( npy == 0 ) then do i = 1 - LAP , f2c % nxc + LAP v_in ( i , 0 ) = 2.d0 * v_in ( i , 1 ) - v_in ( i , 2 ) f2c % kxy_c ( i , 0 ) = 0.d0 f2c % kh2_c ( i , 0 ) = f2c % kxy_c ( i , 0 ) * f2c % hxhyc enddo endif if ( npy == npy0 - 1 ) then do i = 1 - LAP , f2c % nxc + LAP v_in ( i , f2c % nyc + 1 ) = 2.d0 * v_in ( i , f2c % nyc ) - v_in ( i , f2c % nyc - 1 ) f2c % kxy_c ( i , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( i , f2c % nyc + 1 ) = f2c % kxy_c ( i , f2c % nyc + 1 ) * f2c % hxhyc enddo endif !=THE EDGES= if ( npx == 0 . and . npy == 0 ) then v_in ( 0 , 0 ) = 4.d0 * v_in ( 1 , 1 ) - v_in ( 2 , 2 ) - v_in ( 0 , 2 ) - v_in ( 2 , 0 ) f2c % kxy_c ( 0 , 0 ) = 0.d0 f2c % kh2_c ( 0 , 0 ) = f2c % kxy_c ( 0 , 0 ) * f2c % hxhyc endif if ( npx == 0 . and . npy == npy0 - 1 ) then v_in ( 0 , f2c % nyc + 1 ) = 4.d0 * v_in ( 1 , f2c % nyc ) - v_in ( 2 , f2c % nyc - 1 ) - v_in ( 2 , f2c % nyc + 1 ) - v_in ( 0 , f2c % nyc - 1 ) f2c % kxy_c ( 0 , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( 0 , f2c % nyc + 1 ) = f2c % kxy_c ( 0 , f2c % nyc + 1 ) * f2c % hxhyc endif if ( npx == npx0 - 1 . and . npy == 0 ) then v_in ( f2c % nxc + 1 , 0 ) = 4.d0 * v_in ( f2c % nxc , 1 ) - v_in ( f2c % nxc - 1 , 2 ) - v_in ( f2c % nxc - 1 , 0 ) - v_in ( f2c % nxc + 1 , 2 ) f2c % kxy_c ( f2c % nxc + 1 , 0 ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , 0 ) = f2c % kxy_c ( f2c % nxc + 1 , 0 ) * f2c % hxhyc endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then v_in ( f2c % nxc + 1 , f2c % nyc + 1 ) = 4.d0 * v_in ( f2c % nxc , f2c % nyc ) - v_in ( f2c % nxc - 1 , f2c % nyc - 1 ) & - v_in ( f2c % nxc - 1 , f2c % nyc + 1 ) - v_in ( f2c % nxc + 1 , f2c % nyc - 1 ) f2c % kxy_c ( f2c % nxc + 1 , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , f2c % nyc + 1 ) = f2c % kxy_c ( f2c % nxc + 1 , f2c % nyc + 1 ) * f2c % hxhyc endif elseif ( flag_BCs == 2 ) then if ( npx == 0 ) then do j = 1 - LAP , f2c % nyc + LAP v_in ( 0 , j ) = 2.d0 * cone * f2c % kxy_c ( 1 , j ) * f2c % hxc * v_in ( 1 , j ) + v_in ( 2 , j ) f2c % kxy_c ( 0 , j ) = 0.d0 f2c % kh2_c ( 0 , j ) = f2c % kxy_c ( 0 , j ) * f2c % hxhyc enddo endif if ( npx == npx0 - 1 ) then do j = 1 - LAP , f2c % nyc + LAP v_in ( f2c % nxc + 1 , j ) = 2.d0 * cone * f2c % kxy_c ( f2c % nxc , j ) * f2c % hxc * & v_in ( f2c % nxc , j ) + v_in ( f2c % nxc - 1 , j ) f2c % kxy_c ( f2c % nxc + 1 , j ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , j ) = f2c % kxy_c ( f2c % nxc + 1 , j ) * f2c % hxhyc enddo endif if ( npy == 0 ) then do i = 1 - LAP , f2c % nxc + LAP v_in ( i , 0 ) = 2.d0 * cone * f2c % kxy_c ( i , 1 ) * f2c % hyc * v_in ( i , 1 ) + v_in ( i , 2 ) f2c % kxy_c ( i , 0 ) = 0.d0 f2c % kh2_c ( i , 0 ) = f2c % kxy_c ( i , 0 ) * f2c % hxhyc ! !!Another Ghost point seems no gains enddo endif if ( npy == npy0 - 1 ) then do i = 1 - LAP , f2c % nxc + LAP v_in ( i , f2c % nyc + 1 ) = 2.d0 * cone * f2c % kxy_c ( i , f2c % nyc ) * f2c % hyc * & v_in ( i , f2c % nyc ) + v_in ( i , f2c % nyc - 1 ) f2c % kxy_c ( i , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( i , f2c % nyc + 1 ) = f2c % kxy_c ( i , f2c % nyc + 1 ) * f2c % hxhyc enddo endif !=THE CORNER= if ( npx == 0 . and . npy == 0 ) then !   (-1, 3)--(0, 3)-|-(1, 3)--(2, 3)--(3, 3) !      |        |   |    |       |       | !   (-1, 2)--(0, 2)-|-(1, 2)--(2, 2)--(3, 2) !      |        |   |    |       |       | !   (-1, 1)--(0, 1)-|-(1, 1)--(2, 1)--(3, 1) !    __|________|___|____|_______|_______|__ !   (-1, 0)--(0, 0)-|-(1, 0)--(2, 0)--(3, 0) !      |        |   |    |       |       | !   (-1,-1)--(0,-1)-|-(1,-1)--(2,-1)--(3,-1) v_in ( 0 , 0 ) = (( 2.d0 * cone * f2c % kxy_c ( 1 , 0 ) * f2c % hxc * v_in ( 1 , 0 ) + v_in ( 2 , 0 )) & + ( 2.d0 * cone * f2c % kxy_c ( 0 , 1 ) * f2c % hyc * v_in ( 0 , 1 ) + v_in ( 0 , 2 ))) / 2.d0 f2c % kxy_c ( 0 , 0 ) = 0.d0 f2c % kh2_c ( 0 , 0 ) = f2c % kxy_c ( 0 , 0 ) * f2c % hxhyc endif if ( npx == 0 . and . npy == npy0 - 1 ) then !   (-1,n+2)--(0,n+2)-|-(1,n+2)--(2,n+2)--(3,n+2) !      |        |     |    |       |       | !   (-1,n+1)--(0,n+1)-|-(1,n+1)--(2,n+1)--(3,n+1) !    __|________|_____|____|_______|_______|____ !   (-1, n )--(0, n )-|-(1, n )--(2, n )--(3, n ) !      |        |     |    |       |       | !   (-1,n-1)--(0,n-1)-|-(1,n-1)--(2,n-1)--(3,n-1) !      |        |     |    |       |       | !   (-1,n-2)--(0,n-2)-|-(1,n-2)--(2,n-2)--(3,n-2) v_in ( 0 , f2c % nyc + 1 ) = (( 2.d0 * cone * f2c % kxy_c ( 1 , f2c % nyc + 1 ) * f2c % hxc * v_in ( 1 , f2c % nyc + 1 ) + v_in ( 2 , f2c % nyc + 1 )) & + ( 2.d0 * cone * f2c % kxy_c ( 0 , f2c % nyc ) * f2c % hyc * v_in ( 0 , f2c % nyc ) + v_in ( 0 , f2c % nyc - 1 ))) / 2.d0 f2c % kxy_c ( 0 , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( 0 , f2c % nyc + 1 ) = f2c % kxy_c ( 0 , f2c % nyc + 1 ) * f2c % hxhyc endif if ( npx == npx0 - 1 . and . npy == 0 ) then !   (n-2, 3)--(n-1, 3)--( n , 3)--|--(n+1, 3)--(n+2, 3) !       |        |          |     |      |       | !   (n-2, 2)--(n-1, 2)--( n , 2)--|--(n+1, 2)--(n+2, 2) !       |        |          |     |      |       | !   (n-2, 1)--(n-1, 1)--( n , 1)--|--(n+1, 1)--(n+2, 1) !   ____|________|__________|_____|______|_______|______ !       |        |          |     |      |       | !   (n-2, 0)--(n-1, 0)--( n , 0)--|--(n+1, 0)--(n+2, 0) !       |        |          |     |      |       | !   (n-2,-1)--(n-1,-1)--( n ,-1)--|--(n+1,-1)--(n+2,-1) v_in ( f2c % nxc + 1 , 0 ) = (( 2.d0 * cone * f2c % kxy_c ( f2c % nxc , 0 ) * f2c % hxc * v_in ( f2c % nxc , 0 ) + v_in ( f2c % nxc - 1 , 0 )) & + ( 2.d0 * cone * f2c % kxy_c ( f2c % nxc + 1 , 1 ) * f2c % hyc * v_in ( f2c % nxc + 1 , 1 ) + v_in ( f2c % nxc + 1 , 2 ))) / 2.d0 f2c % kxy_c ( f2c % nxc + 1 , 0 ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , 0 ) = f2c % kxy_c ( f2c % nxc + 1 , 0 ) * f2c % hxhyc endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then !   (n-2,n+2)--(n-1,n+2)--( n ,n+2)--|--(n+1,n+2)--(n+2,n+2) !       |          |          |      |      |          | !   (n-2,n+1)--(n-1,n+1)--( n ,n+1)--|--(n+1,n+1)--(n+2,n+1) !   ____|__________|__________|______|______|__________|______ !       |          |          |      |      |          | !   (n-2, n )--(n-1, n )--( n , n )--|--(n+1, n )--(n+2, n ) !       |          |          |      |      |          | !   (n-2,n-1)--(n-1,n-1)--( n ,n-1)--|--(n+1,n-1)--(n+2,n-1) !       |          |          |      |      |          | !   (n-2,n-2)--(n-1,n-2)--( n ,n-2)--|--(n+1,n-2)--(n+2,n-2) v_in ( f2c % nxc + 1 , f2c % nyc + 1 ) = (( 2.d0 * cone * f2c % kxy_c ( f2c % nxc , f2c % nyc + 1 ) * f2c % hxc * v_in ( f2c % nxc , f2c % nyc + 1 )& + v_in ( f2c % nxc - 1 , f2c % nyc + 1 )) & + ( 2.d0 * cone * f2c % kxy_c ( f2c % nxc + 1 , f2c % nyc ) * f2c % hyc * v_in ( f2c % nxc + 1 , f2c % nyc )& + v_in ( f2c % nxc + 1 , f2c % nyc - 1 ))) / 2.d0 f2c % kxy_c ( f2c % nxc + 1 , f2c % nyc + 1 ) = 0.d0 f2c % kh2_c ( f2c % nxc + 1 , f2c % nyc + 1 ) = f2c % kxy_c ( f2c % nxc + 1 , f2c % nyc + 1 ) * f2c % hxhyc endif else write ( * , * ) \"There is no such a boundary conditions yet!!!\" stop endif end subroutine ExtrpltGhostBCs end module deflaion_setup","tags":"","loc":"sourcefile/deflation_setup.f90.html"},{"title":"CSLP_Solver.f90 – ParaMADP","text":"This file depends on sourcefile~~cslp_solver.f90~~EfferentGraph sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cslp_solver.f90~~AfferentGraph sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module CSLP_Solver !! This is a module to solve the inverse of CSLP approximately !! By multigrid methods or Krylov iterations use mpi use comm_variable use mpi_setup use wavenumber , only : wavenumber_k , kh_pow_2 use operators use smoother implicit none type , public :: GridSystem !! A data type that collect some info of a (coarse) grid system !! It is different the type Gridpara, which does not consist any variable like u, rhs, res, and etc. integer ( kind = 4 ) :: nxc_global , nyc_global !! Global grid size, in x and y directions respectively. integer ( kind = 4 ) :: nxc , nyc !! Local grid size of a subdomain, in x and y directions respectively. integer , dimension ( 0 : npMax - 1 ) :: ic_offset !! ic_offset: an array that contains the index offset for MPI ranks in x direction integer , dimension ( 0 : npMax - 1 ) :: jc_offset !! jc_offset: an array that contains the index offset for MPI ranks in y direction integer , dimension ( 0 : npMax - 1 ) :: ic_nn !! ic_nn: an array that contains the number of grid points for MPI ranks in x direction integer , dimension ( 0 : npMax - 1 ) :: jc_nn !! jc_nn: an array that contains the number of grid points for MPI ranks in y direction real ( kind = realdp ) :: hxc , hyc , hxhyc !! space step, hxhyc==hx*hy==hx&#94;2 complex ( kind = realdp ), allocatable , dimension (:,:) :: u_c !! Solution variable in subdomain complex ( kind = realdp ), allocatable , dimension (:,:) :: rhs_c !! RHS variable in subdomain complex ( kind = realdp ), allocatable , dimension (:,:) :: res_c !! Residual variable in subdomain real ( kind = realdp ), allocatable , dimension (:,:) :: kxy_c , kh2_c !! wavenumber in subdomain end type GridSystem contains function MGCSLP_invMx ( b_in ) !! Multigrid-Based CSLP, ONLY starts from the default (finest) grid sysyem implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: b_in complex ( kind = realdp ) :: MGCSLP_invMx ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) !! MGCSLP_invMx = M_h&#94;(-1)(b_h) type ( GridSystem ) :: mg_global MGCSLP_invMx = czero call finestgrid_define ( mg_global ) mg_global % rhs_c = b_in if ( MG_flag == 0 . or . MG_flag == 1 ) then !! One V-cycle if ( mod ( mg_global % nxc_global - 1 , 2 ) == 0 . and . mod ( mg_global % nyc_global - 1 , 2 ) == 0 ) then call V_cycle ( mg_global ) endif elseif ( MG_flag == 12 ) then !! Two V-cycle if ( mod ( mg_global % nxc_global - 1 , 2 ) == 0 . and . mod ( mg_global % nyc_global - 1 , 2 ) == 0 ) then call V_cycle ( mg_global ) call V_cycle ( mg_global ) endif elseif ( MG_flag == 3 ) then !! One F-cycle if ( mod ( mg_global % nxc_global - 1 , 2 ) == 0 . and . mod ( mg_global % nyc_global - 1 , 2 ) == 0 ) then call F_cycle ( mg_global ) endif else write ( * , * ) \"No such a multigrid method yet!!\" stop endif MGCSLP_invMx = mg_global % u_c call grid_destroy ( mg_global ) return end function MGCSLP_invMx function MGCSLP_invMHx ( b_in , grid ) !! Multigrid-based CSLP, starts from the a specified grid system implicit none type ( Gridpara ) :: grid !! A data type that collect some parameters of a system complex ( kind = realdp ), dimension ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) :: b_in complex ( kind = realdp ), dimension ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) :: MGCSLP_invMHx !! MGCSLP_invMHx = M_H&#94;(-1)(b_H) type ( GridSystem ) :: basegridsys MGCSLP_invMHx = czero call gridsys_define ( grid , basegridsys ) basegridsys % rhs_c = b_in if ( MG_flag == 0 . or . MG_flag == 1 ) then !! One V-cycle if ( mod ( basegridsys % nxc_global - 1 , 2 ) == 0 . and . mod ( basegridsys % nyc_global - 1 , 2 ) == 0 ) then call V_cycle ( basegridsys ) endif elseif ( MG_flag == 12 ) then !! Two V-cycle if ( mod ( basegridsys % nxc_global - 1 , 2 ) == 0 . and . mod ( basegridsys % nyc_global - 1 , 2 ) == 0 ) then call V_cycle ( basegridsys ) call V_cycle ( basegridsys ) endif elseif ( MG_flag == 3 ) then !! One F-cycle if ( mod ( basegridsys % nxc_global - 1 , 2 ) == 0 . and . mod ( basegridsys % nyc_global - 1 , 2 ) == 0 ) then call F_cycle ( basegridsys ) endif else write ( * , * ) \"No such a multigrid method yet!!\" stop endif MGCSLP_invMHx = basegridsys % u_c call grid_destroy ( basegridsys ) return end function MGCSLP_invMHx function KrylovCSLP_invMHx ( b_in , grid ) !! Krylov-based CSLP, starts from the a specified grid sysyem implicit none type ( Gridpara ) :: grid !! A data type that collect some parameters of a system complex ( kind = realdp ), dimension ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) :: b_in complex ( kind = realdp ), dimension ( 1 - LAP : grid % nx + LAP , 1 - LAP : grid % ny + LAP ) :: KrylovCSLP_invMHx type ( GridSystem ) :: basegridsys integer ( kind = 4 ) :: C_it !! The maximum number of iterations for the Krylov iterations KrylovCSLP_invMHx = czero C_it = ceiling ( 6.d0 * sqrt ( sqrt ( dble ( grid % nx_global * grid % ny_global )))) call gridsys_define ( grid , basegridsys ) basegridsys % rhs_c = b_in !! Choose Bi-CGSATB or GMRES by uncomment or comment ! call ReD_Glk_CSLP_bicgstab(basegridsys, grid, C_it) call ReD_Glk_CSLP_gmres ( basegridsys , grid , C_it ) KrylovCSLP_invMHx = basegridsys % u_c call grid_destroy ( basegridsys ) return end function KrylovCSLP_invMHx subroutine finestgrid_define ( mg_finest ) !! This is a routine that define the finest grid system from the default (finest) grid parameters implicit none type ( GridSystem ), intent ( inout ) :: mg_finest mg_finest % nxc_global = nx_global mg_finest % nyc_global = ny_global mg_finest % hxc = hx mg_finest % hyc = hy mg_finest % hxhyc = hxhy mg_finest % nxc = nx mg_finest % nyc = ny mg_finest % ic_offset = i_offset mg_finest % jc_offset = j_offset mg_finest % ic_nn = i_nn mg_finest % jc_nn = j_nn allocate ( mg_finest % u_c ( 1 - LAP : mg_finest % nxc + LAP , 1 - LAP : mg_finest % nyc + LAP )) allocate ( mg_finest % rhs_c ( 1 - LAP : mg_finest % nxc + LAP , 1 - LAP : mg_finest % nyc + LAP )) allocate ( mg_finest % res_c ( 1 - LAP : mg_finest % nxc + LAP , 1 - LAP : mg_finest % nyc + LAP )) allocate ( mg_finest % kxy_c ( 1 - LAP : mg_finest % nxc + LAP , 1 - LAP : mg_finest % nyc + LAP )) allocate ( mg_finest % kh2_c ( 1 - LAP : mg_finest % nxc + LAP , 1 - LAP : mg_finest % nyc + LAP )) mg_finest % u_c = ( 0.d0 , 0.d0 ) mg_finest % rhs_c = ( 0.d0 , 0.d0 ) mg_finest % res_c = ( 0.d0 , 0.d0 ) mg_finest % kxy_c = wavenumber_k mg_finest % kh2_c = kh_pow_2 end subroutine finestgrid_define subroutine gridsys_define ( grid , basegridsys ) !! This is a routine that define a GridSystem type from the grid parameters of a data type Gridpara !! One can find the differnece of GridSystem and Gridpara implicit none type ( Gridpara ) :: grid type ( GridSystem ) :: basegridsys basegridsys % nxc_global = grid % nx_global basegridsys % nyc_global = grid % ny_global basegridsys % hxc = grid % hx basegridsys % hyc = grid % hy basegridsys % hxhyc = grid % hxhy basegridsys % nxc = grid % nx basegridsys % nyc = grid % ny basegridsys % ic_offset = grid % i_offset basegridsys % jc_offset = grid % j_offset basegridsys % ic_nn = grid % i_nn basegridsys % jc_nn = grid % j_nn allocate ( basegridsys % u_c ( 1 - LAP : basegridsys % nxc + LAP , 1 - LAP : basegridsys % nyc + LAP )) allocate ( basegridsys % rhs_c ( 1 - LAP : basegridsys % nxc + LAP , 1 - LAP : basegridsys % nyc + LAP )) allocate ( basegridsys % res_c ( 1 - LAP : basegridsys % nxc + LAP , 1 - LAP : basegridsys % nyc + LAP )) allocate ( basegridsys % kxy_c ( 1 - LAP : basegridsys % nxc + LAP , 1 - LAP : basegridsys % nyc + LAP )) allocate ( basegridsys % kh2_c ( 1 - LAP : basegridsys % nxc + LAP , 1 - LAP : basegridsys % nyc + LAP )) basegridsys % u_c = ( 0.d0 , 0.d0 ) basegridsys % rhs_c = ( 0.d0 , 0.d0 ) basegridsys % res_c = ( 0.d0 , 0.d0 ) basegridsys % kxy_c = grid % wavenumber_k basegridsys % kh2_c = grid % wavenumber_kh_pow_2 end subroutine gridsys_define subroutine coarsegrid_create ( mg_coarse , mg_fine ) !! This is a routine that define a coarse grid system mg_coarse from a fine grid system mg_fine implicit none type ( GridSystem ), intent ( inout ) :: mg_coarse , mg_fine integer ( kind = 4 ) :: k mg_coarse % nxc_global = ( mg_fine % nxc_global - 1 ) / 2 + 1 mg_coarse % nyc_global = ( mg_fine % nyc_global - 1 ) / 2 + 1 mg_coarse % hxc = slx / ( mg_coarse % nxc_global - 1 ) mg_coarse % hyc = sly / ( mg_coarse % nyc_global - 1 ) mg_coarse % hxhyc = mg_coarse % hxc * mg_coarse % hyc if ( mod ( mg_fine % ic_offset ( npx ), 2 ) == 0 ) then if ( mod ( mg_fine % nxc , 2 ) == 0 ) then mg_coarse % nxc = mg_fine % nxc / 2 else mg_coarse % nxc = ( mg_fine % nxc - 1 ) / 2 endif else if ( mod ( mg_fine % nxc , 2 ) == 0 ) then mg_coarse % nxc = mg_fine % nxc / 2 else mg_coarse % nxc = ( mg_fine % nxc + 1 ) / 2 endif endif if ( mod ( mg_fine % jc_offset ( npy ), 2 ) == 0 ) then if ( mod ( mg_fine % nyc , 2 ) == 0 ) then mg_coarse % nyc = mg_fine % nyc / 2 else mg_coarse % nyc = ( mg_fine % nyc - 1 ) / 2 endif else if ( mod ( mg_fine % nyc , 2 ) == 0 ) then mg_coarse % nyc = mg_fine % nyc / 2 else mg_coarse % nyc = ( mg_fine % nyc + 1 ) / 2 endif endif do k = 0 , npx0 - 1 if ( mod ( mg_fine % ic_offset ( k ), 2 ) == 0 ) then mg_coarse % ic_offset ( k ) = ( mg_fine % ic_offset ( k ) + 1 + 1 ) / 2 if ( mod ( mg_fine % ic_nn ( k ), 2 ) == 0 ) then mg_coarse % ic_nn ( k ) = mg_fine % ic_nn ( k ) / 2 else mg_coarse % ic_nn ( k ) = ( mg_fine % ic_nn ( k ) - 1 ) / 2 endif else mg_coarse % ic_offset ( k ) = ( mg_fine % ic_offset ( k ) + 1 ) / 2 if ( mod ( mg_fine % ic_nn ( k ), 2 ) == 0 ) then mg_coarse % ic_nn ( k ) = mg_fine % ic_nn ( k ) / 2 else mg_coarse % ic_nn ( k ) = ( mg_fine % ic_nn ( k ) + 1 ) / 2 endif endif enddo do k = 0 , npy0 - 1 if ( mod ( mg_fine % jc_offset ( k ), 2 ) == 0 ) then mg_coarse % jc_offset ( k ) = ( mg_fine % jc_offset ( k ) + 1 + 1 ) / 2 if ( mod ( mg_fine % jc_nn ( k ), 2 ) == 0 ) then mg_coarse % jc_nn ( k ) = mg_fine % jc_nn ( k ) / 2 else mg_coarse % jc_nn ( k ) = ( mg_fine % jc_nn ( k ) - 1 ) / 2 endif else mg_coarse % jc_offset ( k ) = ( mg_fine % jc_offset ( k ) + 1 ) / 2 if ( mod ( mg_fine % jc_nn ( k ), 2 ) == 0 ) then mg_coarse % jc_nn ( k ) = mg_fine % jc_nn ( k ) / 2 else mg_coarse % jc_nn ( k ) = ( mg_fine % jc_nn ( k ) + 1 ) / 2 endif endif enddo allocate ( mg_coarse % u_c ( 1 - LAP : mg_coarse % nxc + LAP , 1 - LAP : mg_coarse % nyc + LAP )) allocate ( mg_coarse % rhs_c ( 1 - LAP : mg_coarse % nxc + LAP , 1 - LAP : mg_coarse % nyc + LAP )) allocate ( mg_coarse % res_c ( 1 - LAP : mg_coarse % nxc + LAP , 1 - LAP : mg_coarse % nyc + LAP )) allocate ( mg_coarse % kxy_c ( 1 - LAP : mg_coarse % nxc + LAP , 1 - LAP : mg_coarse % nyc + LAP )) allocate ( mg_coarse % kh2_c ( 1 - LAP : mg_coarse % nxc + LAP , 1 - LAP : mg_coarse % nyc + LAP )) mg_coarse % u_c = ( 0.d0 , 0.d0 ) mg_coarse % rhs_c = ( 0.d0 , 0.d0 ) mg_coarse % res_c = ( 0.d0 , 0.d0 ) mg_coarse % kxy_c = 0.d0 mg_coarse % kh2_c = 0.d0 end subroutine coarsegrid_create subroutine grid_destroy ( mg_dm ) !! This is a routine that deallocate the arrays of a grid system implicit none type ( GridSystem ), intent ( inout ) :: mg_dm deallocate ( mg_dm % u_c , mg_dm % rhs_c , mg_dm % res_c , mg_dm % kxy_c , mg_dm % kh2_c ) end subroutine grid_destroy subroutine restriction ( mg_coarse , mg_fine ) !! This is routine that perform full-weight resctriction from fine to coarse grid system, mainly !! residual (res) on fine grid --> right-hand side (rhs) on coarse grid, !! wavenumber on fine grid --> wavenumber on the coarse grid !! Based on the relationship of the index between the fine and coarse grid implicit none type ( GridSystem ), intent ( inout ) :: mg_coarse , mg_fine integer :: ii , jj , iif , jjf , icH_global , jcH_global , ifh_global , jfh_global call mg_check_xy2d ( mg_fine % res_c , mg_fine % nxc , mg_fine % nyc ) call mg_checkreal_xy2d ( mg_fine % kxy_c , mg_fine % nxc , mg_fine % nyc ) do jj = 1 , mg_coarse % nyc do ii = 1 , mg_coarse % nxc icH_global = mg_coarse % ic_offset ( npx ) - 1 + ii jcH_global = mg_coarse % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( mg_fine % ic_offset ( npx ) - 1 ) jjf = jfh_global - ( mg_fine % jc_offset ( npy ) - 1 ) mg_coarse % rhs_c ( ii , jj ) = ( 4.d0 * mg_fine % res_c ( iif , jjf ) & + 2.d0 * mg_fine % res_c ( iif - 1 , jjf ) + 2.d0 * mg_fine % res_c ( iif + 1 , jjf ) & + 2.d0 * mg_fine % res_c ( iif , jjf - 1 ) + 2.d0 * mg_fine % res_c ( iif , jjf + 1 ) & + 1.d0 * mg_fine % res_c ( iif - 1 , jjf - 1 ) + 1.d0 * mg_fine % res_c ( iif - 1 , jjf + 1 ) & + 1.d0 * mg_fine % res_c ( iif + 1 , jjf - 1 ) + 1.d0 * mg_fine % res_c ( iif + 1 , jjf + 1 )) / 1 6.d0 mg_coarse % kxy_c ( ii , jj ) = ( 4.d0 * mg_fine % kxy_c ( iif , jjf ) & + 2.d0 * mg_fine % kxy_c ( iif - 1 , jjf ) + 2.d0 * mg_fine % kxy_c ( iif + 1 , jjf ) & + 2.d0 * mg_fine % kxy_c ( iif , jjf - 1 ) + 2.d0 * mg_fine % kxy_c ( iif , jjf + 1 ) & + 1.d0 * mg_fine % kxy_c ( iif - 1 , jjf - 1 ) + 1.d0 * mg_fine % kxy_c ( iif - 1 , jjf + 1 ) & + 1.d0 * mg_fine % kxy_c ( iif + 1 , jjf - 1 ) + 1.d0 * mg_fine % kxy_c ( iif + 1 , jjf + 1 )) / 1 6.d0 if ( npx == 0 . and . ii == 1 ) then mg_coarse % rhs_c ( ii , jj ) = mg_fine % res_c ( iif , jjf ) mg_coarse % kxy_c ( ii , jj ) = mg_fine % kxy_c ( iif , jjf ) endif if ( npx == npx0 - 1 . and . ii == mg_coarse % nxc ) then mg_coarse % rhs_c ( ii , jj ) = mg_fine % res_c ( iif , jjf ) mg_coarse % kxy_c ( ii , jj ) = mg_fine % kxy_c ( iif , jjf ) endif if ( npy == 0 . and . jj == 1 ) then mg_coarse % rhs_c ( ii , jj ) = mg_fine % res_c ( iif , jjf ) mg_coarse % kxy_c ( ii , jj ) = mg_fine % kxy_c ( iif , jjf ) endif if ( npy == npy0 - 1 . and . jj == mg_coarse % nyc ) then mg_coarse % rhs_c ( ii , jj ) = mg_fine % res_c ( iif , jjf ) mg_coarse % kxy_c ( ii , jj ) = mg_fine % kxy_c ( iif , jjf ) endif enddo enddo if ( npx == 0 . and . npy == 0 ) then mg_coarse % rhs_c ( 1 , 1 ) = mg_fine % res_c ( 1 , 1 ) mg_coarse % kxy_c ( 1 , 1 ) = mg_fine % kxy_c ( 1 , 1 ) endif if ( npx == npx0 - 1 . and . npy == 0 ) then mg_coarse % rhs_c ( mg_coarse % nxc , 1 ) = mg_fine % res_c ( mg_fine % nxc , 1 ) mg_coarse % kxy_c ( mg_coarse % nxc , 1 ) = mg_fine % kxy_c ( mg_fine % nxc , 1 ) endif if ( npx == 0 . and . npy == npy0 - 1 ) then mg_coarse % rhs_c ( 1 , mg_coarse % nyc ) = mg_fine % res_c ( 1 , mg_fine % nyc ) mg_coarse % kxy_c ( 1 , mg_coarse % nyc ) = mg_fine % kxy_c ( 1 , mg_fine % nyc ) endif if ( npx == npx0 - 1 . and . npy == npy0 - 1 ) then mg_coarse % rhs_c ( mg_coarse % nxc , mg_coarse % nyc ) = mg_fine % res_c ( mg_fine % nxc , mg_fine % nyc ) mg_coarse % kxy_c ( mg_coarse % nxc , mg_coarse % nyc ) = mg_fine % kxy_c ( mg_fine % nxc , mg_fine % nyc ) endif mg_coarse % kh2_c = mg_coarse % kxy_c * mg_coarse % kxy_c * mg_coarse % hxhyc end subroutine restriction subroutine prolongation_en_correct ( mg_coarse , mg_fine ) !! This is routine that perform bilinear interpolation and correction from coarse to fine grid system, mainly !! solution (u) on coarse grid --> correction (e_h) for solution (u) of fine grid !! Based on the relationship of the index between the fine and coarse grid implicit none type ( GridSystem ), intent ( inout ) :: mg_coarse , mg_fine complex ( kind = realdp ), allocatable , dimension (:,:) :: e_h !! Correction integer :: ii , jj , iif , jjf , icH_global , jcH_global , ifh_global , jfh_global allocate ( e_h ( 1 - LAP : mg_fine % nxc + LAP , 1 - LAP : mg_fine % nyc + LAP )) e_h = ( 0.d0 , 0.d0 ) call mg_check_xy2d ( mg_coarse % u_c , mg_coarse % nxc , mg_coarse % nyc ) do jj = 1 , mg_coarse % nyc do ii = 1 , mg_coarse % nxc icH_global = mg_coarse % ic_offset ( npx ) - 1 + ii jcH_global = mg_coarse % jc_offset ( npy ) - 1 + jj ifh_global = 2 * icH_global - 1 jfh_global = 2 * jcH_global - 1 iif = ifh_global - ( mg_fine % ic_offset ( npx ) - 1 ) jjf = jfh_global - ( mg_fine % jc_offset ( npy ) - 1 ) e_h ( iif , jjf ) = mg_coarse % u_c ( ii , jj ) e_h ( iif , jjf + 1 ) = ( mg_coarse % u_c ( ii , jj ) + mg_coarse % u_c ( ii , jj + 1 )) / 2.d0 e_h ( iif , jjf - 1 ) = ( mg_coarse % u_c ( ii , jj ) + mg_coarse % u_c ( ii , jj - 1 )) / 2.d0 e_h ( iif + 1 , jjf ) = ( mg_coarse % u_c ( ii , jj ) + mg_coarse % u_c ( ii + 1 , jj )) / 2.d0 e_h ( iif - 1 , jjf ) = ( mg_coarse % u_c ( ii , jj ) + mg_coarse % u_c ( ii - 1 , jj )) / 2.d0 e_h ( iif + 1 , jjf + 1 ) = ( mg_coarse % u_c ( ii + 1 , jj ) + mg_coarse % u_c ( ii , jj + 1 ) & + mg_coarse % u_c ( ii + 1 , jj + 1 ) + mg_coarse % u_c ( ii , jj )) / 4.d0 e_h ( iif + 1 , jjf - 1 ) = ( mg_coarse % u_c ( ii + 1 , jj ) + mg_coarse % u_c ( ii , jj - 1 ) & + mg_coarse % u_c ( ii + 1 , jj - 1 ) + mg_coarse % u_c ( ii , jj )) / 4.d0 e_h ( iif - 1 , jjf + 1 ) = ( mg_coarse % u_c ( ii - 1 , jj ) + mg_coarse % u_c ( ii , jj + 1 ) & + mg_coarse % u_c ( ii - 1 , jj + 1 ) + mg_coarse % u_c ( ii , jj )) / 4.d0 e_h ( iif - 1 , jjf - 1 ) = ( mg_coarse % u_c ( ii - 1 , jj ) + mg_coarse % u_c ( ii , jj - 1 ) & + mg_coarse % u_c ( ii - 1 , jj - 1 ) + mg_coarse % u_c ( ii , jj )) / 4.d0 enddo enddo mg_fine % u_c ( 1 : mg_fine % nxc , 1 : mg_fine % nyc ) = mg_fine % u_c ( 1 : mg_fine % nxc , 1 : mg_fine % nyc ) + e_h ( 1 : mg_fine % nxc , 1 : mg_fine % nyc ) deallocate ( e_h ) end subroutine prolongation_en_correct recursive subroutine V_cycle ( mg_fine ) !! A classic multigrid V-cycle implicit none type ( GridSystem ), intent ( inout ) :: mg_fine type ( GridSystem ) :: mg_coarse complex ( kind = realdp ), allocatable , dimension (:,:) :: op_Mx allocate ( op_Mx ( 1 - LAP : mg_fine % nxc + LAP , 1 - LAP : mg_fine % nyc + LAP )) op_Mx = ( 0.d0 , 0.d0 ) call Damp_Jacobi_smoother ( mg_fine % u_c , mg_fine % rhs_c , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) call CSLP_OP_BC ( mg_fine % u_c , op_Mx , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) mg_fine % res_c = mg_fine % rhs_c - op_Mx op_Mx = ( 0.d0 , 0.d0 ) deallocate ( op_Mx ) call coarsegrid_create ( mg_coarse , mg_fine ) call restriction ( mg_coarse , mg_fine ) if ( MG_flag == 0 ) then !! A classic Two-Cycle if ( cslp_mg_miter > 1 ) then !! GMRES or Bi-CGSTAB can be chose to solve the coarse-grid problem call mg_fullgmres ( mg_coarse ) else call mg_bicgstab ( mg_coarse ) endif else if ( mod ( mg_coarse % nxc_global - 1 , 2 ) == 0 . and . mg_coarse % nxc_global > nx_min . and . & mod ( mg_coarse % nyc_global - 1 , 2 ) == 0 . and . mg_coarse % nyc_global > nx_min ) then call V_cycle ( mg_coarse ) else if ( cslp_mg_miter > 1 ) then !! GMRES or Bi-CGSTAB can be chose to solve the coarsest-grid problem call mg_fullgmres ( mg_coarse ) else call mg_bicgstab ( mg_coarse ) endif endif endif call prolongation_en_correct ( mg_coarse , mg_fine ) call Damp_Jacobi_smoother ( mg_fine % u_c , mg_fine % rhs_c , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) call grid_destroy ( mg_coarse ) end subroutine V_cycle recursive subroutine F_cycle ( mg_fine ) !! This is a classic F-cycle multigrid implicit none type ( GridSystem ), intent ( inout ) :: mg_fine type ( GridSystem ) :: mg_coarse complex ( kind = realdp ), allocatable , dimension (:,:) :: op_Mx call Damp_Jacobi_smoother ( mg_fine % u_c , mg_fine % rhs_c , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) allocate ( op_Mx ( 1 - LAP : mg_fine % nxc + LAP , 1 - LAP : mg_fine % nyc + LAP )) op_Mx = ( 0.d0 , 0.d0 ) call CSLP_OP_BC ( mg_fine % u_c , op_Mx , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) mg_fine % res_c = mg_fine % rhs_c - op_Mx op_Mx = ( 0.d0 , 0.d0 ) deallocate ( op_Mx ) call coarsegrid_create ( mg_coarse , mg_fine ) call restriction ( mg_coarse , mg_fine ) if ( mod ( mg_coarse % nxc_global - 1 , 2 ) == 0 . and . mg_coarse % nxc_global > nx_min . and . & mod ( mg_coarse % nyc_global - 1 , 2 ) == 0 . and . mg_coarse % nyc_global > nx_min ) then call F_cycle ( mg_coarse ) else if ( cslp_mg_miter > 1 ) then call mg_fullgmres ( mg_coarse ) else call mg_bicgstab ( mg_coarse ) endif endif call prolongation_en_correct ( mg_coarse , mg_fine ) call Damp_Jacobi_smoother ( mg_fine % u_c , mg_fine % rhs_c , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) call grid_destroy ( mg_coarse ) allocate ( op_Mx ( 1 - LAP : mg_fine % nxc + LAP , 1 - LAP : mg_fine % nyc + LAP )) op_Mx = ( 0.d0 , 0.d0 ) call CSLP_OP_BC ( mg_fine % u_c , op_Mx , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) mg_fine % res_c = mg_fine % rhs_c - op_Mx op_Mx = ( 0.d0 , 0.d0 ) deallocate ( op_Mx ) call coarsegrid_create ( mg_coarse , mg_fine ) call restriction ( mg_coarse , mg_fine ) if ( mod ( mg_coarse % nxc_global - 1 , 2 ) == 0 . and . mg_coarse % nxc_global > nx_min . and . & mod ( mg_coarse % nyc_global - 1 , 2 ) == 0 . and . mg_coarse % nyc_global > nx_min ) then call V_cycle ( mg_coarse ) else if ( cslp_mg_miter > 1 ) then call mg_fullgmres ( mg_coarse ) else call mg_bicgstab ( mg_coarse ) endif endif call prolongation_en_correct ( mg_coarse , mg_fine ) call Damp_Jacobi_smoother ( mg_fine % u_c , mg_fine % rhs_c , mg_fine % nxc , mg_fine % nyc , & mg_fine % hxc , mg_fine % hyc , mg_fine % kxy_c , mg_fine % kh2_c ) call grid_destroy ( mg_coarse ) end subroutine F_cycle subroutine mg_fullgmres ( mg_solve ) !! This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using GMRES !! The CSLP is define by ReD-O2 scheme implicit none !Subroutine arguments ------------------------------------------------------- type ( GridSystem ), intent ( inout ) :: mg_solve !! The current coarsest grid system !Local arguments ------------------------------------------------------------ real ( kind = realdp ) :: Rerror !! Relative residual integer :: iter !! The number of iterations integer :: k , ki , j real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: Au0 , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V ! Subroutine content --------------------------------------------------------- allocate ( sn ( cslp_mg_miter + 1 ), cs ( cslp_mg_miter + 1 ), beta ( cslp_mg_miter + 1 )) allocate ( Au0 ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( H ( cslp_mg_miter + 1 , cslp_mg_miter )) allocate ( V ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP , cslp_mg_miter + 1 )) b_norm = mg_norm ( mg_solve % rhs_c , mg_solve % nxc , mg_solve % nyc ) Au0 = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) call CSLP_OP_BC ( mg_solve % u_c , Au0 , mg_solve % nxc , mg_solve % nyc , & mg_solve % hxc , mg_solve % hyc , mg_solve % kxy_c , mg_solve % kh2_c ) ! Compute Ax mg_solve % res_c = mg_solve % rhs_c - Au0 !r=b-Ax res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) ! ||r|| if ( res_norm == 0. ) then if ( my_id . eq . 0 ) then write ( * , \"(A)\" ) \"   CSLP RHS = 0 , Error = 0 \" endif else Rerror = res_norm / b_norm ! scaled residual beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = mg_solve % res_c / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , cslp_mg_miter k = k + 1 !!Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. call mg_arnoldi ( V , H , k , mg_solve % nxc , mg_solve % nyc , mg_solve % hxc , mg_solve % hyc ,& mg_solve % kxy_c , mg_solve % kh2_c ) call mg_apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( Rerror < 1.d-8 ) then !! The default tolerance is 1E-08 exit end if enddo if ( my_id . eq . 0 ) then write ( * , \"(A,I9,A,E16.9)\" ) \"  Final MGsolve GMRES Iter.    \" , k , \"     Rel. res =\" , Rerror endif call mg_back_substitute ( H , beta , k ) do ki = 1 , k mg_solve % u_c = mg_solve % u_c + beta ( ki ) * V (:,:, ki ) enddo endif deallocate ( sn , cs , beta ) deallocate ( Au0 ) !, res,u0 deallocate ( H ) deallocate ( V ) iter = k end subroutine mg_fullgmres !==================================================================================== subroutine mg_arnoldi ( V , H , k , ni , nj , hx_c , hy_c , kxy , kh2 ) !! Arnoldi precess implicit none ! Subroutine arguments ------------------------------------------------------- integer , intent ( in ) :: ni , nj , k real ( kind = realdp ), intent ( in ) :: hx_c , hy_c complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP , cslp_mg_miter + 1 ), intent ( inout ) :: V complex ( kind = realdp ), dimension ( cslp_mg_miter + 1 , cslp_mg_miter ), intent ( inout ) :: H real ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: kxy , kh2 ! Local arguments ------------------------------------------------------------ integer :: i ! Subroutine content --------------------------------------------------------- call CSLP_OP_BC ( V (:,:, k ), V (:,:, k + 1 ), ni , nj , hx_c , hy_c , kxy , kh2 ) !!  w=A*v_i do i = 1 , k H ( i , k ) = mg_dot_prod ( V (:,:, i ), V (:,:, k + 1 ), ni , nj ) !! Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = mg_norm ( V (:,:, k + 1 ), ni , nj ) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) end subroutine mg_arnoldi ! SUBROUTINE APPLY_GIVENS_ROTATION ==================================================== subroutine mg_apply_givens_rotation ( H , cs , sn , k ) !! This is routine to perform apply_givens_rotation implicit none ! Subroutine arguments ------------------------------------------------------- integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( cslp_mg_miter + 1 , cslp_mg_miter ), intent ( inout ) :: H complex ( kind = realdp ), dimension ( cslp_mg_miter + 1 ), intent ( inout ) :: cs , sn ! Local arguments ------------------------------------------------------------ complex ( kind = realdp ) :: temp integer :: i ! Subroutine content --------------------------------------------------------- do i = 1 , k - 1 temp = conjg ( cs ( i )) * H ( i , k ) + conjg ( sn ( i )) * H ( i + 1 , k ) H ( i + 1 , k ) = - sn ( i ) * H ( i , k ) + cs ( i ) * H ( i + 1 , k ) H ( i , k ) = temp end do if ( H ( k , k ) == 0. ) then cs ( k ) = 0.0d0 sn ( k ) = 1.0d0 else temp = CDSQRT (( CDABS ( H ( k , k ))) ** 2 + ( H ( k + 1 , k )) ** 2 ) cs ( k ) = H ( k , k ) / temp sn ( k ) = H ( k + 1 , k ) / temp end if H ( k , k ) = conjg ( cs ( k )) * H ( k , k ) + conjg ( sn ( k )) * H ( k + 1 , k ) H ( k + 1 , k ) = ( 0.0d0 , 0.0d0 ) end subroutine mg_apply_givens_rotation ! SUBROUTINE BACK_SUBSTITUTION ========================================================= subroutine mg_back_substitute ( H , beta , k ) !! This is routine that performs back substitute implicit none integer :: i integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( cslp_mg_miter + 1 , cslp_mg_miter ), intent ( in ) :: H complex ( kind = realdp ), dimension ( cslp_mg_miter + 1 ), intent ( inout ) :: beta beta ( k ) = beta ( k ) / H ( k , k ) do i = k - 1 , 1 , - 1 beta ( i ) = ( beta ( i ) - sum ( H ( i , i + 1 : k ) * beta ( i + 1 : k ))) / H ( i , i ) end do end subroutine mg_back_substitute !Algorithm Bi-CSGTAB========================================================================= subroutine mg_bicgstab ( mg_solve , maximum_iterations ) !! This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using Bi-CGSTAB !! The CSLP is define by ReD-O2 scheme implicit none ! Subroutine arguments ------------------------------------------------------- type ( GridSystem ), intent ( inout ) :: mg_solve ! optional arguments integer , optional , intent ( in ) :: maximum_iterations !! User-specified maximum number of iterations integer :: iter !! iter: the number of iterations integer :: maxit !! maxit: the maximum number of iterations, default is 3000, the default tolerance is 1E-08 complex ( kind = realdp ), allocatable , dimension (:,:) :: res_hat , Au0 , vi , p , s , t complex ( kind = realdp ) :: rho_cg , rho0_cg complex ( kind = realdp ) :: alpha_cg , omega_cg , beta_cg real ( kind = realdp ) :: res_norm , b_norm maxit = 3000 if ( present ( maximum_iterations ) ) maxit = maximum_iterations allocate ( res_hat ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( vi ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( p ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( s ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( t ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( Au0 ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) rho_cg = ( 1.d0 , 0.d0 ) alpha_cg = ( 1.d0 , 0.d0 ) omega_cg = ( 1.d0 , 0.d0 ) vi = ( 0.d0 , 0.d0 ) p = ( 0.d0 , 0.d0 ) s = ( 0.d0 , 0.d0 ) t = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) call CSLP_OP_BC ( mg_solve % u_c , Au0 , mg_solve % nxc , mg_solve % nyc , & mg_solve % hxc , mg_solve % hyc , mg_solve % kxy_c , mg_solve % kh2_c ) mg_solve % res_c = mg_solve % rhs_c - Au0 !r=b-Ax res_hat = mg_solve % res_c res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) b_norm = mg_norm ( mg_solve % rhs_c , mg_solve % nxc , mg_solve % nyc ) if ( res_norm == 0. ) then if ( my_id . eq . 0 ) then write ( * , \"(A)\" ) \"   CSLP RHS = 0 , Error = 0 \" endif else iter = 0 do while ( res_norm /= 0.d0 . and . res_norm > 1.d-8 * b_norm . and . iter < maxit ) rho0_cg = rho_cg rho_cg = mg_dot_prod ( res_hat , mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) if ( rho_cg == czero ) then write ( * , * ) \"OMG, rho=0!\" stop endif beta_cg = ( rho_cg / rho0_cg ) * ( alpha_cg / omega_cg ) p = mg_solve % res_c + beta_cg * ( p - omega_cg * vi ) call CSLP_OP_BC ( p , vi , mg_solve % nxc , mg_solve % nyc , & mg_solve % hxc , mg_solve % hyc , mg_solve % kxy_c , mg_solve % kh2_c ) alpha_cg = rho_cg / mg_dot_prod ( res_hat , vi , mg_solve % nxc , mg_solve % nyc ) if ( alpha_cg == czero ) then write ( * , * ) \"OMG, alpha_cg=0!\" stop endif s = mg_solve % res_c - alpha_cg * vi if ( mg_norm ( s , mg_solve % nxc , mg_solve % nyc ) < 1.d-8 * b_norm ) then mg_solve % u_c = mg_solve % u_c + alpha_cg * p Au0 = czero call CSLP_OP_BC ( mg_solve % u_c , Au0 , mg_solve % nxc , mg_solve % nyc , & mg_solve % hxc , mg_solve % hyc , mg_solve % kxy_c , mg_solve % kh2_c ) mg_solve % res_c = mg_solve % rhs_c - Au0 res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) Exit endif call CSLP_OP_BC ( s , t , mg_solve % nxc , mg_solve % nyc , & mg_solve % hxc , mg_solve % hyc , mg_solve % kxy_c , mg_solve % kh2_c ) omega_cg = mg_dot_prod ( t , s , mg_solve % nxc , mg_solve % nyc ) & / mg_dot_prod ( t , t , mg_solve % nxc , mg_solve % nyc ) if ( omega_cg == czero ) then write ( * , * ) \"OMG, omega_cg=0!\" stop endif mg_solve % u_c = mg_solve % u_c + alpha_cg * p + omega_cg * s mg_solve % res_c = s - omega_cg * t res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) iter = iter + 1 end do !-------> END OF While LOOP if ( my_id . eq . 0 ) then write ( * , \"(A,I5,A,E16.9)\" ) \"            Final MGsolve BiCGSTAB Iter.    \" , iter , \"     Rel. res =\" , res_norm / b_norm end if endif deallocate ( vi , p , s , t , res_hat , Au0 ) end subroutine mg_bicgstab subroutine ReD_Glk_CSLP_bicgstab ( mg_solve , grid , maximum_iterations ) !! This is a rountine to solve a coarse grid CSLP system approximately by using Bi-CGSTAB. !! The CSLP operator is defined by ReD-Glk scheme. implicit none ! Subroutine arguments ------------------------------------------------------- type ( GridSystem ), intent ( inout ) :: mg_solve !! The current coarse grid system type ( Gridpara ) :: grid !! Parameters of current coarse grid ! optional arguments integer , optional , intent ( in ) :: maximum_iterations integer :: iter !! iter: the number of iterations integer :: maxit !! maxit: the maximum number of iterations, default is 1000 complex ( kind = realdp ), allocatable , dimension (:,:) :: res_hat , Au0 , vi , p , s , t complex ( kind = realdp ) :: rho_cg , rho0_cg complex ( kind = realdp ) :: alpha_cg , omega_cg , beta_cg real ( kind = realdp ) :: res_norm , b_norm , s_norm !------------------------END PARAMETER AND VARIABLE-----------------------------! maxit = 1000 if ( present ( maximum_iterations ) ) maxit = maximum_iterations allocate ( res_hat ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( vi ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( p ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( s ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( t ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( Au0 ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) rho_cg = ( 1.d0 , 0.d0 ) alpha_cg = ( 1.d0 , 0.d0 ) omega_cg = ( 1.d0 , 0.d0 ) vi = ( 0.d0 , 0.d0 ) p = ( 0.d0 , 0.d0 ) s = ( 0.d0 , 0.d0 ) t = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) Au0 = CSLP_Mx_nth ( mg_solve % u_c , grid ) ! Ax !! CSLP operator by ReD-Glk mg_solve % res_c = mg_solve % rhs_c - Au0 !r=b-Ax res_hat = mg_solve % res_c res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) b_norm = mg_norm ( mg_solve % rhs_c , mg_solve % nxc , mg_solve % nyc ) if ( res_norm == 0. ) then if ( my_id . eq . 0 ) then write ( * , \"(A)\" ) \"   CSLP RHS = 0 , Error = 0 \" endif else iter = 0 do while ( res_norm /= 0.d0 . and . res_norm > cslp_mg_tol * b_norm . and . iter < maxit ) rho0_cg = rho_cg rho_cg = mg_dot_prod ( res_hat , mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) if ( rho_cg == czero ) then write ( * , * ) \"OMG, rho=0!\" stop endif beta_cg = ( rho_cg / rho0_cg ) * ( alpha_cg / omega_cg ) p = mg_solve % res_c + beta_cg * ( p - omega_cg * vi ) vi = CSLP_Mx_nth ( p , grid ) alpha_cg = rho_cg / mg_dot_prod ( res_hat , vi , mg_solve % nxc , mg_solve % nyc ) if ( alpha_cg == czero ) then write ( * , * ) \"OMG, alpha_cg=0!\" stop endif s = mg_solve % res_c - alpha_cg * vi s_norm = mg_norm ( s , mg_solve % nxc , mg_solve % nyc ) if ( s_norm < cslp_mg_tol * 1.d-1 * b_norm ) then mg_solve % u_c = mg_solve % u_c + alpha_cg * p Au0 = czero Au0 = CSLP_Mx_nth ( mg_solve % u_c , grid ) mg_solve % res_c = mg_solve % rhs_c - Au0 res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) Exit endif t = CSLP_Mx_nth ( s , grid ) omega_cg = mg_dot_prod ( t , s , mg_solve % nxc , mg_solve % nyc ) & / mg_dot_prod ( t , t , mg_solve % nxc , mg_solve % nyc ) if ( omega_cg == czero ) then write ( * , * ) \"OMG, omega_cg=0!\" stop endif mg_solve % u_c = mg_solve % u_c + alpha_cg * p + omega_cg * s mg_solve % res_c = s - omega_cg * t res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) iter = iter + 1 end do !-------> END OF While LOOP if ( my_id . eq . 0 ) then write ( * , \"(A,I5,A,E16.9)\" ) \"            Final CSLPsolve BiCGSTAB Iter.    \" , iter , \"     Rel. res =\" , res_norm / b_norm end if endif deallocate ( vi , p , s , t , res_hat , Au0 ) end subroutine ReD_Glk_CSLP_bicgstab subroutine ReD_Glk_CSLP_gmres ( mg_solve , grid , maximum_iterations ) !! This is a rountine to solve a coarse grid CSLP system approximately by using GMRES !! The CSLP operator is defined by ReD-Glk scheme implicit none ! Subroutine arguments ------------------------------------------------------- type ( GridSystem ), intent ( inout ) :: mg_solve type ( Gridpara ) :: grid ! optional arguments integer , optional , intent ( in ) :: maximum_iterations !! User-specified maximum number of iterations,default is 300 ! Local arguments ------------------------------------------------------------ real ( kind = realdp ) :: Rerror integer :: iter , maxit , k , ki , i , j real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ) :: temp complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: Au0 , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V integer ( kind = 4 ) :: level_i ! optional present maxit = 200 if ( present ( maximum_iterations ) ) maxit = maximum_iterations ! Subroutine content --------------------------------------------------------- level_i = int ( LOG2 ( dble (( nx_global - 1 ) / ( grid % nx_global - 1 )))) + 1 allocate ( sn ( maxit + 1 ), cs ( maxit + 1 ), beta ( maxit + 1 )) allocate ( Au0 ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP )) allocate ( H ( maxit + 1 , maxit )) allocate ( V ( 1 - LAP : mg_solve % nxc + LAP , 1 - LAP : mg_solve % nyc + LAP , maxit + 1 )) b_norm = mg_norm ( mg_solve % rhs_c , mg_solve % nxc , mg_solve % nyc ) Au0 = czero sn = czero cs = czero V = czero H = czero beta = czero Au0 = CSLP_Mx_nth ( mg_solve % u_c , grid ) ! Compute Ax !! CSLP operator by ReD-Glk mg_solve % res_c = mg_solve % rhs_c - Au0 !r=b-Ax res_norm = mg_norm ( mg_solve % res_c , mg_solve % nxc , mg_solve % nyc ) ! ||r|| Au0 = mg_solve % u_c ! storge the initial u instead if ( res_norm == 0. ) then if ( my_id . eq . 0 ) then write ( * , \"(A)\" ) \"   CSLP RHS = 0 , Error = 0 \" endif else Rerror = res_norm / b_norm ! scaled error beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = mg_solve % res_c / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , maxit k = k + 1 !!Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. !---------------------START arnoldi process---------------------------------- V (:,:, k + 1 ) = CSLP_Mx_nth ( V (:,:, k ), grid ) do i = 1 , k H ( i , k ) = mg_dot_prod ( V (:,:, i ), V (:,:, k + 1 ), mg_solve % nxc , mg_solve % nyc ) !! Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = mg_norm ( V (:,:, k + 1 ), mg_solve % nxc , mg_solve % nyc ) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) !---------------------END arnoldi process---------------------------------- !---------------------START givens_rotation---------------------------------- do i = 1 , k - 1 temp = conjg ( cs ( i )) * H ( i , k ) + conjg ( sn ( i )) * H ( i + 1 , k ) H ( i + 1 , k ) = - sn ( i ) * H ( i , k ) + cs ( i ) * H ( i + 1 , k ) H ( i , k ) = temp end do if ( H ( k , k ) == 0 ) then cs ( k ) = 0.0d0 sn ( k ) = 1.0d0 else temp = CDSQRT (( CDABS ( H ( k , k ))) ** 2 + ( H ( k + 1 , k )) ** 2 ) cs ( k ) = H ( k , k ) / temp sn ( k ) = H ( k + 1 , k ) / temp end if H ( k , k ) = conjg ( cs ( k )) * H ( k , k ) + conjg ( sn ( k )) * H ( k + 1 , k ) H ( k + 1 , k ) = ( 0.0d0 , 0.0d0 ) !---------------------END givens_rotation---------------------------------- beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( Rerror < cslp_mg_tol ) then ! The tolerance for the coarse-grid CSLP solver is set in the Input file exit end if enddo if ( my_id . eq . 0 ) then write ( * , \"(A,I9,A,E16.9)\" ) \"  Final CSLPsolve GMRES Iter.    \" , k , \"     Rel. res =\" , Rerror endif !!---call back_substitute(H,beta,k)--------------------------------- beta ( k ) = beta ( k ) / H ( k , k ) do i = k - 1 , 1 , - 1 beta ( i ) = ( beta ( i ) - sum ( H ( i , i + 1 : k ) * beta ( i + 1 : k ))) / H ( i , i ) end do !!------------------------------------------------------------------ mg_solve % u_c = czero ! make use of the memmory, use as a temp variable here do ki = 1 , k mg_solve % u_c = mg_solve % u_c + beta ( ki ) * V (:,:, ki ) enddo mg_solve % u_c = mg_solve % u_c + Au0 endif deallocate ( sn , cs , beta ) deallocate ( Au0 ) deallocate ( H ) deallocate ( V ) iter = k end subroutine ReD_Glk_CSLP_gmres end module CSLP_Solver","tags":"","loc":"sourcefile/cslp_solver.f90.html"},{"title":"MPI_setup.f90 – ParaMADP","text":"This file depends on sourcefile~~mpi_setup.f90~~EfferentGraph sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mpi_setup.f90~~AfferentGraph sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~mpi_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mpi_setup.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 sourcefile~main.f90->sourcefile~wavenumber.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90->sourcefile~operators.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module mpi_setup !! Module for setting up MPI partition and data exchange use mpi use comm_variable implicit none contains integer function my_mod1 ( na , nb ) !! A function to calculate the modulo of two integers na and nb implicit none integer :: na , nb if ( na < 0 ) then my_mod1 = na + nb else if ( na > nb - 1 ) then my_mod1 = na - nb else my_mod1 = na endif return end function my_mod1 !************************************************************************************************ subroutine part2d () !! Partitions the 2D domain for parallel processing and calculates offsets and sizes for each partition implicit none integer :: k , ka , npx1_x , npx1_y , npx2_x , npx2_y , npy1_x , npy1_y , npy2_x , npy2_y if ( np_size /= npx0 * npy0 ) then if ( my_id == 0 ) then write ( * , * ) 'Number of Total Procs is ' , np_size write ( * , \"('Number of Total procs is not equal to npx0*npy0=',I5,' !!!')\" ) npx0 * npy0 endif stop endif !! the ID of partion along 2 directions npx = mod ( my_id , npx0 ) npy = mod ( my_id , npx0 * npy0 ) / npx0 nx = nx_global / npx0 ny = ny_global / npy0 if ( npx < mod ( nx_global , npx0 )) then nx = nx + 1 endif if ( npy < mod ( ny_global , npy0 )) then ny = ny + 1 endif do k = 0 , npx0 - 1 ka = min ( k , mod ( nx_global , npx0 )) i_offset ( k ) = int ( nx_global / npx0 ) * k + ka + 1 i_nn ( k ) = nx_global / npx0 if ( k < mod ( nx_global , npx0 )) then i_nn ( k ) = i_nn ( k ) + 1 endif enddo do k = 0 , npy0 - 1 ka = min ( k , mod ( ny_global , npy0 )) j_offset ( k ) = int ( ny_global / npy0 ) * k + ka + 1 j_nn ( k ) = ny_global / npy0 if ( k < mod ( ny_global , npy0 )) then j_nn ( k ) = j_nn ( k ) + 1 endif enddo npx1_x = my_mod1 ( npx - 1 , npx0 ) npx2_x = my_mod1 ( npx + 1 , npx0 ) npx1_y = npy npx2_y = npy ID_XM1 = npx1_y * npx0 + npx1_x !! -1 proc in x-direction ID_XP1 = npx2_y * npx0 + npx2_x !! +1 proc in x-direction if ( Iperiodic_X == 0 . and . npx == 0 ) then ID_XM1 = MPI_PROC_NULL !! if not periodic, 0 node donot send mesg to npx0-1 node endif if ( Iperiodic_X == 0 . and . npx == npx0 - 1 ) then ID_XP1 = MPI_PROC_NULL !! if not periodic, npx0-1 node donot send mesg to 0 node endif npy1_x = npx npy2_x = npx npy1_y = my_mod1 ( npy - 1 , npy0 ) npy2_y = my_mod1 ( npy + 1 , npy0 ) ID_YM1 = npy1_y * npx0 + npy1_x ID_YP1 = npy2_y * npx0 + npy2_x if ( Iperiodic_Y == 0 . and . npy == 0 ) then ID_YM1 = MPI_PROC_NULL endif if ( Iperiodic_Y == 0 . and . npy == npy0 - 1 ) then ID_YP1 = MPI_PROC_NULL endif call MPI_barrier ( MPI_COMM_WORLD , ierr ) end subroutine part2d !************************************************************************************************ subroutine check_x2d ( f ) !! Exchanges data in the x direction, ONLY for the default (finest) grid system implicit none integer i , j , k1 complex ( kind = realdp ) :: f ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 complex ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 allocate ( tmp_send1 ( LAP * ny ), tmp_send2 ( LAP * ny )) allocate ( tmp_recv1 ( LAP * ny ), tmp_recv2 ( LAP * ny )) k1 = 0 do i = 1 , LAP do j = 1 , ny k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( nx - LAP + i , j ) enddo enddo if ( npx == 0 ) then k1 = 0 do i = 1 , LAP do j = 1 , ny k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i + 1 , j ) enddo enddo endif if ( npx == npx0 - 1 ) then k1 = 0 do i = 1 , LAP do j = 1 , ny k1 = k1 + 1 tmp_send2 ( k1 ) = f ( nx - LAP + i - 1 , j ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_COMPLEX , ID_XM1 , 9021 , & tmp_recv2 , k1 , MPI_DOUBLE_COMPLEX , ID_XP1 , 9021 , MPI_COMM_WORLD , Status , ierr ) call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_COMPLEX , ID_XP1 , 8021 , & tmp_recv1 , k1 , MPI_DOUBLE_COMPLEX , ID_XM1 , 8021 , MPI_COMM_WORLD , Status , ierr ) if ( ID_XM1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , ny k1 = k1 + 1 f ( i - LAP , j ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_XP1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , ny k1 = k1 + 1 f ( nx + i , j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine check_x2d !************************************************************************************************ subroutine check_y2d ( f ) !! Exchanges data in the y direction, ONLY for the default (finest) grid system implicit none integer i , j , k1 complex ( kind = realdp ) :: f ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) complex ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 complex ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 allocate ( tmp_send1 ( LAP * ( nx + 2 * LAP )), tmp_send2 ( LAP * ( nx + 2 * LAP ))) allocate ( tmp_recv1 ( LAP * ( nx + 2 * LAP )), tmp_recv2 ( LAP * ( nx + 2 * LAP ))) k1 = 0 do j = 1 , LAP do i = 1 - LAP , nx + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( i , ny + j - LAP ) enddo enddo if ( npy == 0 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , nx + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j + 1 ) enddo enddo endif if ( npy == npy0 - 1 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , nx + LAP k1 = k1 + 1 tmp_send2 ( k1 ) = f ( i , ny + j - LAP - 1 ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_COMPLEX , ID_YM1 , 9022 , & tmp_recv2 , k1 , MPI_DOUBLE_COMPLEX , ID_YP1 , 9022 , MPI_COMM_WORLD , Status , ierr ) call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_COMPLEX , ID_YP1 , 022 , & tmp_recv1 , k1 , MPI_DOUBLE_COMPLEX , ID_YM1 , 022 , MPI_COMM_WORLD , Status , ierr ) if ( ID_YM1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , nx + LAP k1 = k1 + 1 f ( i , j - LAP ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_YP1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , nx + LAP !!no2 k1 = k1 + 1 f ( i , ny + j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine check_y2d !************************************************************************************************ subroutine check_xy2d ( f ) !! Exchanges data first in the x direction and then y direction, ONLY for the default (finest) grid system implicit none complex ( kind = realdp ) :: f ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) call check_x2d ( f ) call check_y2d ( f ) end subroutine check_xy2d !************************************************************************************************ subroutine mg_check_x2d ( f , ni , nj ) !! Exchanges data in the x direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj complex ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) complex ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 complex ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 integer i , j , k1 allocate ( tmp_send1 ( LAP * nj ), tmp_send2 ( LAP * nj )) allocate ( tmp_recv1 ( LAP * nj ), tmp_recv2 ( LAP * nj )) k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( ni - LAP + i , j ) enddo enddo if ( npx == 0 ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i + 1 , j ) enddo enddo endif if ( npx == npx0 - 1 ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send2 ( k1 ) = f ( ni - LAP + i - 1 , j ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_COMPLEX , ID_XM1 , 9421 , & tmp_recv2 , k1 , MPI_DOUBLE_COMPLEX , ID_XP1 , 9421 , MPI_COMM_WORLD , Status , ierr ) !!no2 call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_COMPLEX , ID_XP1 , 421 , & tmp_recv1 , k1 , MPI_DOUBLE_COMPLEX , ID_XM1 , 421 , MPI_COMM_WORLD , Status , ierr ) !!no2 if ( ID_XM1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 f ( i - LAP , j ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_XP1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 f ( ni + i , j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine mg_check_x2d !************************************************************************************************ subroutine mg_check_y2d ( f , ni , nj ) !! Exchanges data in the y direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj complex ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) complex ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 complex ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 integer i , j , k1 allocate ( tmp_send1 ( LAP * ( ni + 2 * LAP )), tmp_send2 ( LAP * ( ni + 2 * LAP ))) allocate ( tmp_recv1 ( LAP * ( ni + 2 * LAP )), tmp_recv2 ( LAP * ( ni + 2 * LAP ))) k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( i , nj + j - LAP ) enddo enddo if ( npy == 0 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j + 1 ) enddo enddo endif if ( npy == npy0 - 1 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send2 ( k1 ) = f ( i , nj + j - LAP - 1 ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_COMPLEX , ID_YM1 , 9422 , & tmp_recv2 , k1 , MPI_DOUBLE_COMPLEX , ID_YP1 , 9422 , MPI_COMM_WORLD , Status , ierr ) !!no2 call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_COMPLEX , ID_YP1 , 8422 , & tmp_recv1 , k1 , MPI_DOUBLE_COMPLEX , ID_YM1 , 8422 , MPI_COMM_WORLD , Status , ierr ) !!no2 if ( ID_YM1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 f ( i , j - LAP ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_YP1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 f ( i , nj + j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine mg_check_y2d !************************************************************************************************ subroutine mg_check_xy2d ( f , ni , nj ) !! Exchanges data first in the x direction and then y direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj complex ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) call mg_check_x2d ( f , ni , nj ) call mg_check_y2d ( f , ni , nj ) end subroutine mg_check_xy2d !************************************************************************************************ subroutine mg_checkreal_x2d ( f , ni , nj ) !! Exchanges REAL data in the x direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj real ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) real ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 real ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 integer i , j , k1 allocate ( tmp_send1 ( LAP * nj ), tmp_send2 ( LAP * nj )) allocate ( tmp_recv1 ( LAP * nj ), tmp_recv2 ( LAP * nj )) k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( ni - LAP + i , j ) enddo enddo if ( npx == 0 ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i + 1 , j ) enddo enddo endif if ( npx == npx0 - 1 ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 tmp_send2 ( k1 ) = f ( ni - LAP + i - 1 , j ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_PRECISION , ID_XM1 , 9421 , & tmp_recv2 , k1 , MPI_DOUBLE_PRECISION , ID_XP1 , 9421 , MPI_COMM_WORLD , Status , ierr ) !!no2 call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_PRECISION , ID_XP1 , 421 , & tmp_recv1 , k1 , MPI_DOUBLE_PRECISION , ID_XM1 , 421 , MPI_COMM_WORLD , Status , ierr ) !!no2 if ( ID_XM1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 f ( i - LAP , j ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_XP1 /= MPI_PROC_NULL ) then k1 = 0 do i = 1 , LAP do j = 1 , nj k1 = k1 + 1 f ( ni + i , j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine mg_checkreal_x2d !************************************************************************************************ subroutine mg_checkreal_y2d ( f , ni , nj ) !! Exchanges REAL data in the y direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj real ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) real ( kind = realdp ), allocatable , dimension (:) :: tmp_send1 , tmp_send2 real ( kind = realdp ), allocatable , dimension (:) :: tmp_recv1 , tmp_recv2 integer i , j , k1 allocate ( tmp_send1 ( LAP * ( ni + 2 * LAP )), tmp_send2 ( LAP * ( ni + 2 * LAP ))) allocate ( tmp_recv1 ( LAP * ( ni + 2 * LAP )), tmp_recv2 ( LAP * ( ni + 2 * LAP ))) k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j ) tmp_send2 ( k1 ) = f ( i , nj + j - LAP ) enddo enddo if ( npy == 0 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send1 ( k1 ) = f ( i , j + 1 ) enddo enddo endif if ( npy == npy0 - 1 ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 tmp_send2 ( k1 ) = f ( i , nj + j - LAP - 1 ) enddo enddo endif call MPI_Sendrecv ( tmp_send1 , k1 , MPI_DOUBLE_PRECISION , ID_YM1 , 9422 , & tmp_recv2 , k1 , MPI_DOUBLE_PRECISION , ID_YP1 , 9422 , MPI_COMM_WORLD , Status , ierr ) !!no2 call MPI_Sendrecv ( tmp_send2 , k1 , MPI_DOUBLE_PRECISION , ID_YP1 , 8422 , & tmp_recv1 , k1 , MPI_DOUBLE_PRECISION , ID_YM1 , 8422 , MPI_COMM_WORLD , Status , ierr ) !!no2 if ( ID_YM1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 f ( i , j - LAP ) = tmp_recv1 ( k1 ) enddo enddo endif if ( ID_YP1 /= MPI_PROC_NULL ) then k1 = 0 do j = 1 , LAP do i = 1 - LAP , ni + LAP k1 = k1 + 1 f ( i , nj + j ) = tmp_recv2 ( k1 ) enddo enddo endif deallocate ( tmp_send1 , tmp_send2 ) deallocate ( tmp_recv1 , tmp_recv2 ) end subroutine mg_checkreal_y2d !************************************************************************************************ subroutine mg_checkreal_xy2d ( f , ni , nj ) !! Exchanges REAL data first in the x direction and then y direction, for a specified-size grid system implicit none integer , intent ( in ) :: ni , nj real ( kind = realdp ) :: f ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) call mg_checkreal_x2d ( f , ni , nj ) call mg_checkreal_y2d ( f , ni , nj ) end subroutine mg_checkreal_xy2d end module mpi_setup","tags":"","loc":"sourcefile/mpi_setup.f90.html"},{"title":"RHS.f90 – ParaMADP","text":"This file depends on sourcefile~~rhs.f90~~EfferentGraph sourcefile~rhs.f90 RHS.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~rhs.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rhs.f90~~AfferentGraph sourcefile~rhs.f90 RHS.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~rhs.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module define_rhs !! This is a module to determine the right-hand side for different model problems use mpi use comm_variable implicit none contains subroutine RHS_2DCloseOff ( b , xx , yy ) !! 2D close-off problem with Dirichlet boundary condition implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: b real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j do j = 1 , ny do i = 1 , nx b ( i , j ) = 5.d0 * pi * pi * ( sin ( pi * xx ( i , j )) * sin ( 2.d0 * pi * yy ( i , j ))) & - k0 * k0 * ( sin ( pi * xx ( i , j )) * sin ( 2.d0 * pi * yy ( i , j )) + 1.d0 ) if ( npx == 0 . and . i == 1 ) then b ( i , j ) = ( 1.d0 , 0.d0 ) endif if ( npx == npx0 - 1 . and . i == nx ) then b ( i , j ) = ( 1.d0 , 0.d0 ) endif if ( npy == 0 . and . j == 1 ) then b ( i , j ) = ( 1.d0 , 0.d0 ) endif if ( npy == npy0 - 1 . and . j == ny ) then b ( i , j ) = ( 1.d0 , 0.d0 ) endif enddo enddo end subroutine RHS_2DCloseOff subroutine RHS_CenterSource2D ( b , xx , yy ) !! 2D constant wavenumber problem with a central point source implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: b real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j do j = 1 , ny do i = 1 , nx !! A point source located at (0.5,0.5) if ( 0.5d0 - hx / 2.d0 <= xx ( i , j ) . and . xx ( i , j ) <= 0.5d0 + hx / 2.d0 & . and . 0.5d0 - hy / 2.d0 <= yy ( i , j ) . and . yy ( i , j ) <= 0.5d0 + hy / 2.d0 ) then b ( i , j ) = 1.d0 / hx / hy else b ( i , j ) = 0.d0 endif enddo enddo end subroutine RHS_CenterSource2D subroutine RHS_2DWedge ( b , xx , yy ) !! 2D Wedge problem implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: b real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j do j = 1 , ny do i = 1 , nx !! A point source located at (300,0) if ( 30 0.d0 - hx / 2.d0 <= xx ( i , j ) . and . xx ( i , j ) <= 30 0.d0 + hx / 2.d0 & . and . 0.d0 - hy / 2.d0 <= yy ( i , j ) . and . yy ( i , j ) <= 0.d0 + hy / 2.d0 ) then b ( i , j ) = 1.d0 / hx / hy else b ( i , j ) = 0.d0 endif enddo enddo end subroutine RHS_2DWedge subroutine RHS_marmousi ( b , xx , yy ) !! Marmousi problem implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: b real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j do j = 1 , ny do i = 1 , nx !! A point source located at (6000,0) if ( 600 0.d0 - hx / 2.d0 <= xx ( i , j ) . and . xx ( i , j ) <= 600 0.d0 + hx / 2.d0 & . and . 0.d0 - hy / 2.d0 <= yy ( i , j ) . and . yy ( i , j ) <= 0.d0 + hy / 2.d0 ) then b ( i , j ) = 1.d0 / hx / hy else b ( i , j ) = 0.d0 endif enddo enddo end subroutine RHS_marmousi end module define_rhs !=====================================","tags":"","loc":"sourcefile/rhs.f90.html"},{"title":"wavenumber.f90 – ParaMADP","text":"This file depends on sourcefile~~wavenumber.f90~~EfferentGraph sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~wavenumber.f90~~AfferentGraph sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~operators.f90 Operators.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~wavenumber.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90->sourcefile~operators.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module wavenumber !! This module is used to determine the wavenumber of the computational domain, as well as (kh)&#94;2 use mpi use comm_variable use mpi_setup implicit none real ( kind = realdp ), allocatable , dimension (:,:) :: wavenumber_k real ( kind = realdp ), allocatable , dimension (:,:) :: kh_pow_2 ! If the wavenumber_k is not initialized to zero, some unexpected values will occur in parallel computing. ! It will leads to crash. Ex. MP3 nx2305f40 np192 contains subroutine Const_K () !! constant wavenumber, determine by input variable k0 implicit none allocate ( wavenumber_k ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( kh_pow_2 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) wavenumber_k = 0.d0 kh_pow_2 = 0.d0 wavenumber_k = k0 kh_pow_2 = k0 * k0 * hxhy !! data communication with neighbouring subdomains call mg_checkreal_xy2d ( wavenumber_k , nx , ny ) call mg_checkreal_xy2d ( kh_pow_2 , nx , ny ) end subroutine Const_K subroutine wavenumber_k_Wedge ( xx , yy ) !! Wavenumber for Wedge model problem implicit none real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy real ( kind = realdp ) :: c1 , c2 , c3 !! Three acoustis velocity for three layers integer :: i , j allocate ( wavenumber_k ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) wavenumber_k = 0.d0 c1 = 200 0.d0 ! m/s c2 = 150 0.d0 ! m/s c3 = 300 0.d0 ! m/s do j = 1 , ny do i = 1 , nx if ( yy ( i , j ) > - 1.d0 / 6.d0 * xx ( i , j ) - 40 0.d0 ) then !! The top layer wavenumber_k ( i , j ) = 2.d0 * pi * freq / c1 elseif ( yy ( i , j ) < 1.d0 / 3.d0 * xx ( i , j ) - 80 0.d0 ) then !! The bottom layer wavenumber_k ( i , j ) = 2.d0 * pi * freq / c3 else !! The middle layer wavenumber_k ( i , j ) = 2.d0 * pi * freq / c2 endif enddo enddo allocate ( kh_pow_2 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) kh_pow_2 = 0.d0 kh_pow_2 = wavenumber_k * wavenumber_k * hxhy call mg_checkreal_xy2d ( wavenumber_k , nx , ny ) call mg_checkreal_xy2d ( kh_pow_2 , nx , ny ) end subroutine wavenumber_k_Wedge subroutine read_wavenumber_k_marmousi () !! Read the velocity profile of Marmousi problem with specified grid size and calculate the wavenumber implicit none real ( kind = realdp ), allocatable , dimension (:,:) :: vp_global !! Global velocity profile real ( kind = realdp ), allocatable , dimension (:,:) :: temp_vp !! Local velocity profile for subdomains integer i , j , i_global , j_global , ii , jj , k3 real ( kind = realdp ) :: temp allocate ( wavenumber_k ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) wavenumber_k = 0.d0 allocate ( vp_global ( 1 : nx_global , 1 : ny_global )) if ( my_id . eq . 0 ) then ! Rank 0: read the velocity data from files starting with \"vp_\" in Input directory, with specified grid size write ( filename , \"('Input/vp_nx',I5.5,'ny',I4.4,'.plt')\" ) nx_global , ny_global open ( 77 , file = trim ( filename ), status = 'old' ) read ( 77 , * ) read ( 77 , * ) do jj = 1 , ny_global do ii = 1 , nx_global read ( 77 , * ) temp , temp , vp_global ( ii , jj ) enddo enddo close ( 77 ) !========must remember that the data you read is velocity, ===================! !========don't forget to transfer them to wavenumber within every processor===! do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then ! Rank 0 do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj wavenumber_k ( ii , jj ) = 2.d0 * pi * freq / vp_global ( i_global , j_global ) enddo enddo else ! Send to the other ranks allocate ( temp_vp ( i_nn ( i ), j_nn ( j ))) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 temp_vp ( ii , jj ) = vp_global ( i_global , j_global ) enddo enddo call MPI_SEND ( temp_vp , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 9200 , MPI_COMM_WORLD , ierr ) deallocate ( temp_vp ) endif enddo enddo else ! The other ranks:  receive data and compute wavenumber allocate ( temp_vp ( i_nn ( npx ), j_nn ( npy ))) call MPI_RECV ( temp_vp , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 9200 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) wavenumber_k ( ii , jj ) = 2.d0 * pi * freq / temp_vp ( ii , jj ) enddo enddo deallocate ( temp_vp ) endif deallocate ( vp_global ) allocate ( kh_pow_2 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) kh_pow_2 = 0.d0 kh_pow_2 = wavenumber_k * wavenumber_k * hxhy call mg_checkreal_xy2d ( wavenumber_k , nx , ny ) call mg_checkreal_xy2d ( kh_pow_2 , nx , ny ) end subroutine read_wavenumber_k_marmousi subroutine wavenumber_k_destroy () !! Deallocate the wavenumber field in the end implicit none deallocate ( wavenumber_k , kh_pow_2 ) end subroutine wavenumber_k_destroy end module","tags":"","loc":"sourcefile/wavenumber.f90.html"},{"title":"DefineGrid.f90 – ParaMADP","text":"This file depends on sourcefile~~definegrid.f90~~EfferentGraph sourcefile~definegrid.f90 DefineGrid.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~definegrid.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~definegrid.f90~~AfferentGraph sourcefile~definegrid.f90 DefineGrid.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~definegrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module define_grid !! This is a module to determine the grid coordinate. !! First determined by Rank 0 and then distributed to the other ranks. !! For now, only rectangular domain with uniform space step size, i.e. hx==hy. use mpi use comm_variable implicit none contains subroutine define_uniform_grid ( phys1 , phys2 ) !! A square computational domain with a unit side length implicit none real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: phys1 , phys2 !! Local coordinates in x and y directions real ( kind = realdp ), allocatable , dimension (:,:) :: phys1_global , phys2_global !! Global coordinates in x and y directions real ( kind = realdp ), allocatable , dimension (:,:) :: temp_phys1 , temp_phys2 !! Temp local coordinates in x and y directions for data sending integer :: i , j , ka , i_global , j_global , ii , jj hy = sly / dble ( ny_global - 1 ) hx = slx / dble ( nx_global - 1 ) if ( my_id . eq . 0 ) then allocate ( phys1_global ( 1 : nx_global , 1 : ny_global ), phys2_global ( 1 : nx_global , 1 : ny_global )) do j = 1 , ny_global do i = 1 , nx_global phys1_global ( i , j ) = 0.d0 + dble ( i - 1 ) * hx phys2_global ( i , j ) = 0.d0 + dble ( j - 1 ) * hy enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 ka = j * npx0 + i if ( ka . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo else allocate ( temp_phys1 ( i_nn ( i ), j_nn ( j )), temp_phys2 ( i_nn ( i ), j_nn ( j ))) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 temp_phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) temp_phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo call MPI_SEND ( temp_phys1 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 1 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_phys2 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 2 , MPI_COMM_WORLD , ierr ) deallocate ( temp_phys1 , temp_phys2 ) endif enddo enddo deallocate ( phys1_global , phys2_global ) else !(my_id .eq. 0) allocate ( temp_phys1 ( i_nn ( npx ), j_nn ( npy )), temp_phys2 ( i_nn ( npx ), j_nn ( npy ))) call MPI_RECV ( temp_phys1 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_phys2 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 2 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) phys1 ( ii , jj ) = temp_phys1 ( ii , jj ) phys2 ( ii , jj ) = temp_phys2 ( ii , jj ) enddo enddo deallocate ( temp_phys1 , temp_phys2 ) endif end subroutine define_uniform_grid subroutine define_wedge_grid ( phys1 , phys2 ) !! Wedge model problem implicit none real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: phys1 , phys2 real ( kind = realdp ), allocatable , dimension (:,:) :: phys1_global , phys2_global real ( kind = realdp ), allocatable , dimension (:,:) :: temp_phys1 , temp_phys2 integer :: i , j , ka , i_global , j_global , ii , jj hy = sly / dble ( ny_global - 1 ) hx = slx / dble ( nx_global - 1 ) if ( my_id . eq . 0 ) then allocate ( phys1_global ( 1 : nx_global , 1 : ny_global ), phys2_global ( 1 : nx_global , 1 : ny_global )) do j = 1 , ny_global do i = 1 , nx_global phys1_global ( i , j ) = 0.d0 + dble ( i - 1 ) * hx phys2_global ( i , j ) =- sly + dble ( j - 1 ) * hy enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 ka = j * npx0 + i if ( ka . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo else allocate ( temp_phys1 ( i_nn ( i ), j_nn ( j )), temp_phys2 ( i_nn ( i ), j_nn ( j ))) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 temp_phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) temp_phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo call MPI_SEND ( temp_phys1 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 1 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_phys2 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 2 , MPI_COMM_WORLD , ierr ) deallocate ( temp_phys1 , temp_phys2 ) endif enddo enddo deallocate ( phys1_global , phys2_global ) else !(my_id .eq. 0) allocate ( temp_phys1 ( i_nn ( npx ), j_nn ( npy )), temp_phys2 ( i_nn ( npx ), j_nn ( npy ))) call MPI_RECV ( temp_phys1 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_phys2 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 2 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) phys1 ( ii , jj ) = temp_phys1 ( ii , jj ) phys2 ( ii , jj ) = temp_phys2 ( ii , jj ) enddo enddo deallocate ( temp_phys1 , temp_phys2 ) endif !(my_id .eq. 0) end subroutine define_wedge_grid subroutine define_marmousi_grid ( phys1 , phys2 ) !! Marmousi problem implicit none real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: phys1 , phys2 real ( kind = realdp ), allocatable , dimension (:,:) :: phys1_global , phys2_global real ( kind = realdp ), allocatable , dimension (:,:) :: temp_phys1 , temp_phys2 integer :: i , j , ka , i_global , j_global , ii , jj hy = sly / dble ( ny_global - 1 ) hx = slx / dble ( nx_global - 1 ) if ( my_id . eq . 0 ) then allocate ( phys1_global ( 1 : nx_global , 1 : ny_global ), phys2_global ( 1 : nx_global , 1 : ny_global )) do j = 1 , ny_global do i = 1 , nx_global phys1_global ( i , j ) = 0.d0 + dble ( i - 1 ) * hx phys2_global ( i , j ) =- sly + dble ( j - 1 ) * hy enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 ka = j * npx0 + i if ( ka . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo else allocate ( temp_phys1 ( i_nn ( i ), j_nn ( j )), temp_phys2 ( i_nn ( i ), j_nn ( j ))) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 temp_phys1 ( ii , jj ) = phys1_global ( i_global , j_global ) temp_phys2 ( ii , jj ) = phys2_global ( i_global , j_global ) enddo enddo call MPI_SEND ( temp_phys1 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 1 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_phys2 , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , & ka , 2 , MPI_COMM_WORLD , ierr ) deallocate ( temp_phys1 , temp_phys2 ) endif enddo enddo deallocate ( phys1_global , phys2_global ) else !(my_id .eq. 0) allocate ( temp_phys1 ( i_nn ( npx ), j_nn ( npy )), temp_phys2 ( i_nn ( npx ), j_nn ( npy ))) call MPI_RECV ( temp_phys1 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_phys2 , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , & 0 , 2 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) phys1 ( ii , jj ) = temp_phys1 ( ii , jj ) phys2 ( ii , jj ) = temp_phys2 ( ii , jj ) enddo enddo deallocate ( temp_phys1 , temp_phys2 ) endif !(my_id .eq. 0) end subroutine define_marmousi_grid end module define_grid","tags":"","loc":"sourcefile/definegrid.f90.html"},{"title":"Smoother.f90 – ParaMADP","text":"This file depends on sourcefile~~smoother.f90~~EfferentGraph sourcefile~smoother.f90 Smoother.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~smoother.f90~~AfferentGraph sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90 solvers.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~user_module.f90 user_module.f90 sourcefile~user_module.f90->sourcefile~cslp_solver.f90 sourcefile~user_module.f90->sourcefile~deflation_setup.f90 sourcefile~idrs_module.f90 idrs_module.f90 sourcefile~idrs_module.f90->sourcefile~user_module.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 sourcefile~main.f90->sourcefile~user_module.f90 sourcefile~main.f90->sourcefile~idrs_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module smoother !! A smoother module use comm_variable use mpi_setup use define_BC use operators implicit none contains subroutine Damp_Jacobi_smoother ( x , rhs , ni , nj , hx_c , hy_c , kxy , kh2 ) !! This is a routine to apply damped Jacobbi smoother on coarse grid systems. implicit none integer , intent ( in ) :: ni , nj !! subdomain grid size on the current coarse level real ( kind = realdp ), intent ( in ) :: hx_c , hy_c !! coarse-grid space step size real ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ), intent ( in ) :: kxy , kh2 !! Wavenumber and (kh)&#94;2 complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) :: x complex ( kind = realdp ), dimension ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP ) :: rhs !! local arguements complex ( kind = realdp ), allocatable , dimension (:,:) :: x_tmp complex ( kind = realdp ) :: ap real ( kind = realdp ) :: ae , aw , an , as !! Computational stencils integer :: k , sm_step , i , j real ( kind = 8 ) :: omega !! Relaxation factor, 0.8 by default sm_step = 1 allocate ( x_tmp ( 1 - LAP : ni + LAP , 1 - LAP : nj + LAP )) omega = 0.8d0 x_tmp = ( 0.d0 , 0.d0 ) do k = 1 , sm_step call mg_check_xy2d ( x , ni , nj ) ! data communication, coarse level j = 1 do i = 1 , ni call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo j = nj do i = 1 , ni call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo i = 1 do j = 2 , nj - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo i = ni do j = 2 , nj - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo if ( flag_BCs == 1 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) call if_BCs ( ap , an , as , aw , ae , i , j , ni , nj , hx_c , hy_c , kxy ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo enddo elseif ( flag_BCs == 2 ) then do j = 2 , nj - 1 do i = 2 , ni - 1 call cslp2d_stencils ( ap , an , as , aw , ae , kh2 ( i , j )) !============================== x_tmp ( i , j ) = ( rhs ( i , j ) - ( ae * x ( i + 1 , j ) + aw * x ( i - 1 , j ) & + an * x ( i , j + 1 ) + as * x ( i , j - 1 )) / hx_c / hy_c ) / ( ap / hx_c / hy_c ) enddo enddo endif x = omega * x_tmp + ( 1 - omega ) * x enddo deallocate ( x_tmp ) end subroutine Damp_Jacobi_smoother end module smoother","tags":"","loc":"sourcefile/smoother.f90.html"},{"title":"Write_data.f90 – ParaMADP","text":"This file depends on sourcefile~~write_data.f90~~EfferentGraph sourcefile~write_data.f90 Write_data.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~write_data.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~write_data.f90~~AfferentGraph sourcefile~write_data.f90 Write_data.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~write_data.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module write_data !! A module for solutions output. !! The idea is to collect the data from the other ranks to rank 0, and then write into a tecplot file (.plt). ! There are three \"repeated\" variants so far: ! one for the numerical solution, one for the exact/analytical solution, one for data with real type (wavenumber) ! To improve: an version that can handle different tpyes of input data and can manually specify the output filename. use mpi use comm_variable implicit none contains subroutine write_data_whole ( xx , yy , u ) !! Write the solutions implicit none integer :: i , j , k3 , i_global , j_global , ii , jj real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u real ( kind = realdp ), allocatable , dimension (:,:) :: xx_global , yy_global complex ( kind = realdp ), allocatable , dimension (:,:) :: u_global real ( kind = realdp ), allocatable , dimension (:,:) :: temp_xx , temp_yy complex ( kind = realdp ), allocatable , dimension (:,:) :: temp_u allocate ( xx_global ( 1 : nx_global , 1 : ny_global ), yy_global ( 1 : nx_global , 1 : ny_global )) allocate ( u_global ( 1 : nx_global , 1 : ny_global )) if ( my_id . eq . 0 ) then do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj xx_global ( i_global , j_global ) = xx ( ii , jj ) yy_global ( i_global , j_global ) = yy ( ii , jj ) enddo enddo else allocate ( temp_xx ( i_nn ( i ), j_nn ( j )), temp_yy ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_xx , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_yy , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 2 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 xx_global ( i_global , j_global ) = temp_xx ( ii , jj ) yy_global ( i_global , j_global ) = temp_yy ( ii , jj ) enddo enddo deallocate ( temp_xx , temp_yy ) endif enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj u_global ( i_global , j_global ) = u ( ii , jj ) enddo enddo else allocate ( temp_u ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_u , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_COMPLEX , k3 , 4 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 u_global ( i_global , j_global ) = temp_u ( ii , jj ) enddo enddo deallocate ( temp_u ) endif enddo enddo !===output plt for whole-area write ( filename , \"('Output/MP',I1,'BC',I1,'nx',I5.5,'k',I5.5,     & & 'thm',I2.2,'pre',I1,'nldef',I1,                & & 'np',I3.3,'.plt')\" ) & & i_case , flag_BCs , nx_global , int ( k0 ), & & Algorithm , M_flag , def_nlevel , & & npx0 * npy0 open ( 70 , file = trim ( filename )) write ( 70 , * ) 'variables=x,y,u' write ( 70 , * ) 'zone i=' , nx_global , ' j=' , ny_global !write(70,*)'solutiontime=',iter*dt,'strandid=',strandid do jj = 1 , ny_global do ii = 1 , nx_global write ( 70 , * ) xx_global ( ii , jj ), yy_global ( ii , jj ), real ( u_global ( ii , jj )) enddo enddo close ( 70 ) else !if (my_id .eq. 0 ) allocate ( temp_xx ( i_nn ( npx ), j_nn ( npy )), temp_yy ( i_nn ( npx ), j_nn ( npy )), & temp_u ( i_nn ( npx ), j_nn ( npy ))) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_xx ( ii , jj ) = xx ( ii , jj ) temp_yy ( ii , jj ) = yy ( ii , jj ) enddo enddo do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_u ( ii , jj ) = u ( ii , jj ) enddo enddo call MPI_SEND ( temp_xx , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 1 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_yy , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 2 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_u , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_COMPLEX , 0 , 4 , MPI_COMM_WORLD , ierr ) deallocate ( temp_xx , temp_yy , temp_u ) endif !if (my_id .eq. 0 ) deallocate ( xx_global , yy_global ) deallocate ( u_global ) end subroutine write_data_whole subroutine write_exact_data_whole ( xx , yy , u ) !! Write the analytical solutions implicit none integer :: i , j , k3 , i_global , j_global , ii , jj real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u real ( kind = realdp ), allocatable , dimension (:,:) :: xx_global , yy_global complex ( kind = realdp ), allocatable , dimension (:,:) :: u_global real ( kind = realdp ), allocatable , dimension (:,:) :: temp_xx , temp_yy complex ( kind = realdp ), allocatable , dimension (:,:) :: temp_u allocate ( xx_global ( 1 : nx_global , 1 : ny_global ), yy_global ( 1 : nx_global , 1 : ny_global )) allocate ( u_global ( 1 : nx_global , 1 : ny_global )) if ( my_id . eq . 0 ) then do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj xx_global ( i_global , j_global ) = xx ( ii , jj ) yy_global ( i_global , j_global ) = yy ( ii , jj ) enddo enddo else allocate ( temp_xx ( i_nn ( i ), j_nn ( j )), temp_yy ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_xx , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 10 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_yy , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 20 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 xx_global ( i_global , j_global ) = temp_xx ( ii , jj ) yy_global ( i_global , j_global ) = temp_yy ( ii , jj ) enddo enddo deallocate ( temp_xx , temp_yy ) endif enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj u_global ( i_global , j_global ) = u ( ii , jj ) enddo enddo else allocate ( temp_u ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_u , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_COMPLEX , k3 , 40 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 u_global ( i_global , j_global ) = temp_u ( ii , jj ) enddo enddo deallocate ( temp_u ) endif enddo enddo !===output plt for whole-area write ( filename , \"('Output/MP',I1,'_BC',I1, '_exact_nx',I5.5,'k',I5.5,'thm',I2.2,'np',I3.3,'.plt')\" ) & int ( i_case ), int ( flag_BCs ), int ( nx_global ), int ( k0 ), Algorithm , npx0 * npy0 open ( 71 , file = trim ( filename )) write ( 71 , * ) 'variables=x,y,u' write ( 71 , * ) 'zone i=' , nx_global , ' j=' , ny_global !write(71,*)'solutiontime=',iter*dt,'strandid=',strandid do jj = 1 , ny_global do ii = 1 , nx_global write ( 71 , * ) xx_global ( ii , jj ), yy_global ( ii , jj ), real ( u_global ( ii , jj )) enddo enddo close ( 71 ) else !if (my_id .eq. 0 ) allocate ( temp_xx ( i_nn ( npx ), j_nn ( npy )), temp_yy ( i_nn ( npx ), j_nn ( npy )), & temp_u ( i_nn ( npx ), j_nn ( npy ))) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_xx ( ii , jj ) = xx ( ii , jj ) temp_yy ( ii , jj ) = yy ( ii , jj ) enddo enddo do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_u ( ii , jj ) = u ( ii , jj ) enddo enddo call MPI_SEND ( temp_xx , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 10 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_yy , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 20 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_u , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_COMPLEX , 0 , 40 , MPI_COMM_WORLD , ierr ) deallocate ( temp_xx , temp_yy , temp_u ) endif !if (my_id .eq. 0 ) deallocate ( xx_global , yy_global ) deallocate ( u_global ) end subroutine write_exact_data_whole subroutine write_real_data_whole ( xx , yy , u ) !! Write the real wavenumber/variables implicit none integer :: i , j , k3 , i_global , j_global , ii , jj real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u real ( kind = realdp ), allocatable , dimension (:,:) :: xx_global , yy_global real ( kind = realdp ), allocatable , dimension (:,:) :: u_global real ( kind = realdp ), allocatable , dimension (:,:) :: temp_xx , temp_yy real ( kind = realdp ), allocatable , dimension (:,:) :: temp_u allocate ( xx_global ( 1 : nx_global , 1 : ny_global ), yy_global ( 1 : nx_global , 1 : ny_global )) allocate ( u_global ( 1 : nx_global , 1 : ny_global )) if ( my_id . eq . 0 ) then do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj xx_global ( i_global , j_global ) = xx ( ii , jj ) yy_global ( i_global , j_global ) = yy ( ii , jj ) enddo enddo else allocate ( temp_xx ( i_nn ( i ), j_nn ( j )), temp_yy ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_xx , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 10 , MPI_COMM_WORLD , status , ierr ) call MPI_RECV ( temp_yy , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 20 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 xx_global ( i_global , j_global ) = temp_xx ( ii , jj ) yy_global ( i_global , j_global ) = temp_yy ( ii , jj ) enddo enddo deallocate ( temp_xx , temp_yy ) endif enddo enddo do j = 0 , npy0 - 1 do i = 0 , npx0 - 1 k3 = j * npx0 + i if ( k3 . eq . 0 ) then do jj = 1 , ny do ii = 1 , nx i_global = i_offset ( i ) - 1 + ii j_global = j_offset ( j ) - 1 + jj u_global ( i_global , j_global ) = u ( ii , jj ) enddo enddo else allocate ( temp_u ( i_nn ( i ), j_nn ( j ))) call MPI_RECV ( temp_u , i_nn ( i ) * j_nn ( j ), MPI_DOUBLE_PRECISION , k3 , 40 , MPI_COMM_WORLD , status , ierr ) do jj = 1 , j_nn ( j ) do ii = 1 , i_nn ( i ) i_global = i_offset ( i ) + ii - 1 j_global = j_offset ( j ) + jj - 1 u_global ( i_global , j_global ) = temp_u ( ii , jj ) enddo enddo deallocate ( temp_u ) endif enddo enddo !===output plt for whole-area write ( filename , \"('Output/MP',I1,'_BC',I1, '_wn_nx',I5.5,'k',I5.5,'thm',I2.2,'np',I3.3,'.plt')\" ) & int ( i_case ), int ( flag_BCs ), int ( nx_global ), int ( k0 ), Algorithm , npx0 * npy0 open ( 71 , file = trim ( filename )) write ( 71 , * ) 'variables=x,y,k' write ( 71 , * ) 'zone i=' , nx_global , ' j=' , ny_global do jj = 1 , ny_global do ii = 1 , nx_global write ( 71 , * ) xx_global ( ii , jj ), yy_global ( ii , jj ), real ( u_global ( ii , jj )) enddo enddo close ( 71 ) else !if (my_id .eq. 0 ) allocate ( temp_xx ( i_nn ( npx ), j_nn ( npy )), temp_yy ( i_nn ( npx ), j_nn ( npy )), & temp_u ( i_nn ( npx ), j_nn ( npy ))) do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_xx ( ii , jj ) = xx ( ii , jj ) temp_yy ( ii , jj ) = yy ( ii , jj ) enddo enddo do jj = 1 , j_nn ( npy ) do ii = 1 , i_nn ( npx ) temp_u ( ii , jj ) = u ( ii , jj ) enddo enddo call MPI_SEND ( temp_xx , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 10 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_yy , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 20 , MPI_COMM_WORLD , ierr ) call MPI_SEND ( temp_u , i_nn ( npx ) * j_nn ( npy ), MPI_DOUBLE_PRECISION , 0 , 40 , MPI_COMM_WORLD , ierr ) deallocate ( temp_xx , temp_yy , temp_u ) endif !if (my_id .eq. 0 ) deallocate ( xx_global , yy_global ) deallocate ( u_global ) end subroutine write_real_data_whole end module write_data","tags":"","loc":"sourcefile/write_data.f90.html"},{"title":"analytical_sol.f90 – ParaMADP","text":"This file depends on sourcefile~~analytical_sol.f90~~EfferentGraph sourcefile~analytical_sol.f90 analytical_sol.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~analytical_sol.f90->sourcefile~comm_variable.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~analytical_sol.f90~~AfferentGraph sourcefile~analytical_sol.f90 analytical_sol.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~analytical_sol.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module analytical_sol !! This is a module to compute analytical solutions for some model problems use mpi use comm_variable implicit none contains subroutine exact_2DCloseOff ( u_ex , xx , yy ) !! The analytical solution for 2D close-off problem implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u_ex real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j do j = 1 , ny do i = 1 , nx u_ex ( i , j ) = dsin ( pi * xx ( i , j )) * dsin ( 2.d0 * pi * yy ( i , j )) + 1.d0 enddo enddo end subroutine exact_2DCloseOff subroutine exact_2DPointSource_1stSomer ( u_ex , xx , yy ) !! The analytical solution for constant wavenumber problem with central source point with Sommerfeld boundary condition implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u_ex real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: i , j real ( kind = realdp ) :: r do j = 1 , ny do i = 1 , nx r = dsqrt (( xx ( i , j ) - 0.5d0 ) ** 2 + ( yy ( i , j ) - 0.5d0 ) ** 2 ) if ( r == 0.d0 ) then r = hx / 2.d0 u_ex ( i , j ) = cone / 4.d0 * ( bessel_j0 ( k0 * r ) + cone * bessel_y0 ( k0 * r )) !better that twice! else u_ex ( i , j ) = cone / 4.d0 * ( bessel_j0 ( k0 * r ) + cone * bessel_y0 ( k0 * r )) endif enddo enddo end subroutine exact_2DPointSource_1stSomer subroutine exact_2DPointSource_Dirichlet ( u_ex , xx , yy ) !! The analytical solution for constant wavenumber problem with central source point with Dirichlet boundary condition ! Becareful it may take a lot of time to compute implicit none complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: u_ex real ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: xx , yy integer :: ii , jj do jj = 1 , ny_global do ii = 1 , nx_global u_ex = u_ex + 4 * ( sin ( jj * pi * xx ) * sin ( ii * pi * yy ) * sin ( ii * pi * 0.5d0 ) * sin ( jj * pi * 0.5d0 )) & / ( jj ** 2 * pi ** 2 + ii ** 2 * pi ** 2 - k0 ** 2 ) enddo enddo end subroutine exact_2DPointSource_Dirichlet end module analytical_sol !=====================================","tags":"","loc":"sourcefile/analytical_sol.f90.html"},{"title":"solvers.f90 – ParaMADP","text":"This file depends on sourcefile~~solvers.f90~~EfferentGraph sourcefile~solvers.f90 solvers.f90 sourcefile~comm_variable.f90 comm_variable.f90 sourcefile~solvers.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90 CSLP_Solver.f90 sourcefile~solvers.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90 deflation_setup.f90 sourcefile~solvers.f90->sourcefile~deflation_setup.f90 sourcefile~operators.f90 Operators.f90 sourcefile~solvers.f90->sourcefile~operators.f90 sourcefile~read_setup.f90 read_setup.f90 sourcefile~solvers.f90->sourcefile~read_setup.f90 sourcefile~cslp_solver.f90->sourcefile~comm_variable.f90 sourcefile~cslp_solver.f90->sourcefile~operators.f90 sourcefile~mpi_setup.f90 MPI_setup.f90 sourcefile~cslp_solver.f90->sourcefile~mpi_setup.f90 sourcefile~smoother.f90 Smoother.f90 sourcefile~cslp_solver.f90->sourcefile~smoother.f90 sourcefile~wavenumber.f90 wavenumber.f90 sourcefile~cslp_solver.f90->sourcefile~wavenumber.f90 sourcefile~deflation_setup.f90->sourcefile~comm_variable.f90 sourcefile~deflation_setup.f90->sourcefile~cslp_solver.f90 sourcefile~deflation_setup.f90->sourcefile~operators.f90 sourcefile~deflation_setup.f90->sourcefile~mpi_setup.f90 sourcefile~deflation_setup.f90->sourcefile~wavenumber.f90 sourcefile~operators.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~operators.f90->sourcefile~boundaries.f90 sourcefile~operators.f90->sourcefile~mpi_setup.f90 sourcefile~operators.f90->sourcefile~wavenumber.f90 sourcefile~read_setup.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~comm_variable.f90 sourcefile~boundaries.f90->sourcefile~wavenumber.f90 sourcefile~mpi_setup.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~comm_variable.f90 sourcefile~smoother.f90->sourcefile~operators.f90 sourcefile~smoother.f90->sourcefile~boundaries.f90 sourcefile~smoother.f90->sourcefile~mpi_setup.f90 sourcefile~wavenumber.f90->sourcefile~comm_variable.f90 sourcefile~wavenumber.f90->sourcefile~mpi_setup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~solvers.f90~~AfferentGraph sourcefile~solvers.f90 solvers.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solvers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module solvers !! Serveral GMRES-type Krylov solvers. Only applies to the (default) finest grid level use mpi use comm_variable use read_setup use operators use CSLP_Solver use deflaion_setup implicit none contains !==================================================================================== subroutine fullgmres ( b , u , Rerror , iter ) !! Full GMRES without precondition implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , ki , j real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , u0 , Au0 , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Au0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) ! what if b is real? res = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u0 , Au0 ) ! matrix-vec multiplication res = b - Au0 !r=b-Ax res_norm = norm ( res ) ! ||r|| Rerror = res_norm / b_norm ! scaled error beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = res / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. call arnoldi ( V , H , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) k , Rerror open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) write ( 1234 , \"(I9,E17.9)\" ) k , Rerror close ( 1234 ) end if if ( Rerror < eps ) then exit end if end do call back_substitute ( H , beta , k ) do ki = 1 , k u = u + beta ( ki ) * V (:,:, ki ) enddo iter = k deallocate ( sn , cs , beta ) deallocate ( res , u0 , Au0 ) deallocate ( H ) deallocate ( V ) end subroutine fullgmres !==================================================================================== !==================================================================================== subroutine restartgmres ( b , u , Rerror , iter_total ) !! Restart GMRES implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter_total !-Local arguments ------------------------------------------------------------ integer :: k , ki , j , Out_iter real ( kind = realdp ) :: b_norm , res0_norm , res_norm , pRerror complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res0 , res , u0 , Au0 , Au , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Au0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) Out_iter = 0 Rerror = 1.d0 do while ( Rerror > eps ) Out_iter = Out_iter + 1 res = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u0 , Au0 ) !-compute Ax res0 = b - Au0 !r=b-Ax res0_norm = norm ( res0 ) ! ||r|| beta ( 1 ) = res0_norm ! beta(1)=||r0|| V (:,:, 1 ) = res0 / res0_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. call arnoldi ( V , H , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) pRerror = CDABS ( beta ( k + 1 )) / b_norm end do call back_substitute ( H , beta , k ) do ki = 1 , k u = u + beta ( ki ) * V (:,:, ki ) enddo ! compute Ax call Helmholtz2d_BC ( u , Au ) res = b - Au !r=b-Ax res_norm = norm ( res ) ! ||r|| Rerror = res_norm / b_norm if ( my_id == 0 ) then write ( * , \"(A,I9,A,E14.6,A,E14.6)\" ) \"   Outer Iteration   \" , Out_iter , \"   pError   \" , pRerror , \"   Error   \" , Rerror end if enddo deallocate ( sn , cs , beta ) deallocate ( res0 , res , u0 , Au0 , Au ) deallocate ( H ) deallocate ( V ) iter_total = Out_iter * m_iter end subroutine restartgmres !==================================================================================== !==================================================================================== subroutine Pre_fullgmres ( b , u , Rerror , iter ) !! Full GMRES with left preconditioned implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , ki , j real ( kind = realdp ) :: b_norm , Mres_norm , Mb_norm , MRerror , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , Mres , Mb , u0 , Au0 , Au , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Mres ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Mb ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Au0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) ! ||b||_2 Mb = Precond_x ( b ) ! apply preconditioner, P&#94;(-1)b Mb_norm = norm ( Mb ) res = ( 0.d0 , 0.d0 ) Mres = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u0 , Au0 ) ! compute Ax res = b - Au0 !r=b-Ax Mres = Precond_x ( res ) ! M&#94;{-1}r  !Mres = res Mres_norm = norm ( Mres ) ! ||r|| MRerror = Mres_norm / Mb_norm ! scaled error beta ( 1 ) = Mres_norm ! beta(1)=||r0|| V (:,:, 1 ) = Mres / Mres_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. call Prearnoldi ( V , H , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) MRerror = CDABS ( beta ( k + 1 )) / Mb_norm if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) k , MRerror open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) write ( 1234 , \"(I9,E17.9)\" ) k , MRerror close ( 1234 ) end if if ( MRerror < eps ) then exit end if end do call back_substitute ( H , beta , k ) do ki = 1 , k u = u + beta ( ki ) * V (:,:, ki ) enddo call Helmholtz2d_BC ( u , Au ) res = b - Au res_norm = norm ( res ) Rerror = res_norm / b_norm deallocate ( sn , cs , beta ) deallocate ( res , Mres , Mb , u0 , Au0 , Au ) deallocate ( H ) deallocate ( V ) iter = k end subroutine Pre_fullgmres !==================================================================================== !==================================================================================== subroutine full_pgmres ( b , u , Rerror , iter ) !! Full GMRES with right precondition implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , ki , j , i real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , z , u0 , Au , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( z ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) res = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u , Au ) ! compute Ax res = b - Au !r=b-Ax res_norm = norm ( res ) ! ||r|| Rerror = res_norm / b_norm beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = res / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. z = Precond_x ( V (:,:, k )) call Helmholtz2d_BC ( z , V (:,:, k + 1 )) do i = 1 , k H ( i , k ) = dot_prod ( V (:,:, i ), V (:,:, k + 1 )) !-Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = norm ( V (:,:, k + 1 )) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) k , Rerror open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) write ( 1234 , \"(I9,E17.9)\" ) k , Rerror close ( 1234 ) end if if ( Rerror < eps ) then exit end if end do call back_substitute ( H , beta , k ) u = ( 0.d0 , 0.d0 ) do ki = 1 , k u = u + beta ( ki ) * V (:,:, ki ) enddo u = Precond_x ( u ) u = u + u0 call Helmholtz2d_BC ( u , Au ) res = b - Au res_norm = norm ( res ) Rerror = res_norm / b_norm deallocate ( sn , cs , beta ) deallocate ( res , z , u0 , Au ) deallocate ( H ) deallocate ( V ) iter = k end subroutine full_pgmres !==================================================================================== !==================================================================================== subroutine Pre_restartgmres ( b , u , Rerror , iter ) !! Preconditioned restart GMRES implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , ki , j , Out_iter real ( kind = realdp ) :: b_norm , Mres_norm , Mb_norm , MRerror , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , Mres , Mb , u0 , Au0 , Au , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Mres ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Mb ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Au0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) ! what if b is real? Mb = Precond_x ( b ) Mb_norm = norm ( Mb ) Out_iter = 0 Rerror = 1.d0 MRerror = 1.d0 do while ( MRerror . gt . eps ) Out_iter = Out_iter + 1 res = ( 0.d0 , 0.d0 ) Mres = ( 0.d0 , 0.d0 ) Au0 = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u0 , Au0 ) Mres = b - Au0 !r=b-Ax Mres = Precond_x ( Mres ) Mres_norm = norm ( Mres ) ! ||r|| MRerror = Mres_norm / Mb_norm ! scaled error? beta ( 1 ) = Mres_norm ! beta(1)=||r0|| V (:,:, 1 ) = Mres / Mres_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter !-Here m_iter is the iteration to restart k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. call Prearnoldi ( V , H , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) MRerror = CDABS ( beta ( k + 1 )) / Mb_norm enddo call back_substitute ( H , beta , k ) do ki = 1 , k u = u + beta ( ki ) * V (:,:, ki ) enddo !call Helmholtz2d(u,Au) call Helmholtz2d_BC ( u , Au ) res = b - Au res_norm = norm ( res ) Rerror = res_norm / b_norm if ( my_id == 0 ) then write ( * , \"(A,I9,A,E14.6,A,E14.6)\" ) \"   Outer Iteration   \" , Out_iter , \"   MError   \" , MRerror , \"   Error   \" , Rerror end if enddo deallocate ( sn , cs , beta ) deallocate ( res , Mres , Mb , u0 , Au0 , Au ) deallocate ( H ) deallocate ( V ) iter = Out_iter * m_iter end subroutine Pre_restartgmres !==================================================================================== !================================================================ subroutine arnoldi ( V , H , k ) !! ARNOLDI precess implicit none !-Subroutine arguments ------------------------------------------------------- integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 ), intent ( inout ) :: V complex ( kind = realdp ), dimension ( m_iter + 1 , m_iter ), intent ( inout ) :: H integer :: i !-Subroutine content --------------------------------------------------------- !- w=A*v_i call Helmholtz2d_BC ( V (:,:, k ), V (:,:, k + 1 )) do i = 1 , k H ( i , k ) = dot_prod ( V (:,:, i ), V (:,:, k + 1 )) !-Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = norm ( V (:,:, k + 1 )) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) end subroutine arnoldi !================================================================ subroutine Prearnoldi ( V , H , k ) !! Preconditioned ARNOLDI precess implicit none !-Subroutine arguments ------------------------------------------------------- integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 ), intent ( inout ) :: V complex ( kind = realdp ), dimension ( m_iter + 1 , m_iter ), intent ( inout ) :: H integer :: i !-Subroutine content --------------------------------------------------------- !- w=A*v_i call Helmholtz2d_BC ( V (:,:, k ), V (:,:, k + 1 )) !-Precondition V (:,:, k + 1 ) = Precond_x ( V (:,:, k + 1 )) do i = 1 , k H ( i , k ) = dot_prod ( V (:,:, i ), V (:,:, k + 1 )) !-Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = norm ( V (:,:, k + 1 )) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) end subroutine Prearnoldi !================================================================ subroutine apply_givens_rotation ( H , cs , sn , k ) !! APPLY GIVENS ROTATION implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( m_iter + 1 , m_iter ), intent ( inout ) :: H integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( m_iter + 1 ), intent ( inout ) :: cs , sn !-Local arguments ------------------------------------------------------------ complex ( kind = realdp ) :: temp integer :: i !-Subroutine content --------------------------------------------------------- do i = 1 , k - 1 temp = conjg ( cs ( i )) * H ( i , k ) + conjg ( sn ( i )) * H ( i + 1 , k ) H ( i + 1 , k ) = - sn ( i ) * H ( i , k ) + cs ( i ) * H ( i + 1 , k ) H ( i , k ) = temp end do if ( H ( k , k ) == 0. ) then cs ( k ) = 0.0d0 sn ( k ) = 1.0d0 else temp = CDSQRT (( CDABS ( H ( k , k ))) ** 2 + ( H ( k + 1 , k )) ** 2 ) cs ( k ) = H ( k , k ) / temp sn ( k ) = H ( k + 1 , k ) / temp end if H ( k , k ) = conjg ( cs ( k )) * H ( k , k ) + conjg ( sn ( k )) * H ( k + 1 , k ) H ( k + 1 , k ) = ( 0.0d0 , 0.0d0 ) end subroutine apply_givens_rotation !=============================================================== subroutine back_substitute ( H , beta , k ) !! Apply BACK SUBSTITUTION implicit none integer :: i integer , intent ( in ) :: k complex ( kind = realdp ), dimension ( m_iter + 1 , m_iter ), intent ( in ) :: H complex ( kind = realdp ), dimension ( m_iter + 1 ), intent ( inout ) :: beta beta ( k ) = beta ( k ) / H ( k , k ) do i = k - 1 , 1 , - 1 beta ( i ) = ( beta ( i ) - sum ( H ( i , i + 1 : k ) * beta ( i + 1 : k ))) / H ( i , i ) end do end subroutine back_substitute !==================================================================================== subroutine full_pgcr ( b , u , Rerror , iter ) !! Right preconditioned GCR implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , i , j complex ( kind = realdp ) :: alpha , beta real ( kind = realdp ) :: b_norm , res_norm , vv_norm complex ( kind = realdp ), allocatable , dimension (:,:) :: res , Au complex ( kind = realdp ), allocatable , dimension (:,:,:) :: vv , ss !-Subroutine content --------------------------------------------------------- allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( vv ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) allocate ( ss ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) res = ( 0.d0 , 0.d0 ) vv = ( 0.d0 , 0.d0 ) ss = ( 0.d0 , 0.d0 ) call Helmholtz2d_BC ( u , Au ) ! compute Ax res = b - Au !r=b-Ax res_norm = norm ( res ) ! ||r|| Rerror = res_norm / b_norm ! scaled error? k = 0 do i = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. ss (:,:, i ) = Precond_x ( res ) call Helmholtz2d_BC ( ss (:,:, i ), vv (:,:, i )) do j = 1 , i - 1 alpha = dot_prod ( vv (:,:, j ), vv (:,:, i )) ss (:,:, i ) = ss (:,:, i ) - alpha * ss (:,:, j ) vv (:,:, i ) = vv (:,:, i ) - alpha * vv (:,:, j ) end do vv_norm = norm ( vv (:,:, i )) ss (:,:, i ) = ss (:,:, i ) / vv_norm vv (:,:, i ) = vv (:,:, i ) / vv_norm beta = dot_prod ( vv (:,:, i ), res ) u = u + beta * ss (:,:, i ) res = res - beta * vv (:,:, i ) res_norm = norm ( res ) Rerror = res_norm / b_norm if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) k , Rerror open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) write ( 1234 , \"(I9,E17.9)\" ) k , Rerror close ( 1234 ) end if if ( Rerror < eps ) then exit end if end do call Helmholtz2d_BC ( u , Au ) res = b - Au res_norm = norm ( res ) Rerror = res_norm / b_norm deallocate ( res , Au ) deallocate ( vv ) deallocate ( ss ) iter = k end subroutine full_pgcr !==================================================================================== !==================================================================================== subroutine pfgmres ( b , u , Rerror , iter ) !! Flexible GMRES with right precondition implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( in ) :: b complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ), intent ( inout ) :: u real ( kind = realdp ), intent ( out ) :: Rerror integer , intent ( inout ) :: iter !-Local arguments ------------------------------------------------------------ integer :: k , ki , j , i real ( kind = realdp ) :: b_norm , res_norm complex ( kind = realdp ), allocatable , dimension (:) :: sn , cs , beta complex ( kind = realdp ), allocatable , dimension (:,:) :: res , u0 , Au , H complex ( kind = realdp ), allocatable , dimension (:,:,:) :: V , Z !-Subroutine content --------------------------------------------------------- allocate ( sn ( m_iter + 1 ), cs ( m_iter + 1 ), beta ( m_iter + 1 )) allocate ( res ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( u0 ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( Au ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP )) allocate ( H ( m_iter + 1 , m_iter )) allocate ( V ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) allocate ( Z ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP , m_iter + 1 )) b_norm = norm ( b ) res = ( 0.d0 , 0.d0 ) sn = ( 0.d0 , 0.d0 ) cs = ( 0.d0 , 0.d0 ) V = ( 0.d0 , 0.d0 ) H = ( 0.d0 , 0.d0 ) beta = ( 0.d0 , 0.d0 ) u0 = u call Helmholtz2d_BC ( u , Au ) ! compute Ax res = b - Au !r=b-Ax res_norm = norm ( res ) ! ||r|| Rerror = res_norm / b_norm beta ( 1 ) = res_norm ! beta(1)=||r0|| V (:,:, 1 ) = res / res_norm !  This is V(:,1) i.e. v1 in the algorithm k = 0 do j = 1 , m_iter k = k + 1 !-Be careful!!, after the whole iteration without achieving eps, then the value of j will be \"m_iter+1\".So we need a k. Z (:,:, k ) = Precond_x ( V (:,:, k )) call Helmholtz2d_BC ( Z (:,:, k ), V (:,:, k + 1 )) do i = 1 , k H ( i , k ) = dot_prod ( V (:,:, i ), V (:,:, k + 1 )) !-Attention: h_(i,j)=(w,v_i)=v&#94;H*w, for complex value, so the code should be dot_product(v_i,w) V (:,:, k + 1 ) = V (:,:, k + 1 ) - H ( i , k ) * V (:,:, i ) end do H ( k + 1 , k ) = norm ( V (:,:, k + 1 )) V (:,:, k + 1 ) = V (:,:, k + 1 ) / H ( k + 1 , k ) call apply_givens_rotation ( H , cs , sn , k ) beta ( k + 1 ) = - sn ( k ) * beta ( k ) beta ( k ) = conjg ( cs ( k )) * beta ( k ) Rerror = CDABS ( beta ( k + 1 )) / b_norm if ( my_id == 0 ) then write ( * , \"(I9,E17.9)\" ) k , Rerror open ( 1234 , file = trim ( logname ), position = 'APPEND' , status = 'OLD' ) write ( 1234 , \"(I9,E17.9)\" ) k , Rerror close ( 1234 ) end if if ( Rerror < eps ) then exit end if end do call back_substitute ( H , beta , k ) do ki = 1 , k u = u + beta ( ki ) * Z (:,:, ki ) enddo call Helmholtz2d_BC ( u , Au ) res = b - Au res_norm = norm ( res ) Rerror = res_norm / b_norm deallocate ( sn , cs , beta ) deallocate ( res , u0 , Au ) deallocate ( H ) deallocate ( V ) deallocate ( Z ) iter = k end subroutine pfgmres !==================================================================================== function Precond_x ( x ) !! This is a routine to select which preconditioner is applied, Precond_x = P&#94;(-1)x implicit none !-Subroutine arguments ------------------------------------------------------- complex ( kind = realdp ), dimension ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) :: x complex ( kind = realdp ) :: Precond_x ( 1 - LAP : nx + LAP , 1 - LAP : ny + LAP ) select case ( M_flag ) case ( 1 ) !-Multigrid based CSLP Precond_x = MGCSLP_invMx ( x ) case ( 2 : 5 ) !-Deflation preconditioning Precond_x = DEF_Px ( x ) case default !-No precondition Precond_x = x end select end function Precond_x end module solvers","tags":"","loc":"sourcefile/solvers.f90.html"}]}