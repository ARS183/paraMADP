<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Documentation for ParaMADP">
    <meta name="author" content="Jinqiang Chen" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; ParaMADP
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">ParaMADP </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../program/helmholtz_2d.html">Program</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr>
                 <td><a href='../proc/apply_givens_rotation.html'>apply_givens_rotation</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>APPLY GIVENS ROTATION </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/arnoldi.html'>arnoldi</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>ARNOLDI precess</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/back_substitute.html'>back_substitute</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply BACK SUBSTITUTION </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_x2d.html'>check_x2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data in the x direction, ONLY for the default (finest) grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_xy2d.html'>check_xy2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data first in the x direction and then y direction, ONLY for the default (finest) grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/check_y2d.html'>check_y2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data in the y direction, ONLY for the default (finest) grid system
no2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cmatvec.html'>cmatvec</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Function</td>
                 <td><p>This is complex matrix-vector multiplication</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/coarsegrid_create.html'>coarsegrid_create</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a routine that define a coarse grid system mg_coarse from a fine grid system mg_fine</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/coarsegridpara.html'>CoarseGridpara</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A procedure to create a Gridpara type of the coarse grid system from a given a two-grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/const_k.html'>Const_K</a></td>
                 <td><a href='../module/wavenumber.html'>wavenumber</a></td>
                 <td>Subroutine</td>
                 <td><p>constant wavenumber, determine by input variable k0
data communication with neighbouring subdomains</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cprecon.html'>cprecon</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Function</td>
                 <td><p>This is an preconditioner for complex-type input v, i.e. M1^(-1)v
We can manully call different preconditioners here. Here only use multigrid-based CLSP </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cslp2d_stencils.html'>cslp2d_stencils</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>Computational stencils for the CSLP operator</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cslp_mx_nth.html'>CSLP_Mx_nth</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p><em>ReD-Glk</em> CSLP operator for coarse levels</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cslp_mx_nth_stencils.html'>CSLP_Mx_nth_stencils</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p><em>ReD-Glk</em> computational stencils of the CSLP operator for differnet coarse-grid level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/cslp_op_bc.html'>CSLP_OP_BC</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>matrix-free CSLP operator, for the specified gird systems</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/damp_jacobi_smoother.html'>Damp_Jacobi_smoother</a></td>
                 <td><a href='../module/smoother.html'>smoother</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a routine to apply damped Jacobbi smoother on coarse grid systems.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_apply_givens_rotation.html'>def_apply_givens_rotation</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Apply givens rotation of DEF_fullgmres</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_arnoldi.html'>def_arnoldi</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Arnoldi prosess of DEF_fullgmres
Attention: h_(i,j)=(w,v_i)=v^H*w, for complex value, so the code should be dot_product(v_i,w)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_back_substitute.html'>def_back_substitute</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Perform back substitute in of DEF_fullgmres</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_bicgstab.html'>DEF_bicgstab</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>A (CSLP preconditioned) Bi-CGSTAB solver for the coarse-grid problem in two-level deflation method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_fullgmres.html'>DEF_fullgmres</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>A (CSLP preconditioned) GMRES solver for the coarse-grid problem in two-level deflation method
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "def_mg_miter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_prefgmres.html'>DEF_prefgmres</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>A recursive flexible GMRES with right deflation preconditioning
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "maxit+1".So we need a k.</p><a href="../proc/def_prefgmres.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/def_px.html'>DEF_Px</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Identifier for different deflation methods, ONLY for an input array from the default (finest) grid system
A basic deflation method</p><a href="../proc/def_px.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/default_gridpara.html'>default_gridpara</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a rountine to define the default finest Gridpara from the common grid parameters of the whole project </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/define_marmousi_grid.html'>define_marmousi_grid</a></td>
                 <td><a href='../module/define_grid.html'>define_grid</a></td>
                 <td>Subroutine</td>
                 <td><p>Marmousi problem</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/define_uniform_grid.html'>define_uniform_grid</a></td>
                 <td><a href='../module/define_grid.html'>define_grid</a></td>
                 <td>Subroutine</td>
                 <td><p>A square computational domain with a unit side length</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/define_wedge_grid.html'>define_wedge_grid</a></td>
                 <td><a href='../module/define_grid.html'>define_grid</a></td>
                 <td>Subroutine</td>
                 <td><p>Wedge model problem</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dirichlet.html'>Dirichlet</a></td>
                 <td><a href='../module/define_bc.html'>define_BC</a></td>
                 <td>Subroutine</td>
                 <td><p>Dirichlet, ap=h^2, which will devided by h^2 in the rountine of the operator
When use this Dirichlet, you have to be carefull with the RHS respectively</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/dot_prod.html'>dot_prod</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute the do product of two complex variables, ONLY for the default grid system.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ex.html'>Ex</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Coarse-grid operation for two-level deflation
Straight-forward Galerkin coarsening approach</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exact_2dcloseoff.html'>exact_2DCloseOff</a></td>
                 <td><a href='../module/analytical_sol.html'>analytical_sol</a></td>
                 <td>Subroutine</td>
                 <td><p>The analytical solution for 2D close-off problem</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exact_2dpointsource_1stsomer.html'>exact_2DPointSource_1stSomer</a></td>
                 <td><a href='../module/analytical_sol.html'>analytical_sol</a></td>
                 <td>Subroutine</td>
                 <td><p>The analytical solution for constant wavenumber problem with central source point with Sommerfeld boundary condition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/exact_2dpointsource_dirichlet.html'>exact_2DPointSource_Dirichlet</a></td>
                 <td><a href='../module/analytical_sol.html'>analytical_sol</a></td>
                 <td>Subroutine</td>
                 <td><p>The analytical solution for constant wavenumber problem with central source point with Dirichlet boundary condition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/extrpltghostbcs.html'>ExtrpltGhostBCs</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Extrapolate a layer of ghost grid points based on the boundary conditions 
The zero padding of wavenumber is ok in practical</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/f_cycle.html'>F_cycle</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a classic F-cycle multigrid </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/finestgrid_define.html'>finestgrid_define</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a routine that define the finest grid system from the default (finest) grid parameters</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/first_order_neum.html'>first_order_Neum</a></td>
                 <td><a href='../module/define_bc.html'>define_BC</a></td>
                 <td>Subroutine</td>
                 <td><p>Sommerfeld boundary conditions. Eliminate the ghost grid points by second-order discretization</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/frob_norm.html'>FROB_NORM</a></td>
                 <td><a href='../module/idrs_module.html'>idrs_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fromfine2coarse.html'>FromFine2Coarse</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A procedure to create a two-grid system from a given fine Gridpara type
The wavenumber of the coarse level is restricted from the fine level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/full_pgcr.html'>full_pgcr</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Right preconditioned GCR 
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/full_pgmres.html'>full_pgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Full GMRES with right precondition
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/fullgmres.html'>fullgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Full GMRES without precondition
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/grid_destroy.html'>grid_destroy</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a routine that deallocate the arrays of a grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/gridbase_extrpltghostbcs.html'>GridBase_ExtrpltGhostBCs</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>Extrapolation of a layer of ghost grid points</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/gridsys_define.html'>gridsys_define</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a routine that define a GridSystem type from the grid parameters of a data type Gridpara
One can find the differnece of GridSystem and Gridpara </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helm_a2hx.html'>Helm_A2hx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A function that performs the Helmholtz operator on the coarse grid of the two-grid system, by different methods
ReD-O2
ReD-Glk
ReD-cmpO4</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helm_ahx.html'>Helm_Ahx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A function that performs the Helmholtz operator on the fine grid of the two-grid system, by ReD-O2 method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helm_ax_nth.html'>Helm_Ax_nth</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p><em>ReD-Glk</em> Helmholtz operator for coarse levels</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helm_ax_nth_stencils.html'>Helm_Ax_nth_stencils</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p><em>ReD-Glk</em> computational stencils of the Helmholtz operator for differnet coarse-grid level
Default 2nd-ordr stencils</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helmholtz2d_bc.html'>Helmholtz2d_BC</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>matrix-free Helmholtz operator, ONLY for the default gird system
First deal with the boundary grid points and then the internals</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helmholtz2d_bc_mg.html'>Helmholtz2d_BC_mg</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>matrix-free Helmholtz operator, for the specified coarse gird systems</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helmholtz2d_o4cmpct.html'>Helmholtz2d_O4cmpct</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>A coarse-grid Helmholtz operator for two-level deflation, descretized by a classic compact fourth-order FD scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helmholtz2d_red_glk.html'>Helmholtz2d_ReD_Glk</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>A coarse-grid Helmholtz operator for two-level deflation, descretized by ReD-GLK FD scheme
fill in a layer of ghost grid points by boundary conditions</p><a href="../proc/helmholtz2d_red_glk.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/helmholtz2d_stencils.html'>Helmholtz2d_stencils</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Subroutine</td>
                 <td><p>Computational stencils for the Helmholtz operator, second-order central FD scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/idrs.html'>IDRS</a></td>
                 <td><a href='../module/idrs_module.html'>idrs_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/if_bcs.html'>if_BCs</a></td>
                 <td><a href='../module/define_bc.html'>define_BC</a></td>
                 <td>Subroutine</td>
                 <td><p>Determine which BC, for specified coarse grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/invey.html'>invEy</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Invert the coarse-grid operator for two-level delfation method, by using GMRES or Bi-CGSTAB
determined by the specified maximum number of iterations on the coarse grid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/krylovcslp_invmhx.html'>KrylovCSLP_invMHx</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Function</td>
                 <td><p>Krylov-based CSLP, starts from the a specified grid sysyem
Choose Bi-CGSATB or GMRES by uncomment or comment </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/log2.html'>LOG2</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute log2(x)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_apply_givens_rotation.html'>mg_apply_givens_rotation</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is routine to perform apply_givens_rotation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_arnoldi.html'>mg_arnoldi</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>Arnoldi precess
 w=A*v_i</p><a href="../proc/mg_arnoldi.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_back_substitute.html'>mg_back_substitute</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is routine that performs back substitute</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_bicgstab.html'>mg_bicgstab</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using Bi-CGSTAB
The CSLP is define by ReD-O2 scheme</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_check_x2d.html'>mg_check_x2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data in the x direction, for a specified-size grid system
no2
no2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_check_xy2d.html'>mg_check_xy2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data first in the x direction and then y direction, for a specified-size grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_check_y2d.html'>mg_check_y2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges data in the y direction, for a specified-size grid system
no2
no2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_checkreal_x2d.html'>mg_checkreal_x2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges REAL data in the x direction, for a specified-size grid system
no2
no2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_checkreal_xy2d.html'>mg_checkreal_xy2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges REAL data first in the x direction and then y direction, for a specified-size grid system</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_checkreal_y2d.html'>mg_checkreal_y2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Exchanges REAL data in the y direction, for a specified-size grid system
no2
no2</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_dot_prod.html'>mg_dot_prod</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute the dot product of two complex variables, for a coarse-grid system.
Note that the dimension is not specified here, it means it calculate all the elements</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_fullgmres.html'>mg_fullgmres</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a rountine to solve the (specified) coarsest-grid CSLP system approximately by using GMRES
 The CSLP is define by ReD-O2 scheme
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.
 The default tolerance is 1E-08</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mg_norm.html'>mg_norm</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute the L2-norm of a complex variable, for a coarse-grid system.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mgcslp_invmhx.html'>MGCSLP_invMHx</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Function</td>
                 <td><p>Multigrid-based CSLP, starts from the a specified grid system
One V-cycle
Two V-cycle
One F-cycle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/mgcslp_invmx.html'>MGCSLP_invMx</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Function</td>
                 <td><p>Multigrid-Based CSLP, ONLY starts from the default (finest) grid sysyem
One V-cycle
Two V-cycle
One F-cycle</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/multilevel_invey.html'>MultiLevel_invEy</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A recursive function to invert the coarse-level operators for multilevel delfation methods, by using preconditioned FGMRES</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/multileveladp_px.html'>MultiLevelADP_Px</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Multilevel deflation preconditioning (MADP) 
Multigrid-based CSLP on the finest and second level
Krylov-based CSLP on the finest and second level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/my_mod1.html'>my_mod1</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Function</td>
                 <td><p>A function to calculate the modulo of two integers na and nb</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/norm.html'>norm</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute the L2-norm of a complex variable, ONLY for the default grid system.</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(ASTERISK).html'>OPERATOR(*)</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/operator(SLASH).html'>OPERATOR(/)</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/p_adef1x.html'>P_ADEF1x</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Adapted Deflation Preconditioning, P = M^(-1)(I-AQ)+Q, including higher-order deflation (ADP) if LAP &gt; 1</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/p_defx.html'>P_DEFx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Deflation preconditioning, P = (I-AQ)+Q</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/p_dot.html'>P_DOT</a></td>
                 <td><a href='../module/idrs_module.html'>idrs_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/p_tlkmx.html'>P_TLKMx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Two-Level Krylov Method, P = [(I-M^(-1)AQ<code>)+Q</code>]M^(-1), where Q' is defined based on M^(-1)A
M^(-1)x
QM^(-1)x</p><a href="../proc/p_tlkmx.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/part2d.html'>part2d</a></td>
                 <td><a href='../module/mpi_setup.html'>mpi_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>Partitions the 2D domain for parallel processing and calculates offsets and sizes for each partition
the ID of partion along 2 directions
-1 proc in x-direction
+1 proc in x-direction
if not periodic, 0 node donot send mesg to npx0-1 node
if not periodic, npx0-1 node donot send mesg to 0 node</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pfgmres.html'>pfgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Flexible GMRES with right precondition 
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pre_fullgmres.html'>Pre_fullgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Full GMRES with left preconditioned
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/pre_restartgmres.html'>Pre_restartgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Preconditioned restart GMRES 
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/prearnoldi.html'>Prearnoldi</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Preconditioned ARNOLDI precess</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/precond_x.html'>Precond_x</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Function</td>
                 <td><p>This is a routine to select which preconditioner is applied, Precond_x = P^(-1)x</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/prolongation_en_correct.html'>prolongation_en_correct</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is routine that perform bilinear interpolation and correction from coarse to fine grid system, mainly
solution (u) on coarse grid --&gt; correction (e_h) for solution (u) of fine grid
Based on the relationship of the index between the fine and coarse grid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/px.html'>Px</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Perform y=Px in deflation definition, where P=I-AQ</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/qx.html'>Qx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Perform y=Qx in deflation definition, where Q=ZE^(-1)Z^T</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/read_parameter.html'>read_parameter</a></td>
                 <td><a href='../module/read_setup.html'>read_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>read the input parameters for the solver settings
Read by Rank 0 and then broadcast to the other ranks
Get the input filename</p><a href="../proc/read_parameter.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/read_wavenumber_k_marmousi.html'>read_wavenumber_k_marmousi</a></td>
                 <td><a href='../module/wavenumber.html'>wavenumber</a></td>
                 <td>Subroutine</td>
                 <td><p>Read the velocity profile of Marmousi problem with specified grid size and calculate the wavenumber</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/realnorm.html'>Realnorm</a></td>
                 <td><a href='../module/operators.html'>operators</a></td>
                 <td>Function</td>
                 <td><p>Compute the L2-norm of a real variable, ONLY for the default grid system.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/red_glk_cslp_bicgstab.html'>ReD_Glk_CSLP_bicgstab</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a rountine to solve a coarse grid CSLP system approximately by using Bi-CGSTAB. 
The CSLP operator is defined by ReD-Glk scheme. 
CSLP operator by ReD-Glk </p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/red_glk_cslp_gmres.html'>ReD_Glk_CSLP_gmres</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is a rountine to solve a coarse grid CSLP system approximately by using GMRES
 The CSLP operator is defined by ReD-Glk scheme
 CSLP operator by ReD-Glk </p><a href="../proc/red_glk_cslp_gmres.html" class="pull-right"><emph>Read more&hellip;</emph></a></td>
               </tr>
			   <tr>
                 <td><a href='../proc/red_glk_stencils.html'>ReD_Glk_stencils</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p><em>ReD-Glk</em> computational stencils of the Helmholtz operator for coarse-grid level in two-deflation method</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/restartgmres.html'>restartgmres</a></td>
                 <td><a href='../module/solvers.html'>solvers</a></td>
                 <td>Subroutine</td>
                 <td><p>Restart GMRES
Be careful!!, after the whole iteration without achieving eps, then the value of j will be "m_iter+1".So we need a k.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/restriction.html'>restriction</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>This is routine that perform full-weight resctriction from fine to coarse grid system, mainly
residual (res) on fine grid --&gt; right-hand side (rhs) on coarse grid,
wavenumber on fine grid --&gt; wavenumber on the coarse grid
Based on the relationship of the index between the fine and coarse grid</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rhs_2dcloseoff.html'>RHS_2DCloseOff</a></td>
                 <td><a href='../module/define_rhs.html'>define_rhs</a></td>
                 <td>Subroutine</td>
                 <td><p>2D close-off problem with Dirichlet boundary condition</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rhs_2dwedge.html'>RHS_2DWedge</a></td>
                 <td><a href='../module/define_rhs.html'>define_rhs</a></td>
                 <td>Subroutine</td>
                 <td><p>2D Wedge problem
A point source located at (300,0)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rhs_centersource2d.html'>RHS_CenterSource2D</a></td>
                 <td><a href='../module/define_rhs.html'>define_rhs</a></td>
                 <td>Subroutine</td>
                 <td><p>2D constant wavenumber problem with a central point source
A point source located at (0.5,0.5)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rhs_marmousi.html'>RHS_marmousi</a></td>
                 <td><a href='../module/define_rhs.html'>define_rhs</a></td>
                 <td>Subroutine</td>
                 <td><p>Marmousi problem
A point source located at (6000,0)</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rmatvec.html'>rmatvec</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Function</td>
                 <td><p>This is an empty matrix-vector multiplication for real-type input v</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/rprecon.html'>rprecon</a></td>
                 <td><a href='../module/user_module.html'>user_module</a></td>
                 <td>Function</td>
                 <td><p>This is an empty preconditioner for real-type input v</p></td>
               </tr>
			   <tr>
                 <td><a href='../interface/trace_dot.html'>TRACE_DOT</a></td>
                 <td><a href='../module/idrs_module.html'>idrs_module</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../interface/twogrids.html'>TwoGrids</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Interface</td>
                 <td></td>
               </tr>
			   <tr>
                 <td><a href='../proc/v_cycle.html'>V_cycle</a></td>
                 <td><a href='../module/cslp_solver.html'>CSLP_Solver</a></td>
                 <td>Subroutine</td>
                 <td><p>A classic multigrid V-cycle
A classic Two-Cycle
GMRES or Bi-CGSTAB can be chose to solve the coarse-grid problem
GMRES or Bi-CGSTAB can be chose to solve the coarsest-grid problem</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wavenumber_fwrestriction.html'>wavenumber_FWrestriction</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Subroutine</td>
                 <td><p>This routine obtains the wavenumber of the coarse level by full-weight restriction from the fine level</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wavenumber_k_destroy.html'>wavenumber_k_destroy</a></td>
                 <td><a href='../module/wavenumber.html'>wavenumber</a></td>
                 <td>Subroutine</td>
                 <td><p>Deallocate the wavenumber field in the end</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/wavenumber_k_wedge.html'>wavenumber_k_Wedge</a></td>
                 <td><a href='../module/wavenumber.html'>wavenumber</a></td>
                 <td>Subroutine</td>
                 <td><p>Wavenumber for Wedge model problem
The top layer
The bottom layer
The middle layer</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/write_data_whole.html'>write_data_whole</a></td>
                 <td><a href='../module/write_data.html'>write_data</a></td>
                 <td>Subroutine</td>
                 <td><p>Write the solutions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/write_exact_data_whole.html'>write_exact_data_whole</a></td>
                 <td><a href='../module/write_data.html'>write_data</a></td>
                 <td>Subroutine</td>
                 <td><p>Write the analytical solutions</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/write_real_data_whole.html'>write_real_data_whole</a></td>
                 <td><a href='../module/write_data.html'>write_data</a></td>
                 <td>Subroutine</td>
                 <td><p>Write the real wavenumber/variables</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ztx.html'>ZTx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Restriction of a variable, by full-weight restriction or higher-order restriction depending on the laylers of overlapping grid points used.</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/ztzx.html'>ZTZx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>A routine that first perform restriction and then interpolation</p></td>
               </tr>
			   <tr>
                 <td><a href='../proc/zx.html'>Zx</a></td>
                 <td><a href='../module/deflaion_setup.html'>deflaion_setup</a></td>
                 <td>Function</td>
                 <td><p>Interpolation of a variable from coarse to fine, by bilinear or higher-order interpolation depending on the laylers of overlapping grid points used.</p></td>
               </tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              ParaMADP
 was developed by Jinqiang Chen<br>              &copy; 2024 <a rel="license" href="https://opensource.org/licenses/MIT">MIT</a>
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>